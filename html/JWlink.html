<HEAD>
<TITLE> JWlink v1.9 Guide </TITLE>
</HEAD>
<BODY>

<H1 ID="About_JWlink"> About JWlink </H1>
JWlink is a linkage editor (linker) that takes object and library files as input and produces executable files
as output.
<P>The following object module and library formats are supported:
<P>
<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#C0C0C0"><TH ALIGN="LEFT">Format</TH><TH ALIGN="LEFT">Comment</TH></TR>
<TR BGCOLOR="#E0E0E0"><TD>OMF</TD><TD>the standard Intel Object Module Format, including Microsoft's 32-bit extensions</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>COFF</TD><TD>both 32-bit and 64-bit variants of this format</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>ELF</TD><TD>both 32-bit and 64-bit variants of this format</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>OMF-386</TD><TD>Phar Lap's 32-bit OMF variant (Easy OMF)</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>OMF</TD><TD>library format</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>AR</TD><TD>object library format (Microsoft, GNU or BSD compatible)</TD></TR>
</TABLE>
</TD></TR>
</TABLE>

<P>The executable file formats supported by JWlink are:
<P>
<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#C0C0C0"><TH ALIGN="LEFT">OS</TH><TH ALIGN="LEFT">Comment</TH></TR>
<TR BGCOLOR="#E0E0E0"><TD>DOS</TD><TD>executable files, including .COM format</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>DOS</TD><TD>binaries for various DOS extenders (CauseWay, HX, PMODE, DOS/4G, Phar Lap, ...)</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>OS/2</TD><TD>16- and 32-bit binaries, including Dynamic Link Libraries</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>Windows</TD><TD>16-, 32- and 64-bit binaries, including Dynamic Link Libraries</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>Windows</TD><TD>Virtual Device Drivers (VxD) for Windows 3.x/9x/ME</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>Unix, Linux</TD><TD>32- and 64-bit executable files in ELF format</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>QNX</TD><TD>16- and 32-bit executable files</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>NetWare</TD><TD>Netware Loadable Modules (NLMs)</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD></TD><TD>raw binary images</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD></TD><TD>Intel Hex files (Hex80, Hex86 and extended linear)</TD></TR>
</TABLE>
</TD></TR>
</TABLE>

<P>JWlink binaries are available for the following operating systems:

<UL>
<LI>Windows 32-bit platforms</LI>
<LI>OS/2</LI>
<LI>DOS</LI>
<LI>Linux</LI>
</UL>

<P>We refer to the operating system upon which you run JWlink as the &quot;host&quot;.
<P>Chapter <A HREF="#Linking_Executable_Files_for_Various_Systems">Linking Executable Files for Various Systems</A>
summarizes the most commonly used executable file formats that can be generated by the linker.&nbsp; The chapter entitled <A HREF="#Linker_Directives_and_Options">Linker Directives and Options</A>
describes all of the linker directives and options.&nbsp; The remaining chapters describe aspects of each of the executable
file formats.

<H2 ID="JWlink_Commandline"> JWlink Commandline </H2>

<P>The JWlink command line format is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink {directive}</TT>

<P>where<B><I> directive</I></B> is a series of JWlink directives specified on the command line or in one or more
files.&nbsp; If the directives are contained within a file, the &quot;@&quot; character is used to reference that file.&nbsp;
If no file extension is specified, a file extension of &quot;lnk&quot; is assumed.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink name testprog @first @second option map</TT>
<P>In the above example, directives are specified on the command line (e.g., &quot;name testprog&quot; and &quot;option map&quot;)
and in files (e.g.,<TT> first.lnk</TT> and<TT> second.lnk</TT>).

<P>To make JWlink display the available directives in full detail, enter;
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink ?</TT>

<P>If jwlink is launched without any arguments at all, it will enter interactive mode,
display prompt &quot;JWLINK&gt;&quot; and wait for user input.
You can then enter as many lines of directive information
as required.&nbsp; Press &quot;Ctrl/Z&quot; followed by the &quot;Enter&quot; key to terminate the input of directive information
if you are running a DOS, OS/2 or Windows NT-hosted version of JWlink.&nbsp; Press &quot;Ctrl/D&quot;
to terminate the input of directive information if you are running a UNIX-hosted version of JWlink.

<H1 ID="Linking_Executable_Files_for_Various_Systems"> Linking Executable Files for Various Systems </H1>

There exist 2 ways to tell the linker what kind of binary it is to create.
One may either use the <A HREF="#FORMAT_Directive">FORMAT</A> directive, optionally in conjunction
with additional directives ( <A HREF="#RUNTIME_Directive">RUNTIME</A>, <A HREF="#LIBRARY_Directive">LIBRARY</A>, ... )
or one may use the <A HREF="#SYSTEM_Directive">SYSTEM</A> directive.
The <A HREF="#SYSTEM_Directive">SYSTEM</A> directive allows to select a set of other directives and values with a single name.
That's why for the most common executable formats predefined system definitions have been made available.

<H2 ID="Using_the_SYSTEM_Directive"> Predefined System Definitions </H2>

<P>The sytem definitions listed below are defined in a special linker directive file,<TT> jwlink.lnk, </TT>consisting of editable plain ASCII text.
<P><TT> jwlink.lnk</TT> is automatically processed by JWlink
before processing any other directives.&nbsp; On a DOS, OS/2, or Windows-hosted system, this file must be located in
one of the paths specified in the<B> PATH</B> environment variable.&nbsp;
<P>
<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#C0C0C0"><TH ALIGN="LEFT">System</TH>   <TH ALIGN="LEFT">Description</TH></TR>
<TR BGCOLOR="#E0E0E8"><TD><A HREF="#Linking_DOS_16Mbit_Executable_Files">com</A></TD>      <TD>DOS 16-bit &quot;.COM&quot; executable</TD></TR>
<TR BGCOLOR="#E0E0E8"><TD><A HREF="#Linking_DOS_16Mbit_Executable_Files">dos</A></TD>      <TD>DOS 16-bit executable</TD></TR>
<TR BGCOLOR="#E0E0E8"><TD><A HREF="#Linking_DOSMextended_16Mbit_HX_Executable_Files">hx16</A></TD>     <TD>DOS-extended 16-bit HX executable</TD></TR>
<TR BGCOLOR="#E0E0E8"><TD><A HREF="#Linking_DOSMextended_32Mbit_CauseWay_Executable_Files">causeway</A></TD> <TD>DOS-extended 32-bit CauseWay executable</TD></TR>
<TR BGCOLOR="#E0E0E8"><TD><A HREF="#Linking_DOSMextended_32Mbit_CauseWay_Dynamic_Link_Libraries">cwdllr</A></TD>   <TD>DOS-extended 32-bit CauseWay Dynamic Link Library (register calling convention)</TD></TR>
<TR BGCOLOR="#E0E0E8"><TD><A HREF="#Linking_DOSMextended_32Mbit_CauseWay_Dynamic_Link_Libraries">cwdlls</A></TD>   <TD>DOS-extended 32-bit CauseWay Dynamic Link Library (stack calling convention)</TD></TR>
<TR BGCOLOR="#E0E0E8"><TD><A HREF="#Linking_DOSMextended_32Mbit_HX_Executable_Files">hx32</A></TD>     <TD>DOS-extended 32-bit HX executable</TD></TR>
<TR BGCOLOR="#E0E0E8"><TD><A HREF="#Linking_DOSMextended_32Mbit_HX_Dynamic_Link_Libraries">hx32_dll</A></TD> <TD>DOS-extended 32-bit HX Dynamic Link Library</TD></TR>
<TR BGCOLOR="#E0E0E8"><TD><A HREF="#Linking_DOSMextended_32Mbit_HX_Executable_Files_Win32stat">hx32s</A></TD>    <TD>DOS-extended 32-bit HX executable (statically linked Win32 emulation)</TD></TR>

<TR BGCOLOR="#E0E8E0"><TD><A HREF="#Linking_Windows_3_x_16Mbit_Executable_Files">win16</A></TD>    <TD>Windows 3.x 16-bit executable</TD></TR>
<TR BGCOLOR="#E0E8E0"><TD><A HREF="#Linking_Windows_3_x_16Mbit_Dynamic_Link_Libraries">win16_dll</A></TD><TD>Windows 3.x 16-bit Dynamic Link Library</TD></TR>
<TR BGCOLOR="#E0E8E0"><TD><A HREF="#Linking_Windows_3_x_or_9x_32Mbit_Virtual_Device_Driver">win_vxd</A></TD>  <TD>Windows 3.x or 9x 32-bit Virtual Device Driver</TD></TR>
<TR BGCOLOR="#E0E8E0"><TD><A HREF="#Linking_Win32DWin64_CharacterMMode_Executable_Files">pe_con</A></TD>   <TD>Win32/Win64 character-mode executable</TD></TR>
<TR BGCOLOR="#E0E8E0"><TD><A HREF="#Linking_Win32DWin64_Windowed_Executable_Files">pe_gui</A></TD>   <TD>Win32/Win64 windowed executable</TD></TR>
<TR BGCOLOR="#E0E8E0"><TD><A HREF="#Linking_Win32DWin64_Dynamic_Link_Libraries">pe_dll</A></TD>   <TD>Win32/Win64 Dynamic Link Library</TD></TR>
<TR BGCOLOR="#E0E8E0"><TD><A HREF="#Linking_Win32DWin64_CharacterMMode_Executable_Files">pe</A></TD>       <TD>synonym for &quot;pe_con&quot;</TD></TR>

<TR BGCOLOR="#E8E0E0"><TD><A HREF="#Linking_OSD2_16Mbit_Executable_Files">os2</A></TD>      <TD>OS/2 16-bit executable</TD></TR>
<TR BGCOLOR="#E8E0E0"><TD><A HREF="#Linking_OSD2_16Mbit_Dynamic_Link_Libraries">os2_dll</A></TD>  <TD>OS/2 16-bit Dynamic Link Library</TD></TR>
<TR BGCOLOR="#E8E0E0"><TD><A HREF="#Linking_OSD2_16Mbit_Presentation_Manager_Executable_Files">os2_pm</A></TD>   <TD>OS/2 16-bit Presentation Manager executable</TD></TR>
<TR BGCOLOR="#E8E0E0"><TD><A HREF="#Linking_OSD2_32Mbit_Executable_Files">os2v2</A></TD>    <TD>OS/2 32-bit executable</TD></TR>
<TR BGCOLOR="#E8E0E0"><TD><A HREF="#Linking_OSD2_32Mbit_Dynamic_Link_Libraries">os2v2_dll</A></TD><TD>OS/2 32-bit Dynamic Link Library</TD></TR>
<TR BGCOLOR="#E8E0E0"><TD><A HREF="#Linking_OSD2_32Mbit_Presentation_Manager_Executable_Files">os2v2_pm</A></TD> <TD>OS/2 32-bit Presentation Manager executable</TD></TR>
</TABLE>
</TD></TR></TABLE>

<P>The default name of the linker directive file (<TT>jwlink.lnk</TT>) can be overridden by the<B> JWLINK_LNK</B> environment
variable.&nbsp; If the specified file can't be opened, the default file name will be used.&nbsp; For example, if the<B> JWLINK_LNK</B>
environment variable is defined as follows
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; set JWLINK_LNK=my.lnk</TT>
<P>then JWlink will attempt to use a<TT> my.lnk</TT> directive file, and if that file cannot be opened, the
linker will revert to using the default<TT> jwlink.lnk</TT> file.
<P>In the following sections, we show some of the typical directives that you might use to create a particular executable
file format.&nbsp; The common directives are described in the chapter entitled <A HREF="#Linker_Directives_and_Options">Linker Directives and Options</A>.
&nbsp;They are &quot;common&quot; in the sense that they may be used with any executable format.&nbsp; There are other, less
general, directives that may be specified for a particular executable format.&nbsp; In each of the following sections, we
refer you to chapters in which you will find more information on the directives available with the executable format used.
<P>At this point, it should be noted that various systems have adopted particular executable file formats.&nbsp; For example,
the CauseWay DOS extender, Tenberry Software DOS/4G(W) and FlashTek DOS extenders all support one of the OS/2 executable file
formats.&nbsp; It is for this reason that you may find that we direct you to a chapter which would, at first glance, seem
unrelated to the executable file format in which you are interested.
<P>To summarize, the steps that you should follow to learn about creating a particular executable are:
<OL>
<LI>Look for a section in this chapter that describes the executable format in which you are interested.
<LI>See the chapter entitled <A HREF="#Linker_Directives_and_Options">Linker Directives and Options</A> for a description
of the common directives.
<LI>If you require additional information, see also the chapter to which we have referred you.
</OL>

<H2 ID="Linking_16Mbit_Executable_Files"> Linking 16-bit Executable Files </H2>

The following sections describe how to link a variety of 16-bit executable files
using the predefined system definitions included in <TT>jwlink.lnk</TT>.

<H3 ID="Linking_DOS_16Mbit_Executable_Files"> Linking DOS 16-bit Executable Files </H3>
<P>To create a DOS 16-bit executable, there are 2 systems defined:
<P>
<P>To create a DOS .EXE executable, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>dos</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>
<P>To create a DOS .COM executable, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>com</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#DOS_Executable_File_Format">DOS Executable File Format</A>.

<H3 ID="Linking_DOSMextended_16Mbit_HX_Executable_Files"> Linking DOS-extended 16-bit HX Executable Files </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>hx16</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#Win16_Executable_and_DLL_File_Formats">Win16 Executable and DLL File Formats</A>.

<H3 ID="Linking_OSD2_16Mbit_Executable_Files"> Linking OS/2 16-bit Executable Files </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>os2</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#OSD2_Executable_and_DLL_File_Formats">OS/2 Executable and DLL File Formats</A>.

<H3 ID="Linking_OSD2_16Mbit_Dynamic_Link_Libraries"> Linking OS/2 16-bit Dynamic Link Libraries </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>os2_dll</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#OSD2_Executable_and_DLL_File_Formats">The OS/2 Executable and DLL File Formats</A>.

<H3 ID="Linking_OSD2_16Mbit_Presentation_Manager_Executable_Files"> Linking OS/2 16-bit Presentation Manager Executable Files </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>os2_pm</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#OSD2_Executable_and_DLL_File_Formats">OS/2 Executable and DLL File Formats</A>.

<H3 ID="Linking_Windows_3_x_16Mbit_Executable_Files"> Linking Windows 3.x 16-bit Executable Files </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>win16</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#Win16_Executable_and_DLL_File_Formats">Win16 Executable and DLL File Formats</A>.

<H3 ID="Linking_Windows_3_x_16Mbit_Dynamic_Link_Libraries"> Linking Windows 3.x 16-bit Dynamic Link Libraries </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>win16_dll</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#Win16_Executable_and_DLL_File_Formats">Win16 Executable and DLL File Formats</A>.

<H2 ID="Linking_32Mbit_Executable_Files"> Linking 32- and 64-bit Executable Files </H2>

The following sections describe how to create a variety of 32- and 64-bit executable files
using the predefined system definitions included in <TT>jwlink.lnk</TT>.

<H3 ID="Linking_DOSMextended_32Mbit_CauseWay_Executable_Files"> Linking DOS-extended 32-bit CauseWay Executable Files </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>causeway</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#OSD2_Executable_and_DLL_File_Formats">OS/2 Executable and DLL File Formats</A>.

<H3 ID="Linking_DOSMextended_32Mbit_CauseWay_Dynamic_Link_Libraries"> Linking DOS-extended 32-bit CauseWay Dynamic Link Libraries </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>cwdllr</b> or <b>cwdlls</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#OSD2_Executable_and_DLL_File_Formats">OS/2 Executable and DLL File Formats</A>.

<H3 ID="Linking_DOSMextended_32Mbit_HX_Executable_Files"> Linking DOS-extended 32-bit HX Executable Files </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp;  <b>hx32</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#Win32_Executable_and_DLL_File_Formats">Win32/Win64 Executable and DLL File Formats</A>.

<H3 ID="Linking_DOSMextended_32Mbit_HX_Dynamic_Link_Libraries"> Linking DOS-extended 32-bit HX Dynamic Link Libraries </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp;  <b>hx32_dll</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br> 
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#Win32_Executable_and_DLL_File_Formats">Win32/Win64 Executable and DLL File Formats</A>.

<H3 ID="Linking_DOSMextended_32Mbit_HX_Executable_Files_Win32stat"> Linking DOS-extended 32-bit HX Executable Files (+ static Win32 Emulation) </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp;  <b>hx32s</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#Win32_Executable_and_DLL_File_Formats">Win32/Win64 Executable and DLL File Formats</A>.

<H3 ID="Linking_OSD2_32Mbit_Executable_Files"> Linking OS/2 32-bit Executable Files </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>os2v2</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#OSD2_Executable_and_DLL_File_Formats">OS/2 Executable and DLL File Formats</A>.

<H3 ID="Linking_OSD2_32Mbit_Dynamic_Link_Libraries"> Linking OS/2 32-bit Dynamic Link Libraries </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>os2v2_dll</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#OSD2_Executable_and_DLL_File_Formats">OS/2 Executable and DLL File Formats</A>.

<H3 ID="Linking_OSD2_32Mbit_Presentation_Manager_Executable_Files"> Linking OS/2 32-bit Presentation Manager Executable Files </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>os2v2_pm</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#OSD2_Executable_and_DLL_File_Formats">OS/2 Executable and DLL File Formats</A>.

<H3 ID="Linking_Windows_3_x_or_9x_32Mbit_Virtual_Device_Driver"> Linking Windows 3.x or 9x 32-bit Virtual Device Drivers (VxD) </H3>
<P>There are two type of the Virtual Device Driver.
<P>Staticaly loaded Virtual Device Driver used by Windows 3.x or 9x.&nbsp; To create this type of file, use the following
structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>win_vxd</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>Dynamically loaded Virtual Device Driver used by Windows 3.11 or 9x.&nbsp; To create this type of file, use the following
structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>win_vxd dynamic</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#Windows_Virtual_Device_Driver_File_Format">Windows Virtual Device Driver File Format</A>.

<H3 ID="Linking_Win32DWin64_CharacterMMode_Executable_Files"> Linking Win32/Win64 Console Executable Files </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>pe_con</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#Win32_Executable_and_DLL_File_Formats">Win32/Win64 Executable and DLL File Formats</A>.

<H3 ID="Linking_Win32DWin64_Windowed_Executable_Files"> Linking Win32/Win64 GUI Executable Files </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>pe_gui</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#Win32_Executable_and_DLL_File_Formats">Win32/Win64 Executable and DLL File Formats</A>.

<H3 ID="Linking_Win32DWin64_Dynamic_Link_Libraries"> Linking Win32/Win64 Dynamic Link Libraries </H3>
<P>To create this type of file, use the following structure.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp; <b>pe_dll</b><br>
&nbsp;&nbsp;&nbsp;&nbsp; option&nbsp;&nbsp; map<br>
&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp; app_name<br>
&nbsp;&nbsp;&nbsp;&nbsp; file&nbsp;&nbsp;&nbsp;&nbsp; obj1, obj2, ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; library&nbsp; lib1, lib2, ...<br>
</TT>
<P>For more information, see the chapter entitled <A HREF="#Win32_Executable_and_DLL_File_Formats">Win32/Win64 Executable and DLL File Formats</A>.

<H1 ID="Linker_Directives_and_Options"> Linker Directives and Options </H1>
<P>JWlink supports a large set of directives and options.&nbsp; The following sections present these directives
and options in alphabetical order.&nbsp; Not all directives and options are supported for all executable formats.&nbsp; When
a directive or option applies only to a subset of the executable formats that the linker can generate, the supporting formats
are noted.&nbsp; In the following example, the notation indicates that the directive or option is supported for all executable
formats.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; Formats: All</TT>
<P>In the following example, the notation indicates that the directive or option is supported for OS/2, 16-bit Windows and
32-bit Windows executable formats only.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; Formats: OS/2, Win16, Win32</TT>
<P>Directives tell JWlink how to create your program.&nbsp; For example, using directives you can tell
JWlink which object files are to be included in the program, which library files to search to resolve undefined
references, and the name of the executable file.
<P>The file<TT> jwlink.lnk</TT> is a special linker directive file that is automatically processed by JWlink
before processing any other directives.&nbsp; 
<P>The default name of the linker directive file (<TT>jwlink.lnk</TT>) can be overridden by the <B>JWLINK_LNK</B> environment
variable.&nbsp; If the specified file can't be opened, the default file name will be used.&nbsp; For example, if the <B>JWLINK_LNK</B>
environment variable is defined as follows
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; set JWLINK_LNK=my.lnk</TT>
<P>then JWlink will attempt to use a<TT> my.lnk</TT> directive file, and if that file cannot be opened, the
linker will revert to using the default<TT> jwlink.lnk</TT> file.
<P>It is also possible to use environment variables when specifying a directive.&nbsp; For example, if the<B> LIBDIR</B> environment
variable is defined as follows,
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; set libdir=\test</TT>
<P>then the linker directive
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; library %libdir%\mylib</TT>
<P>is equivalent to the following linker directive.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; library \test\mylib</TT>
<P>Note that a space must precede a reference to an environment variable.
<P>Many directives can take a list of one or more arguments separated by commas.&nbsp; Instead of a comma-delimited list,
you can specify a space-separated list provided the list is enclosed in braces (e.g., { space delimited list }).&nbsp; For
example, the <A HREF="#FILE_Directive">FILE</A> directive can take a list of object file names as an argument.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; file first,second,third,fourth</TT>
<P>The alternate way of specifying this is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; file {first second third fourth}</TT>
<P>Where this comes in handy is in make files, where a list of dependents is usually a space-delimited list.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; OBJS = first second third fourth</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jwlink file {$(objs)}</TT>
<P>The following notation is used to describe the syntax of linker directives and options.
<DL>
<P><DT>ABC
<DD>All items in upper case are required.
<P><DT>[abc]
<DD>The item<B> abc</B> is optional.
<P><DT>{abc}
<DD>The item<B> abc</B> may be repeated zero or more times.
<P><DT>{abc}+
<DD>The item<B> abc</B> may be repeated one or more times.
<P><DT>a|b|c
<DD>One of<B> a, b</B> or<B> c</B> may be specified.
<P><DT>a ::= b
<DD>The item<B> a</B> is defined in terms of<B> b.</B>
</DL>
<P>Certain characters have special meaning to the linker.&nbsp; When a special character must appear in a name, you can imbed
the string that makes up the name inside apostrophes (e.g., 'name@8').&nbsp; This prevents the linker from interpreting the
special character in its usual manner.&nbsp; This is also true for file or path names that contain spaces (e.g., '\program
files\software\mylib').&nbsp; Normally, the linker would interpret a space or blank in a file name as a separator.&nbsp; The
special characters are listed below:
<P><PRE>
<TABLE>
<TR>
<TH valign="top" align="left" width="10%"></TH>
<TH valign="top" align="left" width="80%"></TH>
<TH valign="top" align="left" width="10%"></TH>
</TR>
<TR>
<TD></TD>
<TD>
<TABLE CELLPADDING="4">
<TR BGCOLOR="#C0C0C0">
<TH VALIGN="top" ALIGN="center">Character</TH>
<TH VALIGN="top" ALIGN="left">Name of Character</TH>
</TR>
<TR BGCOLOR="#E0E0E0"><TD ALIGN="center">&nbsp;</TD><TD>Blank</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD ALIGN="center">=</TD><TD>Equals</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD ALIGN="center">(</TD><TD>Left Parenthesis </TD></TR>
<TR BGCOLOR="#E0E0E0"><TD ALIGN="center">)</TD><TD>Right Parenthesis</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD ALIGN="center">,</TD><TD>Comma            </TD></TR>
<TR BGCOLOR="#E0E0E0"><TD ALIGN="center">.</TD><TD>Period           </TD></TR>
<TR BGCOLOR="#E0E0E0"><TD ALIGN="center">{</TD><TD>Left Brace       </TD></TR>
<TR BGCOLOR="#E0E0E0"><TD ALIGN="center">}</TD><TD>Right Brace      </TD></TR>
<TR BGCOLOR="#E0E0E0"><TD ALIGN="center">@</TD><TD>At Sign          </TD></TR>
<TR BGCOLOR="#E0E0E0"><TD ALIGN="center">#</TD><TD>Hash Mark        </TD></TR>
<TR BGCOLOR="#E0E0E0"><TD ALIGN="center">%</TD><TD>Percentage Symbol</TD></TR>
</TABLE>
</TD>
<TD></TD>
</TR>
</TABLE>
</PRE>

<H2 ID="hash_Directive"> The # Directive </H2>
Formats:&nbsp; All 
<P>The &quot;#&quot; directive is used to mark the start of a comment.&nbsp; All text from the &quot;#&quot; character to
the end of the line is considered a comment.&nbsp; The format of the &quot;#&quot; directive is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # comment</TT>
<P>where &lt;comment&gt; is any sequence of characters.

<P>The following directive file illustrates the use of comments.
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; file main, trigtest<br>
&nbsp;&nbsp;&nbsp;&nbsp; # Use my own version of &quot;sin&quot; instead of the<br>
&nbsp;&nbsp;&nbsp;&nbsp; # library version.<br>
&nbsp;&nbsp;&nbsp;&nbsp; file mysin<br>
&nbsp;&nbsp;&nbsp;&nbsp; library \math\trig<br>
</TT>

<H2 ID="atsign_Directive"> The @ Directive </H2>
The &quot;@&quot; directive instructs JWlink to process directives from an alternate source.&nbsp; The
format of the &quot;@&quot; directive is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @directive_var</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @directive_file</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>directive_var
<DD>is the name of an environment variable.&nbsp; The directives specified by the value of<TT> directive_var</TT> will be processed.
<P><DT>directive_file
<DD>is a file specification for the name of a linker directive file.&nbsp; A file extension of &quot;lnk&quot; is assumed if no
file extension is specified.
</DL>
<P>The environment variable approach to specifying linker directives allows you to specify commonly used directives without
having to specify them each time you invoke JWlink.&nbsp; If the environment variable &quot;jwlink&quot; is
set as in the following example,
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; set jwlink=debug watcom all option map, verbose library math</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink @jwlink</TT>
<P>then each time JWlink is invoked, full debugging information will be generated, a verbose map file will
be created, and the library file &quot;math.lib&quot; will be searched for undefined references.
<P>A linker directive file is useful, for example, when the linker input consists of a large number of object files and you
do not want to type their names on the command line each time you link your program.&nbsp; Note that a linker directive file
can also include other linker directive files.
<P>Let the file &quot;memos.lnk&quot; be a directive file containing the following lines.
<P><PRE>
     system my_os
     name memos
     file memos
     file actions
     file read
     file msg
     file prompt
     file memmgr
     library \termio\screen
     library \termio\keyboard
</PRE>

<P>Consider the following example.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink @memos</TT>
<P>JWlink is instructed to process the contents of the directive file &quot;memos.lnk&quot;.&nbsp; The executable
image file will be called &quot;memos.exe&quot;.&nbsp; The following object files will be loaded from the current directory.
<P><PRE>
     memos.obj
     actions.obj
     read.obj
     msg.obj
     prompt.obj
     memmgr.obj
</PRE>
<P>If any unresolved symbol references remain after all object files have been processed, the library files &quot;screen.lib&quot;
and &quot;keyboard.lib&quot; in the directory &quot;\termio&quot; will be searched (in the order listed).
<P><B>Notes:</B>
<OL>
<P><LI>In the above example, we did not provide the file extension when the directive file was specified.&nbsp; JWlink
assumes a file extension of &quot;lnk&quot; if none is present.
<P><LI>It is not necessary to list each object file and library with a separate directive.&nbsp; The following linker directive
file is equivalent.
<P><PRE>
     system my_os
     name memos
     file memos,actions,read,msg,prompt,memmgr
     library \termio\screen,\termio\keyboard
</PRE>
<P>However, if you want to selectively specify what debugging information should be included, the first style of directive
file will be easier to use.&nbsp; This is illustrated in the following sample directive file.
<P><PRE>
     system my_os
     name memos
     debug watcom lines
     file memos
     debug watcom all
     file actions
     debug watcom lines
     file read
     file msg
     file prompt
     file memmgr
     debug watcom
     library \termio\screen
     library \termio\keyboard
</PRE>
<P><LI>Information for a particular directive can span directive files.&nbsp; This is illustrated in the following sample
directive file.
<P><PRE>
     system my_os
     file memos, actions, read, msg, prompt, memmgr
     file @dbgfiles
     library \termio\screen
     library \termio\keyboard
</PRE>
<P>The directive file &quot;dbgfiles.lnk&quot; contains, for example, those object files that are used for debugging purposes.
</OL>

<H2 ID="ALIAS_Directive"> The ALIAS Directive </H2>
Formats:&nbsp; All 
<P>The ALIAS directive is used to specify an equivalent name for a symbol name.&nbsp; The format of the ALIAS
directive ( short form A ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALIAS alias_name=symbol_name{, alias_name=symbol_name}</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>alias_name
<DD>is the alias name.
<P><DT>symbol_name
<DD>is the symbol name to which the alias name is mapped.
</DL>
<P>Consider the following example.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; alias sine=mysine</TT>
<P>When the linker tries to resolve the reference to<TT> sine</TT>, it will immediately substitute the name<TT> mysine</TT>
for<TT> sine</TT> and begin searching for the symbol<TT> mysine</TT>.

<H2 ID="ALIGNMENT_Option"> The ALIGNMENT Option </H2>
Formats:&nbsp; ELF, OS/2, Win16, Win32/Win64 
<P>The ALIGNMENT option specifies the alignment for segments/sections in the executable file.&nbsp; The format of the ALIGNMENT
option ( short form A ) is
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION ALIGNMENT=n</TT>
<DL><DT>
<P>where &lt;n&gt; is a numeric value.&nbsp; The complete form of &lt;n&gt; is
<DD>
<P><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>

<P>&lt;n&gt; specifies the alignment for segments/sections in the executable file and must be a power of 2.
<P>In 16-bit applications, segments in the executable file are pointed to by a segment table.&nbsp; An entry in the segment
table contains a 16-bit value which is a multiple of the alignment value.&nbsp; Together they form the offset of the segment
from the start of the segment table.&nbsp; Note that the smaller the value of &lt;n&gt; the smaller the executable file.
<P>The default value of &lt;n&gt; depends on the format. For PE, the default
value is 512. For the other formats, JWlink will automatically choose the
smallest value of &lt;n&gt; possible&nbsp;; hence in these cases you need not
specify this option unless you want padding between segments in the executable file.
<P>
<P>For alignment of sections in memory for flat formats, see the <A HREF="#OBJALIGN_Option">OBJALIGN</A> option.

<H2 ID="ANONYMOUSEXPORT_Directive"> The ANONYMOUSEXPORT Directive </H2>
Formats:&nbsp; Win16, Win32/Win64 
<P>The ANONYMOUSEXPORT directive is an alternative to the <A HREF="#EXPORT_Directive">EXPORT</A> directive.
&nbsp;The symbol associated with this name will not appear in either the resident or the non-resident names table.&nbsp; The
entry point is, however, still available for ordinal linking.
<P>The format of the ANONYMOUSEXPORT directive ( short form ANON ) is as follows.
<PRE>
          ANONYMOUSEXPORT export{,export}
               <i>or</i>
          ANONYMOUSEXPORT =lbc_file
          export ::= entry_name[.ordinal][=internal_name]
</PRE>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>entry_name
<DD>is the name to be used by other applications to call the function.
<P><DT>ordinal
<DD>is an ordinal value for the function.&nbsp; If the ordinal number is specified, other applications can reference the function
by using this ordinal number.
<P><DT>internal_name
<DD>is the actual name of the function and should only be specified if it differs from the entry name.
<P><DT>lbc_file
<DD>is a file specification for the name of a librarian command file.&nbsp; If no file extension is specified, a file extension
of &quot;lbc&quot; is assumed.&nbsp; The linker will process the librarian command file and look for commands to the librarian
that are used to create import library entries.&nbsp; These commands have the following form.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; ++sym.dll_name[.[altsym].export_name][.ordinal]</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>sym
<DD>is the name of a symbol in a Dynamic Link Library.
<P><DT>dll_name
<DD>is the name of the Dynamic Link Library that defines<TT> sym.</TT>
<P><DT>altsym
<DD>is the name of a symbol in a Dynamic Link Library.&nbsp; When omitted, the default symbol name is<TT> sym.</TT>
<P><DT>export_name
<DD>is the name that an application that is linking to the Dynamic Link Library uses to reference<TT> sym.</TT>&nbsp; When omitted,
the default export name is<TT> sym.</TT>
<P><DT>ordinal
<DD>is the ordinal value that can be used to identify<TT> sym</TT> instead of using the name<TT> export_name.</TT>
</DL>
<P>All other librarian commands will be ignored.
</DL>
<P><B>Notes:</B>
<OL>
<P><LI>By default, the Open Watcom C and C++ compilers append an underscore ('_') to all function names.&nbsp; This should
be considered when specifying<B> entry_name</B> and<B> internal_name</B> in an ANONYMOUSEXPORT directive.
<P><LI>If the name contains characters that are special to the linker then the name may be placed inside apostrophes (e.g.,<TT>
anonymousexport 'myfunc@8'</TT>).
<P><LI>The symbol associated with the entry name will not appear in either the resident or the non-resident names table.&nbsp;
The entry point is, however, still available for ordinal linking.&nbsp; This directive is important when you wish to reduce
the number of entries that are placed in the resident and non-resident names table.
</OL>

<H2 ID="AREA_Option"> The AREA Option </H2>
Formats:&nbsp; DOS 
<P>The AREA option can be used to set the size of the memory pool in which overlay sections are loaded by the
dynamic overlay manager.&nbsp; The format of the AREA option ( short form AR ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION AREA=n</TT>
<DL>
<P><DT>where &lt;n&gt; represents a numeric value.&nbsp; The complete form of &lt;n&gt; is:
<DD>
<P><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>

<P>The default size of the memory pool for a given application is selected by JWlink and is equal to twice
the size of the largest overlay.
<P>It is also possible to add to the memory pool at run-time.&nbsp; If you wish to add to the memory pool at run-time, see
the section entitled <A HREF="#DOS__Increasing_the_Dynamic_Overlay_Area">DOS:&nbsp; Increasing the Dynamic Overlay Area</A>.

<H2 ID="ARTIFICIAL_Option"> The ARTIFICIAL Option </H2>
Formats:&nbsp; All 
<P>The ARTIFICIAL option should only be used if you are developing a Open Watcom C++ application.&nbsp; A Open
Watcom C++ application contains many compiler-generated symbols.&nbsp; By default, the linker does not include these symbols
in the map file ( see the <A HREF="#MAP_Option">MAP</A> option ).&nbsp; The ARTIFICIAL option can be used if you wish to include these compiler-generated symbols
in the map file.
<P>The format of the ARTIFICIAL option ( short form ART ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION ARTIFICIAL</TT>

<H2 ID="AUTOSECTION_Directive"> The AUTOSECTION Directive </H2>
Formats:&nbsp; DOS 
<P>The AUTOSECTION directive specifies that each object file that appears in a subsequent <A HREF="#FILE_Directive">FILE</A> directive,
up to the next <A HREF="#SECTION_Directive">SECTION</A> or <A HREF="#END_Directive">END</A> directive, will be assigned a different overlay.&nbsp; The AUTOSECTION
method of defining overlays is most useful when using the dynamic overlay manager, selected by specifying the <A HREF="#DYNAMIC_Option">DYNAMIC</A>
option.&nbsp; For more information on the dynamic overlay manager, see the section entitled <A HREF="#DOS__Using_Overlays">DOS:&nbsp; Using Overlays</A>.
<P>The format of the AUTOSECTION directive ( short form AUTOS ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AUTOSECTION [INTO ovl_file]</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>INTO
<DD>specifies that all overlays are to be placed into a file, namely<B> ovl_file.</B>&nbsp; If &quot;INTO&quot; (short form &quot;IN&quot;)
is not specified, the overlays are placed in the executable file.
<P><DT>ovl_file
<DD>is the file specification for the name of an overlay file.&nbsp; If no file extension is specified, a file extension of &quot;ovl&quot;
is assumed.
</DL>
<P>Placing overlays in separate files has a number of advantages.&nbsp; For example, if your application was linked into one
file, it may not fit on a single diskette, making distribution of your application difficult.

<H2 ID="AUTOUNLOAD_Option"> The AUTOUNLOAD Option </H2>
Formats:&nbsp; NetWare 
<P>The AUTOUNLOAD option specifies that a NetWare Loadable Module (NLM) built with this option should automatically
be unloaded when all of its entry points are no longer in use.&nbsp; This only applies if the NLM was automatically loaded
by another modules loading.
<P>The format of the AUTOUNLOAD option ( short form AUTOUN ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION AUTOUNLOAD</TT>

<H2 ID="BEGIN_Directive"> The BEGIN Directive </H2>
Formats:&nbsp; DOS 
<P>The BEGIN directive is used to define the start of an overlay area.&nbsp;An overlay area is a piece of memory in which overlays are loaded.&nbsp;
All overlays defined between a BEGIN directive and the corresponding <A HREF="#END_Directive">END</A> directive are loaded into
that overlay area.
<P>The format of the BEGIN directive ( short form B ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BEGIN</TT>
<P>See <A HREF="#DOS__Defining_Overlay_Structures">Defining Overlay Structures</A> how the BEGIN directive is
supposed to be used.

<H2 ID="CACHE_Option"> The CACHE Option </H2>
Formats:&nbsp; All 
<P>The CACHE and NOCACHE options can be used to control caching of object and library files in memory
by the linker.&nbsp; When neither CACHE nor NOCACHE is specified, the linker will only
cache small libraries.&nbsp; Object files and large libraries are not cached.&nbsp; The CACHE and NOCACHE
options can be used to alter this default behaviour.&nbsp; The CACHE option enables the caching of object files
and large library files while the NOCACHE option disables all caching.
<P>The format of the CACHE option ( short form CAC ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION CACHE</TT>
<P>The format of the NOCACHE option ( short form NOCAC ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NOCACHE</TT>
<P>When linking large applications with many object files, caching object files will cause extensive use of memory by the
linker.&nbsp; On virtual memory systems such as OS/2, Windows NT or Windows 95, this can cause extensive page file activity
when real memory resources have been exhausted.&nbsp; This can degrade the performance of other tasks on your system.&nbsp;
For this reason, the OS/2 and Windows-hosted versions of the linker do not perform object file caching by default.&nbsp; This
does not imply that object file caching is not beneficial.&nbsp; If your system has lots of real memory or the linker is running
as the only task on the machine, object file caching can certainly improve the performance of the linker.
<P>On single-tasking environments such as DOS, the benefits of improved linker performance outweighs the memory demands associated
with object file caching.&nbsp; For this reason, object file caching is performed by default on these systems.&nbsp; If the
memory requirements of the linker exceed the amount of memory on your system, the NOCACHE option can be specified.
<P>The QNX operating system is a multi-tasking real-time operating system.&nbsp; However, it is not a virtual memory system.
&nbsp;Caching object files can consume large amounts of memory.&nbsp; This may prevent other tasks on the system from running,
a problem that may be solved by using the NOCACHE option.

<H2 ID="CASEEXACT_Option"> The CASEEXACT Option </H2>
Formats:&nbsp; All 
<P>The <b>CASEEXACT</b> option tells JWlink to respect case when resolving references to global symbols.
&nbsp;That is, &quot;ScanName&quot; and &quot;SCANNAME&quot; represent two different symbols.&nbsp; This is the default because
the most commonly used languages (C, C++, FORTRAN) are case sensitive.&nbsp; The format of the CASEEXACT option
( short form C ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION CASEEXACT</TT>
<P>It is possible to override the default by using the <b>NOCASEEXACT</b> option.&nbsp; The NOCASEEXACT option
turns off case-sensitive linking.&nbsp; The format of the NOCASEEXACT option (short form NOCASE ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NOCASEEXACT</TT>

<H2 ID="CHECK_Option"> The CHECK Option </H2>
Formats:&nbsp; NetWare 
<P>The CHECK option specifies the name of a procedure to execute before an NLM is unloaded.&nbsp; This procedure
can, for example, inform the operator that the NLM is in use and prevent it from being unloaded.
<P>The format of the CHECK option ( short form CH ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION CHECK=symbol_name</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>symbol_name
<DD>specifies the name of a procedure to execute before the NLM is unloaded.
</DL>
<P>If the CHECK option is not specified, no check procedure will be called.

<H2 ID="CHECKSUM_Option"> The CHECKSUM Option </H2>
Formats:&nbsp; Win32/Win64 
<P>The CHECKSUM option specifies that the linker should create an MS-CRC32 checksum for the current image.&nbsp;
This is primarily used for DLL's and device drivers but can be applied to any PE format images.&nbsp; The format of the CHECKSUM
option (no short form) is
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION CHECKSUM</TT>

<H2 ID="COMMIT_Directive"> The COMMIT Directive </H2>
Formats:&nbsp; Win32/Win64 
<P>When the operating system allocates the stack and heap for an application, it does not actually allocate the whole stack
and heap to the application when it is initially loaded.&nbsp; Instead, only a portion of the stack and heap are allocated
or committed to the application.&nbsp; Any part of the stack and heap that is not committed will be committed on demand.
<P>The format of the COMMIT directive ( short form COM ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMIT mem_type</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mem_type ::= STACK=n | HEAP=n</TT>
<DL><DT>
<P>where &lt;n&gt; represents a numeric value. The complete form of &lt;n&gt; is
<DD>
<P><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>
<P>&lt;n&gt; represents the amount of stack or heap that is initially committed to the application.&nbsp; The short form for
STACK is ST and the short form for HEAP is H.

<P>The default values for stack and heap commits are 4k. 
See the <A HREF="#STACK_Option">STACK</A> and <A HREF="#HEAPSIZE_Option">HEAPSIZE</A>
options for information on specifying <b>reserved</b> sizes for stack and heap.

<H2 ID="COPYRIGHT_Option"> The COPYRIGHT Option </H2>
Formats:&nbsp; NetWare 
<P>The COPYRIGHT option specifies copyright information that is placed in the executable file.&nbsp; The format
of the COPYRIGHT option ( short form COPYR ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION COPYRIGHT 'string'</TT>
<P>where &lt;string&gt; specifies the copyright information.

<H2 ID="CUSTOM_Option"> The CUSTOM Option </H2>
Formats:&nbsp; NetWare 
<P>The format of the CUSTOM option ( short form CUST ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION CUSTOM=file_name</TT>
<P>where &lt;file_name&gt; specifies the file name of the custom data file.
<P>The custom data file is placed into the executable file when the application is linked but is really not part of the program.
&nbsp;When the application is loaded into memory, the information extracted from a custom data file is not loaded into memory.
&nbsp;Instead, information is passed to the program (as arguments) which allows the access and processing of this information.

<H2 ID="CVPACK_Option"> The CVPACK Option </H2>
Formats:&nbsp; All 
<P>This option is only meaningful when generating Microsoft CodeView debugging information.&nbsp; This option causes the linker
to automatically run the Open Watcom CodeView 4 Symbolic Debugging Information Compactor, CVPACK, on the executable that it
has created.&nbsp; This is necessary to get the CodeView debugging information into a state where the Microsoft CodeView debugger
will accept it.
<P>The format of the CVPACK option ( short form CVP ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION CVPACK</TT>
<P>For more information on generating CodeView debugging information into the executable, see the section entitled <A HREF="#DEBUG_Directive">The DEBUG Directive</A>

<H2 ID="DEBUG_Directive"> The DEBUG Directive </H2>
Formats:&nbsp; All 
<P>The DEBUG directive is used to tell JWlink to generate debugging information in the executable
file.&nbsp; This extra information in the executable file is used by the Open Watcom Debugger.&nbsp; The format of the DEBUG
directive ( short form D ) is as follows.
<PRE>
         DEBUG dbtype [dblist] |
         DEBUG [dblist]

         dbtype ::= DWARF | WATCOM | CODEVIEW | NOVELL
         dblist ::= [db_option{,db_option}]
         db_option ::= LINES | TYPES | LOCALS | ALL
    <i>DEBUG NOVELL only</i>:
         db_option ::= ONLYEXPORTS | REFERENCED
</PRE>
<P>JWlink supports four types of debugging information, DWARF (the default), WATCOM,
CODEVIEW, or NOVELL.

<TABLE>
<TR BGCOLOR="#E0E0E0"><TD>DWARF<br>short: D</TD><TD> specifies that all object files contain DWARF format debugging information and that the executable
file will contain DWARF debugging information. This debugging format is assumed by default when none is specified.</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>WATCOM<br>short: W</TD><TD> specifies that all object files contain Watcom format debugging information and that the executable
file will contain Watcom debugging information. This format permits the selection of specific classes of debugging information
(<B> dblist</B>) which are described below.</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>CODEVIEW<br>short: C</TD><TD> specifies that all object files contain CodeView (CV4) format debugging information and that the
executable file will contain CodeView debugging information. It will be necessary to run the Microsoft Debugging Information Compactor, CVPACK, on the executable that it has created.
For information on requesting the linker to automatically run CVPACK, see the section entitled <A HREF="#CVPACK_Option">The CVPACK Option</A>
Alternatively, you can run CVPACK from the command line.</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>NOVELL<br>short: N</TD><TD> specifies a form of global symbol information that can only be processed by the NetWare debugger.</TD></TR>
</TABLE>

<HR>

<B><I>&nbsp; Note:</I></B>&nbsp; Except in rare cases, the most appropriate use of the DEBUG directive is specifying
DEBUG ALL ( short form D A ) prior to any <A HREF="#FILE_Directive">FILE</A> or <A HREF="#LIBRARY_Directive">LIBRARY</A> directives.&nbsp;
This will cause JWlink to emit all available debugging information in the default format.
<HR>

<P>The following options can be used with the DEBUG WATCOM directive to select specific types of
debugging information to be included in the executable file:

<TABLE>
<TR BGCOLOR="#E0E0E0"><TD>LINES<br>short: LI</TD><TD>specifies line numbering and global symbol information.</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>LOCALS<br>short: LO</TD><TD>specifies local and global symbol information.</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>TYPES<br>short: T</TD><TD>specifies typing and global symbol information.</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>ALL<br>short: A</TD><TD>specifies all of the above debugging information.</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>ONLYEXPORTS<br>short: ONL</TD><TD>restricts the generation of global symbol information to exported symbols. This option
may only be used with Netware executable formats.</TD></TR>
</TABLE>

<P>The following options can be used with the DEBUG NOVELL directive to select specific types of
debugging information to be included in the executable file:
<TABLE>
<TR BGCOLOR="#E0E0E0"><TD>ONLYEXPORTS<br>short: ONL</TD><TD>restricts the generation of global symbol information to exported symbols.</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>REFERENCED<br>short: REF</TD><TD>restricts the generation of symbol information to referenced symbols only.</TD></TR>
</TABLE>

<HR>
<B><I>&nbsp; Note:</I></B>&nbsp; The position of the DEBUG directive is important.&nbsp; The level of debugging
information specified in a DEBUG directive only applies to object files and libraries that appear in<B> subsequent</B>
<A HREF="#FILE_Directive">FILE</A> or <A HREF="#LIBRARY_Directive">LIBRARY</A> directives.&nbsp; For example, if DEBUG WATCOM ALL was the only DEBUG
directive specified and was also the last linker directive, no debugging information would appear in the executable file.
<HR>
Only global symbol information is actually produced by JWlink; the other three classes of debugging information
are extracted from object modules and copied to the executable file.&nbsp; Therefore, at compile time, you must instruct the
compiler to generate local symbol, line numbering and typing information in the object file so that the information can be
transferred to the executable file.&nbsp; If you have asked JWlink to produce a particular class of debugging
information and it appears that none is present, one of the following conditions may exist.
<OL>
<LI>The debugging information is not present in the object files.
<LI>The DEBUG directive has been misplaced.
</OL>
<P>The following sections describe the classes of debugging information.

<H3 ID="Line_Numbering_Information_M_DEBUG_WATCOM_LINES"> Line Numbering Information - DEBUG WATCOM LINES </H3>
<P>The DEBUG WATCOM LINES option controls the processing of line numbering information.&nbsp; Line numbering information
is the line number and address of the generated code for each line of source code in a particular module.&nbsp; This allows
Open Watcom Debugger to perform source-level debugging.&nbsp; When JWlink encounters a <i>DEBUG WATCOM</i>
directive with a LINES or ALL option, line number information for each subsequent object module will
be placed in the executable file.&nbsp; This includes all object modules extracted from object files specified in subsequent
<A HREF="#FILE_Directive">FILE</A> directives and object modules extracted from libraries specified in subsequent <A HREF="#LIBRARY_Directive">LIBRARY</A> or <A HREF="#FILE_Directive">FILE</A>
directives.
<HR>
<P><B><I>&nbsp; Note:</I></B>&nbsp; If Open Watcom compilers are used, all modules for which line numbering information is requested must have been compiled
with the &quot;-d1&quot; or &quot;-d2&quot; option.
<HR>
A subsequent DEBUG WATCOM directive without a LINES or ALL option terminates the processing
of line numbering information.

<H3 ID="Local_Symbol_Information_M_DEBUG_WATCOM_LOCALS"> Local Symbol Information - DEBUG WATCOM LOCALS </H3>
<P>The DEBUG WATCOM LOCALS option controls the processing of local symbol information.&nbsp; Local symbol information
is the name and address of all symbols local to a particular module.&nbsp; This allows Open Watcom Debugger to locate these
symbols so that you can reference local data and routines by name.&nbsp; When JWlink encounters a <i>DEBUG
WATCOM</i> directive with a LOCALS or ALL option, local symbol information for each subsequent object
module will be placed in the executable file.&nbsp; This includes all object modules extracted from object files specified
in subsequent <A HREF="#FILE_Directive">FILE</A> directives and object modules extracted from libraries specified in subsequent <A HREF="#LIBRARY_Directive">LIBRARY</A>
or <A HREF="#FILE_Directive">FILE</A> directives.
<HR>
<P><B><I>&nbsp; Note:</I></B>&nbsp; If Open Watcom compilers are used, all modules for which local symbol information is requested must have been compiled with
the &quot;-d2&quot; option.
<HR>
A subsequent <i>DEBUG WATCOM</i> directive without a LOCALS or ALL option terminates the processing
of local symbol information.

<H3 ID="Typing_Information_M_DEBUG_WATCOM_TYPES"> Typing Information - DEBUG WATCOM TYPES </H3>
<P>The DEBUG WATCOM TYPES option controls the processing of typing information.&nbsp; Typing information includes
a description of all types, structures and arrays that are defined in a module.&nbsp; This allows Open Watcom Debugger to
display variables according to their type.&nbsp; When JWlink encounters a <i>DEBUG WATCOM</i> directive
with a TYPES or ALL option, typing information for each subsequent object module will be placed in
the executable file.&nbsp; This includes all object modules extracted from object files specified in subsequent <A HREF="#FILE_Directive">FILE</A>
directives and object modules extracted from libraries specified in subsequent <A HREF="#LIBRARY_Directive">LIBRARY</A> or <A HREF="#FILE_Directive">FILE</A> directives.
<HR>
<P><B><I>&nbsp; Note:</I></B>&nbsp; If Open Watcom compilers are used, all modules for which typing information is requested must have been compiled with the
&quot;-d2&quot; option.
<HR>
A subsequent DEBUG WATCOM directive without a TYPES or ALL option terminates the processing
of typing information.

<H3 ID="All_Debugging_Information_M_DEBUG_WATCOM_ALL"> All Debugging Information - DEBUG WATCOM ALL </H3>
<P>The DEBUG WATCOM ALL option specifies that LINES, LOCALS, and TYPES options
are requested.&nbsp; The LINES option controls the processing of line numbering information.&nbsp; The LOCALS
option controls the processing of local symbol information.&nbsp; The TYPES option controls the processing of
typing information.&nbsp; Each of these options is described in a previous section.&nbsp; A subsequent <i>DEBUG WATCOM</i>
 directive without an ALL option discontinues those options which are not specified in the list of debug
options.

<H3 ID="Global_Symbol_Information"> Global Symbol Information </H3>
<P>Global symbol information consists of all the global symbols in your program and their address.&nbsp; This allows Open
Watcom Debugger to locate these symbols so that you can reference global data and routines by name.&nbsp; When JWlink
encounters a DEBUG directive, global symbol information for all the global symbols appearing in your program
is placed in the executable file.

<H3 ID="Global_Symbols_for_the_NetWare_Debugger_M_DEBUG_NOVELL"> Global Symbols for the NetWare Debugger - DEBUG NOVELL </H3>
<P>The NetWare operating system has a built-in debugger that can be used to debug programs.&nbsp; When DEBUG NOVELL
is specified, JWlink will generate global symbol information that can be used by the NetWare debugger.&nbsp;
Note that any line numbering, local symbol, and typing information generated in the executable file will not be recognized
by the NetWare debugger.&nbsp; Also, the Open Watcom tool <B><I>WSTRIP</I></B> cannot be used to remove this form of global symbol information
from the executable file.

<H3 ID="ONLYEXPORTS_Debugging_Option"> The ONLYEXPORTS Debugging Option </H3>
<P>The ONLYEXPORTS option ( short form ONL ) restricts the generation of global symbol information to
exported symbols (symbols appearing in an <A HREF="#EXPORT_Directive">EXPORT</A> directive).&nbsp; If DEBUG WATCOM ONLYEXPORTS is
specified, Open Watcom Debugger global symbol information is generated only for exported symbols.&nbsp; If DEBUG NOVELL
ONLYEXPORTS is specified, NetWare global symbol information is generated only for exported symbols.

<H3 ID="Using_DEBUG_Directives"> Using DEBUG Directives </H3>
<P>Consider the following directive file.
<PRE>
     debug watcom all
     file module1
     debug watcom lines
     file module2, module3
     debug watcom
     library mylib
</PRE>
<P>It specifies that the following debugging information is to be generated in the executable file.
<UL>
<LI>global symbol information for your program</LI>
<LI>line numbering, typing and local symbol information for object file <TT>module1.obj</TT></LI>
<LI>line numbering information for object files <TT>module2.obj</TT> and <TT>module3.obj</TT></LI>
</UL>
<P>Note that if the DEBUG WATCOM directive before the <A HREF="#LIBRARY_Directive">LIBRARY</A> directive is not specified, line numbering
information for all object modules extracted from the library &quot;mylib.lib&quot; would be generated in the executable file
provided the object modules extracted from the library have line numbering information present.
<HR>
<P><B><I>&nbsp; Note:</I></B>&nbsp; A DEBUG WATCOM directive with no option suppresses the processing of line
numbering, local symbol and typing information for all subsequent object modules.
<HR>
Debugging information can use a significant amount of disk space.&nbsp; As shown in the above example, you can select only
the class of debugging information you want and for those modules you wish to debug.&nbsp; In this way, the amount of debugging
information in the executable file is minimized and hence the amount of disk space used by the executable file is kept to
a minimum.
<P>As you can see from the above example, the position of the DEBUG WATCOM directive is important when describing
the debugging information that is to appear in the executable file.
<HR>
<P><B><I>&nbsp; Note:</I></B>&nbsp; If you want all classes of debugging information for all files to appear in the executable
file you must specify DEBUG WATCOM ALL before any <A HREF="#FILE_Directive">FILE</A> and <A HREF="#LIBRARY_Directive">LIBRARY</A> directives.
<HR>

<H3 ID="Removing_Debugging_Information_from_an_Executable_File"> Removing Debugging Information from an Executable File </H3>
An Open Watcom utility called <B><I>WSTRIP</I></B> has been provided which takes as input an executable file and removes the debugging
information placed in the executable file by JWlink.&nbsp; Note that global symbol information generated using
DEBUG NOVELL cannot be removed by<B><I> WSTRIP</I></B> .
<P>For more information on this utility, see the chapter entitled &quot;The Open Watcom Strip Utility&quot; in the<B><I> Open
Watcom C/C++ Tools User's Guide</I></B> or<B><I> Open Watcom FORTRAN 77 Tools User's Guide.</I></B>

<H2 ID="DESCRIPTION_Option"> The DESCRIPTION Option </H2>
Formats:&nbsp; OS/2, Win16, Win32/Win64 
<P>The DESCRIPTION option inserts the specified text into the application or Dynamic Link Library.&nbsp; This
is useful if you wish to embed copyright information into an application or Dynamic Link Library.&nbsp; The format of the
DESCRIPTION option ( short form DE ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION DESCRIPTION 'string'</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>string
<DD>is the sequence of characters to be embedded into the application or Dynamic Link Library.
</DL>

<H2 ID="DISABLE_Directive"> The DISABLE Directive </H2>
Formats:&nbsp; All 
<P>The DISABLE directive is used to disable the display of linker messages.
<P>JWlink issues three classes of messages; fatal errors, errors and warnings.&nbsp; Each message has a 4-digit
number associated with it.&nbsp; Fatal messages start with the digit 3, error messages start with the digit 2, and warning
messages start with the digit 1.&nbsp; It is possible for a message to be issued as a warning or an error.
<P>If a fatal error occurs, the linker will terminate immediately and no executable file will be generated.
<P>If an error occurs, the linker will continue to execute so that all possible errors are issued.&nbsp; However, no executable
file will be generated since these errors do not permit a proper executable file to be generated.
<P>If a warning occurs, the linker will continue to execute.&nbsp; A warning message is usually informational and does not
prevent the creation of a proper executable file.&nbsp; However, all warnings should eventually be corrected.
<P>Note that the behaviour of the linker does not change when a message is disabled.&nbsp; For example, if a message that
normally terminates the linker is disabled, the linker will still terminate but the message describing the reason for the
termination will not be displayed.&nbsp; For this reason, you should only disable messages that are warnings.
<P>The linker will ignore the severity of the message number.&nbsp; For example, some messages can be displayed as errors
or warnings.&nbsp; It is not possible to disable the message when it is issued as a warning and display the message when it
is issued as an error.&nbsp; In general, do not specify the severity of the message when specifying a message number.
<P>The format of the DISABLE directive ( short form DISA ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISABLE msg_num{, msg_num}</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>msg_num
<DD>is a message number.&nbsp; See the chapter entitled <A HREF="#JWlink_Diagnostic_Messages">JWlink Diagnostic Messages</A>
for a list of messages and their corresponding numbers.
</DL>
<P>The following DISABLE directive will disable message 28 (an undefined symbol has been referenced).
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; disable 28</TT>

<H2 ID="DISTRIBUTE_Option"> The DISTRIBUTE Option </H2>
Formats:&nbsp; DOS 
<P>The DISTRIBUTE option specifies that object modules extracted from library files are to be distributed throughout
the overlay structure.&nbsp; The format of the DISTRIBUTE option ( short form DIS ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION DISTRIBUTE</TT>
<P>An object module extracted from a library file will be placed in the overlay section that satisfies the following conditions.
<OL>
<LI>The symbols defined in the object module are not referenced by an ancestor of the overlay section selected to contain
the object module.
<LI>At least one symbol in the object module is referenced by an immediate descendant of the overlay section selected to
contain the module.
</OL>
<P>Note that libraries specified in the <A HREF="#FIXEDLIB_Directive">FIXEDLIB</A> directive will not be distributed.&nbsp; Also, if a symbol defined
in a library module is referenced indirectly (its address is taken), the module extracted from the library will be placed
in the root unless the <A HREF="#NOINDIRECT_Option">NOINDIRECT</A> option is specified.
<P>For more information on overlays, see the section entitled <A HREF="#DOS__Using_Overlays">DOS:&nbsp; Using Overlays</A>.

<H2 ID="DOSSEG_Option"> The DOSSEG Option </H2>
Formats:&nbsp; All 
<P>The DOSSEG option tells JWlink to order segments in a special way.&nbsp; The format of the
DOSSEG option ( short form D ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION DOSSEG</TT>
<P>When the DOSSEG option is specified, segments will be ordered in the following way.&nbsp; 
<P>
<PRE>
    +------------------------------------------------------------+
    | segments not belonging to group DGROUP with class CODE     |
    +------------------------------------------------------------+
    | other segments not belonging to group DGROUP               |
    +------------------------------------------------------------+
    | segments of group DGROUP with class BEGDATA                |
    +------------------------------------------------------------+
    | segments of group DGROUP with class != BEGDATA, BSS, STACK |
    +------------------------------------------------------------+
    | segments of group DGROUP with class BSS                    |
    +------------------------------------------------------------+
    | segments of group DGROUP with class STACK                  |
    +------------------------------------------------------------+
</PRE>
<P>A special segment belonging to class &quot;BEGDATA&quot; is defined when linking with Open Watcom run-time libraries.&nbsp;
This segment is initialized with the hexadecimal byte pattern &quot;01&quot; and is the first segment in group &quot;DGROUP&quot;
so that storing data at location 0 can be detected in segmented memory models.
<P>Segments belonging to class &quot;BSS&quot; contain uninitialized data.&nbsp; Note that this only includes uninitialized
data in segments belonging to group &quot;DGROUP&quot;.&nbsp; Segments belonging to class &quot;STACK&quot; are used to define
the size of the stack used for your application.&nbsp; Segments belonging to the classes &quot;BSS&quot; and &quot;STACK&quot;
are last in the segment ordering so that uninitialized data need not take space in the executable file.
<P>When using Open Watcom run-time libraries, it is not necessary to specify the DOSSEG option.&nbsp; One of the
object files in the Open Watcom run-time libraries contains a special record that specifies the DOSSEG option.
<P>If no DOSSEG option is specified, segments are ordered in the order they are encountered by JWlink.
<P>When the DOSSEG option is specified, JWlink defines two special variables.&nbsp; <TT> _edata</TT>
defines the start of the &quot;BSS&quot; class of segments and<TT> _end</TT> defines the end of the &quot;BSS&quot; class
of segments.&nbsp; Your program must not redefine these symbols.

<H3 ID="Phar_Lap__Memory_Layout"> Phar Lap:&nbsp; Memory Layout with DOSSEG Option </H3>
Segment ordering of a Phar Lap DOS application if Option DOSSEG has been set:
<OL>
<LI><b>all &quot;USE16&quot; segments</b>.&nbsp; These segments are present in applications that execute in both real mode and
protected mode.&nbsp; They are first in the segment ordering so that the REALBREAK option of the <A HREF="#RUNTIME_Directive">RUNTIME</A>
directive can be used to separate the real-mode part of the application from the protected-mode part of the application.&nbsp;
<LI>all segments not belonging to group &quot;DGROUP&quot; with class &quot;CODE&quot;
<LI>all other segments not belonging to group &quot;DGROUP&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BEGDATA&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; not with class &quot;BEGDATA&quot;, &quot;BSS&quot; or &quot;STACK&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BSS&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;STACK&quot;
</OL>


<H2 ID="DYNAMIC_Option"> The DYNAMIC Option </H2>
Formats:&nbsp; DOS 
<P>The DYNAMIC; option tells JWlink to use the dynamic overlay manager.&nbsp; The format of the
DYNAMIC option ( short form DYN ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION DYNAMIC</TT>
<P>Note that the dynamic overlay manager can only be used with applications that have been compiled using the &quot;of&quot;
option and a big code memory model.&nbsp; The &quot;of&quot; option generates a special prologue/epilogue sequence for procedures
that is required by the dynamic overlay manager.&nbsp; See the compiler User's Guide for more information on the &quot;of&quot;
option.
<P>For more information on the dynamic overlay manager, see the section entitled <A HREF="#DOS__Using_Overlays">DOS:&nbsp; Using Overlays</A>.

<H2 ID="ELIMINATE_Option"> The ELIMINATE Option </H2>
Formats:&nbsp; All 
<P>The ELIMINATE option can be used to enable dead code elimination.&nbsp; Dead code elimination is a process
the linker uses to remove unreferenced segments from the application.&nbsp; The linker will only remove segments that contain
code; unreferenced data segments will not be removed.
<P>The format of the ELIMINATE option ( short form EL ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION ELIMINATE</TT>
<DL>
<P><DT>Linking C/C++ Applications
<DD>Typically, a module of C/C++ code contains a number of functions.&nbsp; When this module is compiled, all functions will be
placed in the same code segment.&nbsp; The chances of each function in the module being unreferenced are remote and the usefulness
of the ELIMINATE option is greatly reduced.
<P>In order to maximize the effect of the ELIMINATE option, the &quot;zm&quot; compiler option is available to
tell the Open Watcom C/C++ compiler to place each function in its own code segment.&nbsp; This allows the linker to remove
unreferenced functions from modules that contain many functions.
<P>Note, that if a function is referenced by data, as in a jump table, the linker will not be able to eliminate the code for
the function even if the data that references it is unreferenced.
<P><DT>Linking FORTRAN 77 Applications
<DD>The Open Watcom FORTRAN 77 compiler always places each function and subroutine in its own code segment, even if they are contained
in the same module.&nbsp; Therefore when linking with the ELIMINATE option the linker will be able to eliminate
code on a function/subroutine basis.
</DL>

<H2 ID="END_Directive"> The END Directive </H2>
Formats:&nbsp; DOS 
<P>The END directive is used to define the end of an overlay area.&nbsp;
An overlay area is a piece of memory in which overlays are loaded.&nbsp;
All overlays defined between a <A HREF="#BEGIN_Directive">BEGIN</A> directive and the corresponding END directive are loaded into
that overlay area.
<P>The format of the END directive ( short form E ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<P>See <A HREF="#DOS__Defining_Overlay_Structures">Defining Overlay Structures</A> how the END directive is
supposed to be used.


<H2 ID="ENDLINK_Directive"> The ENDLINK Directive </H2>
Formats:&nbsp; All 
<P>The ENDLINK directive is used to indicate the end of a new set of linker commands that are to be processed
after the current set of commands has been processed.&nbsp; The format of the ENDLINK directive ( short form ENDL )
is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDLINK</TT>
<P>The <A HREF="#STARTLINK_Directive">STARTLINK</A> directive is used to indicate the start of the set of commands.

<H2 ID="EXIT_Option"> The EXIT Option </H2>
Formats:&nbsp; NetWare 
<P>The format of the EXIT option ( short form EX ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION EXIT=symbol_name</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>symbol_name
<DD>specifies the name of the procedure that is executed when an NLM is unloaded.
</DL>
<P>The default name of the exit procedure is &quot;_Stop&quot;.
<P>Note that the exit procedure cannot prevent the NLM from being unloaded.&nbsp; Once the exit procedure has executed, the
NLM will be unloaded.&nbsp; The <A HREF="CHECK_Option">CHECK</A> option can be used to specify a check procedure that can prevent an NLM
from being unloaded.

<H2 ID="EXPORT_Directive"> The EXPORT Directive </H2>
Formats:&nbsp; ELF, NetWare, OS/2, Win16, Win32/Win64 
<P>The EXPORT directive is used to tell JWlink which symbols are available for import by other
executables.

<OL>
<LI><A HREF="#EXPORT_M_OSD2__Win16__Win32_only"> EXPORT - OS/2, Win16, Win32/Win64 only </A></LI>
<LI><A HREF="#EXPORT_M_ELF_only"> EXPORT - ELF only </A></LI>
<LI><A HREF="#EXPORT_M_Netware_only"> EXPORT - Netware only </A></LI>
</OL>

<H3 ID="EXPORT_M_OSD2__Win16__Win32_only"> EXPORT - OS/2, Win16, Win32/Win64 only </H3>
<P>The EXPORT directive can be used to define the names and attributes of functions in Dynamic Link Libraries
that are to be exported.&nbsp; An EXPORT definition must be specified for every Dynamic Link Library function
that is to be made available externally.
<P>The format of the EXPORT directive ( short form EXP ) is:
<P>
<PRE>
          EXPORT export{,export}
              or
          EXPORT =lbc_file
     <i>OS/2</i>:
          export ::= entry_name[.ordinal][=internal_name]
                     [PRIVATE] [NONAME | RESIDENT] [iopl_bytes]
     <i>Win16</i>:
          export ::= entry_name[.ordinal][=internal_name]
                     [PRIVATE] [NONAME | RESIDENT] 
     <i>Win32/Win64</i>:
          export ::= entry_name[.ordinal][=internal_name]
                     [PRIVATE] [NONAME] 
</PRE>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>entry_name
<DD>is the name to be used by other applications to call the function.
<P><DT>ordinal
<DD>is an ordinal value for the function.&nbsp; If the ordinal number is specified, other applications can reference the function
by using this ordinal number.
<P><DT>internal_name
<DD>is the actual name of the function and should only be specified if it differs from the entry name.
<P><DT>PRIVATE
<DD>(no short form ) specifies that the function's entry name should be included in the DLL's export table, but not included in
any import library that the linker generates.
<P><DT>NONAME
<DD>(no short form ) specifies that the function's entry name should not appear in any name table.
The function can be imported by ordinal only. Using NONAME is similiar to the <A HREF="#ANONYMOUSEXPORT_Directive">ANONYMOUSEXPORT</A>
directive.
<P><DT>RESIDENT
<DD>( short form RES ) specifies that the function's entry name should be kept resident in memory (i.e., added to the
resident names table).
<P>By default, the entry name is always made memory resident if an ordinal is not specified (i.e., it is implicitly RESIDENT).
&nbsp;For 16-bit Windows, the limit on the size of the resident names table is 64K bytes.&nbsp; Memory resident entry names
allow the operating system to resolve calls more efficiently when the call is by entry name rather than by ordinal.
<P>If an ordinal is specified and RESIDENT is not specified, the entry name is added to the non-resident names table (i.e.,
it is implicitly non-RESIDENT).&nbsp; If both the ordinal and the RESIDENT keyword are specified, the symbol is placed in
the resident names table.
<P><DT>iopl_bytes
<DD>(OS/2 only) is required for functions that execute with I/O privilege.<B>&nbsp; iopl_bytes</B> specifies that total size of
the function's arguments in bytes.&nbsp; When such a function is executed, the specified number of bytes is copied from the
caller's stack to the I/O-privileged function's stack.&nbsp; The maximum number of bytes allowed is 63.
<P><DT>lbc_file
<DD>is a file specification for the name of a librarian command file.&nbsp; If no file extension is specified, a file extension
of &quot;lbc&quot; is assumed.&nbsp; The linker will process the librarian command file and look for commands to the librarian
that are used to create import library entries.&nbsp; These commands have the following form.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; ++sym.dll_name[.[altsym].export_name][.ordinal]</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>sym
<DD>is the name of a symbol in a Dynamic Link Library.
<P><DT>dll_name
<DD>is the name of the Dynamic Link Library that defines<TT> sym.</TT>
<P><DT>altsym
<DD>is the name of a symbol in a Dynamic Link Library.&nbsp; When omitted, the default symbol name is<TT> sym.</TT>
<P><DT>export_name
<DD>is the name that an application that is linking to the Dynamic Link Library uses to reference<TT> sym.</TT>&nbsp; When omitted,
the default export name is<TT> sym.</TT>
<P><DT>ordinal
<DD>is the ordinal value that can be used to identify<TT> sym</TT> instead of using the name<TT> export_name.</TT>
</DL>
<P>All other librarian commands will be ignored.
</DL>

<P><B>Notes:</B>
<OL>
<P><LI>By default, the linker knows mangled ( aka "decorated") symbols only;
a prefix or suffix may have been added to the unmangled name. 
This should be taken into account when the <b>internal_name</b> (or the <b>entry_name</b>, if no <b>internal_name</b> is given ) is specified.
The <A HREF="#FUZZYEXPORT_Option">FUZZYEXPORT</A> option may be helpful to avoid having to know the mangled name variants.
<P><LI>If the name contains characters that are special to the linker then the name may be placed inside apostrophes (e.g.,<TT>
export 'myfunc@8'</TT>).
<P><LI>If the<B><I> __export</I></B> declspec modifier is used in the source code, it is the equivalent of using the following
linker directive:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXPORT entry_name RESIDENT</TT>
</OL>

<H3 ID="EXPORT_M_ELF_only"> EXPORT - ELF only </H3>
<P>The EXPORT directive is used to tell JWlink which symbols are available for import by other
executables.&nbsp; The format of the EXPORT directive ( short form EXP ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXPORT entry_name{,entry_name}</TT>
<P>where &lt;entry_name&gt; is the name of the exported symbol.

<P><B>Notes:</B>
<OL>
<P><LI>By default, the Open Watcom C and C++ compilers append an underscore ('_') to all function names.&nbsp; This should
be considered when specifying<B> entry_name</B> in an &quot;EXPORT&quot; directive.
<P><LI>If the name contains characters that are special to the linker then the name may be placed inside apostrophes (e.g.,<TT>
export 'myfunc@8'</TT>).
</OL>

<H3 ID="EXPORT_M_Netware_only"> EXPORT - Netware only </H3>
The EXPORT directive is used to tell JWlink which symbols are available for import by other NLMs.
&nbsp;The format of the EXPORT directive ( short form EXP ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXPORT entry_name{,entry_name}</TT>

<P>where &lt;entry_name&gt; is the name of the exported symbol.

<P><B>Notes:</B>
<OL>
<P><LI>If the name contains characters that are special to the linker then the name may be placed inside apostrophes (e.g.,<TT>
export 'myfunc@8'</TT>).
</OL>

<H2 ID="EXPORTALL_Option"> The EXPORTALL Option </H2>
Formats:&nbsp; ELF
<P>The EXPORTALL option exports all global functions. Syntax is
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION EXPORTALL</TT>
<P>The exported symbols are included in the symbol table of the resulting binary,
which may significantly increase the binary size.

<H2 ID="FARCALLS_Option"> The FARCALLS Option </H2>
Formats:&nbsp; All 
<P>The <b>FARCALLS</b> option tells JWlink to optimize Far Calls.&nbsp; This is the default setting for
JWlink. The format of the FARCALLS option ( short form FAR ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION FARCALLS</TT>
<P>The <b>NOFARCALLS</b> option turns off Far Calls optimization.&nbsp; The format of the NOFARCALLS option
( short form NOFAR ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NOFARCALLS</TT>

<H2 ID="FILE_Directive"> The FILE Directive </H2>
Formats:&nbsp; All 
<P>The FILE directive is used to specify the object files and library modules that JWlink is to
process.&nbsp; The format of the FILE directive ( short form F ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE obj_spec{,obj_spec}</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj_spec ::= obj_file[(obj_module)]</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | library_file[(obj_module)]</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>obj_file
<DD>is a file specification for the name of an object file.&nbsp; If no file extension is specified, a file extension of &quot;obj&quot;
is assumed if you are running a DOS, OS/2 or Windows-hosted version of JWlink.&nbsp; Also, if you are running
a DOS, OS/2 or Windows-hosted version of JWlink, the object file specification can contain wild cards (*,
?).&nbsp; A file extension of &quot;o&quot; is assumed if you are running a UNIX-hosted version of JWlink.
<P><DT>library_file
<DD>is a file specification for the name of a library file.&nbsp; Note that the file extension of the library file (usually &quot;lib&quot;)
must be specified; otherwise an object file will be assumed.&nbsp; When a library file is specified, all object files in the
library are included (whether required or not).
<P><DT>obj_module
<DD>is the name of an object module defined in an object or library file.
</DL>
<P>Consider the following example.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os f \math\sin, mycos</TT>
<P>JWlink is instructed to process the following object files:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; \math\sin.obj</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; mycos.obj</TT>
<P>The object file &quot;mycos.obj&quot; is located in the current directory since no path was specified.
<P>More than one FILE directive may be used.&nbsp; The following example is equivalent to the preceding one.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os f \math\sin f mycos</TT>
<P>Thus, other directives may be placed between lists of object files.
<P>The FILE directive can also specify object modules from a library file or object file.&nbsp; Consider the following
example.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os f \math\math.lib(sin)</TT>
<P>JWlink is instructed to process the object module &quot;sin&quot; contained in the library file &quot;math.lib&quot;
in the directory &quot;\math&quot;.
<P>In the following example, JWlink will process the object module &quot;sin&quot; contained in the object
file &quot;math.obj&quot; in the directory &quot;\math&quot;.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os f \math\math(sin)</TT>
<P>In the following example, JWlink will include all object modules contained in the library file &quot;math.lib&quot;
in the directory &quot;\math&quot;.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os f \math\math.lib</TT>

<H2 ID="FILLCHAR_Option"> The FILLCHAR Option </H2>
Formats:&nbsp; All 
<P>The FILLCHAR option ( short form FILL ) specifies the byte value used to fill gaps in the output
image.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION FILLCHAR=n</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>n
<DD>represents a value.&nbsp; The complete form of<B> n</B> is the following.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; [0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>
<P><B>n</B> specifies the value to be used in blank areas of the output image.&nbsp; The value must be in the range of 0 to
255, inclusive.
<P>This option is most useful for raw binary output that will be programmed into an (E)EPROM where a value of 255 (0xff) is
preferred.&nbsp; The default value of<B> n</B> is zero.

<H2 ID="FIXEDLIB_Directive"> The FIXEDLIB Directive </H2>
Formats:&nbsp; DOS 
<P>The FIXEDLIB directive can be used to explicitly place the modules from a library file in the overlay section
in which the FIXEDLIB directive appears.&nbsp; The format of the FIXEDLIB directive (short form FIX
) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FIXEDLIB library_file{,library_file}</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>library_file
<DD>is a file specification for the name of a library file.&nbsp; If no file extension is specified, a file extension of &quot;lib&quot;
is assumed.
</DL>
<P>Consider the following example.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; begin</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; section file1, file2</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; section file3</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fixedlib mylib</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<P>Two overlay sections are defined.&nbsp; The first contains<TT> file1</TT> and<TT> file2.</TT>&nbsp; The second contains<TT>
file3</TT> and all modules contained in the library file &quot;mylib.lib&quot;.
<P>Note that all modules extracted from library files that appear in a <A HREF="#LIBRARY_Directive">LIBRARY</A> directive are placed in the root
unless the <A HREF="#DISTRIBUTE_Option">DISTRIBUTE</A> option is specified.

<H2 ID="FORCEVECTOR_Directive"> The FORCEVECTOR Directive </H2>
Formats:&nbsp; DOS 
<P>The FORCEVECTOR directive forces JWlink to generate an overlay vector for the specified symbols.
&nbsp;The format of the FORCEVECTOR directive ( short form FORCEVE ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORCEVECTOR symbol_name{,symbol_name}</TT>
<P>where &lt;symbol_name&gt; is a symbol name.

<H2 ID="FORMAT_Directive"> The FORMAT Directive </H2>
Formats:&nbsp; All 
<P>The FORMAT directive is used to specify the format of the executable file that JWlink is to
generate.&nbsp; The format of this directive ( short form FORM ) is:
<PRE>
        FORMAT form
        form ::= <b>DOS</b> [COM]
               | <b>RAW</b> [BIN | HEX]
               | <b>WINDOWS</b> [dll16_attrs] [MEMORY] [FONT] [DPMI]
               | <b>WINDOWS VXD</b> [DYNAMIC]
               | <b>WINDOWS PE</b> [TNT | HX] [dll32_attrs]
               | <b>OS2</b> [dll16_attrs | os2_attrs]
               | <b>OS2 FLAT | LE | LX</b> [dll32_attrs | os2_attrs]
               | <b>PHARLAP</b> [EXTENDED | REX | SEGMENTED]
               | <b>NOVELL</b> [NLM | LAN | DSK | NAM | 'number'] 'description'
               | <b>QNX</b> [FLAT]
               | <b>ELF</b> [DLL]
        dll16_attrs ::= DLL [INITGLOBAL | INITINSTANCE]
        dll32_attrs ::= DLL [INITGLOBAL | INITINSTANCE]
                            [TERMINSTANCE | TERMGLOBAL]
        os2_attrs ::= PM | PMCOMPATIBLE | FULLSCREEN
                      | PHYSDEVICE | VIRTDEVICE
</PRE>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#E0E0E0" ><TH>Format</TH><TH>Description</TH></TR>
<TR BGCOLOR="#F8F8F8" VALIGN="TOP"><TD>DOS<br>abbr: D</TD>
<TD>
tells JWlink to generate a DOS &quot;EXE&quot; file.
<P>The name of the executable file will have extension &quot;exe&quot;.&nbsp; If <b>COM</b> is specified, a DOS &quot;COM&quot;
file will be generated in which case the name of the executable file will have extension &quot;com&quot;.&nbsp; Note that
these default extensions can be overridden by using the <A HREF="#NAME_Directive">NAME</A> directive.
<P>Not all programs can be generated in &quot;COM&quot; format.&nbsp; The following rules must be followed.
<OL>
<LI>The program must consist of only one physical segment.&nbsp; This implies that the size of the program (code and data)
must be less than 64k.
<LI>The program must not contain any segment relocation.&nbsp; A warning message will be issued by JWlink
each time a segment relocation is encountered.
</OL>
<P>A DOS &quot;COM&quot; file cannot contain debugging information.&nbsp; If you wish to debug a DOS &quot;COM&quot; file,
you must use the <A HREF="#SYMFILE_Option">SYMFILE</A> option to instruct JWlink to place the debugging information in a separate
file.
<P>For more information on DOS executable file formats, see the chapter entitled <A HREF="#DOS_Executable_File_Format">DOS Executable File Format</A>.
</TD></TR>

<TR BGCOLOR="#F0F0F0" VALIGN="TOP" ><TD>RAW<br>abbr: R</TD>
<TD>
tells JWlink to generate a RAW output file.
<P>If <b>HEX</b> is specified, a raw 32-bit output file in Intel Hex format with the extension &quot;hex&quot; will be
created.&nbsp; When <b>BIN</b> is specified or RAW is given without further specification, a raw 32-bit image with the
extension &quot;bin&quot; will be created.&nbsp; Note that these default extensions can be overridden by using the <A HREF="#NAME_Directive">NAME</A>
directive to name the executable file.
<P>A raw output file cannot contain debugging information.&nbsp; If you wish to debug a raw file, you must use the <A HREF="#SYMFILE_Option">SYMFILE</A>
option to instruct JWlink to place the debugging information in a separate file.
<P>For more information on RAW executable file formats, see the chapter entitled <A HREF="#RAW__The_RAW_File_Format">RAW:&nbsp; The RAW File Format</A>.
</TD></TR>

<TR BGCOLOR="#F8F8F8" VALIGN="TOP" ><TD>WINDOWS<br>abbr: WIN</TD>
<TD>
tells JWlink to generate a Windows 16-bit executable file (NE format).
<P>The name of the executable file will have extension &quot;exe&quot;.&nbsp; If <b>DLL</b> ( short form DL )
is specified, a Dynamic Link Library will be generated; the name of the executable file will also have extension &quot;exe&quot;.
&nbsp;Note that the default extensions can be overridden by using the <A HREF="#NAME_Directive">NAME</A> directive.
<P>Specifying <b>INITGLOBAL</b> ( short form INITG ) will cause Windows to call an initialization routine the
first time the Dynamic Link Library is loaded.&nbsp; The INITGLOBAL option should be used with <A HREF="#ONEAUTODATA_Option">OPTION ONEAUTODATA</A>
(the default for Dynamic Link Libraries).&nbsp; If the INITGLOBAL option is used with <A HREF="#MANYAUTODATA_Option">OPTION MANYAUTODATA</A>
the initialization code will be called once for the first data segment allocated but not for subsequent allocations (this
is generally not desirable behaviour and will likely cause a program fault).
<P>Specifying <b>INITINSTANCE</b> ( short form INITI ) will cause Windows to call an initialization routine
each time the Dynamic Link Library is used by a process.&nbsp; The INITINSTANCE option should be used with 
<A HREF="#MANYAUTODATA_Option">OPTION MANYAUTODATA</A> (the default for executable programs).
<P>In either case, the initialization routine is defined by the start address.&nbsp; If neither INITGLOBAL nor
INITINSTANCE is specified, INITGLOBAL is assumed.
<P>Specifying <b>MEMORY</b> ( short form MEM ) indicates that the application will run in standard or enhanced
mode.&nbsp; If Windows 3.0 is running in standard and enhanced mode, and MEMORY is not specified, a warning message
will be issued.&nbsp; The MEMORY specification was used in the transition from Windows 2.0 to Windows 3.0.&nbsp;
The MEMORY specification is ignored in Windows 3.1 or later.
<P>Specifying <b>FONT</b> ( short form FO ) indicates that the proportional-spaced system font can be used.
&nbsp;Otherwise, the old-style mono-spaced system font will be used.&nbsp; The FONT specification was used in
the transition from Windows 2.0 to Windows 3.0.&nbsp; The FONT specification is ignored in Windows 3.1 or later.
<P>Specifying <b>DPMI</b> will set the target OS in the executable header to 5; this value is known by
Borland tools - and also by the HX DOS extender - and interpreted as a 16-bit DPMI application. The Windows OS
will no longer try to launch it as a Windows GUI application and execute the DOS-stub instead; hence setting the DPMI
attribute usually also requires to include a special stub with <A HREF="#STUB_Option">OPTION STUB</A>.
<P>For more information on Windows executable file formats, see the chapter entitled <A HREF="#Win16_Executable_and_DLL_File_Formats">Win16 Executable and DLL File Formats</A>.
</TD></TR>

<TR BGCOLOR="#F0F0F0" VALIGN="TOP" >
<TD>WINDOWS VXD</TD>
<TD>
tells JWlink to generate a Windows VxD file (Virtual Device Driver).
<P>The name of the file will have extension &quot;386&quot;.&nbsp; Note that this default extension can be overridden by using
the <A HREF="#NAME_Directive">NAME</A> directive.
<P>Specifying <b>DYNAMIC</b> ( short form DYN ), a dynamicaly loadable driver will be generated (only for Windows
3.11 or 9x).&nbsp; By default JWlink generate staticaly loadable driver (for Windows 3.x or 9x).

<P>For more information on Windows Virtual Device Driver file format, see the chapter entitled <A HREF="#Windows_Virtual_Device_Driver_File_Format">Windows Virtual Device Driver File Format</A>.
</TD></TR>

<TR BGCOLOR="#F8F8F8" VALIGN="TOP" >
<TD>WINDOWS PE</TD>
<TD>
tells JWlink to generate a Win32 or Win64 executable file (PE format). Target Win64 will
be selected automatically if PE32+ COFF modules are detected as input files.
<P>If <b>TNT</b> is specified, an executable for the Phar Lap TNT DOS extender is created.&nbsp;
The <i>magic bytes</i> &quot;PE&quot; are replaced by &quot;PL&quot; in this format, to
prevent the Windows loader from running the program as a Windows application;
instead the Phar Lap TNT DOS extender will always run the application.
<P>If <b>HX</b> is specified, an executable for the HX DOS extender is created.&nbsp;
Here, the <i>magic bytes</i> &quot;PE&quot; are replaced by &quot;PX&quot;, so 
the Windows loader won't get in the way; instead, the HX DOS extender will always run the application.
<P>If <b>DLL</b> ( short form DL ) is specified, a Dynamic Link Library will be generated in which case the
name of the executable file will have extension &quot;dll&quot;.&nbsp; Note that these default extensions can be overridden
by using the <A HREF="#NAME_Directive">NAME</A> directive.

<P>[Note: the following information about INIT* and TERM* attributes may be obsolete.
Recent versions of Windows will ignore the corresponding flags in field <i>DllCharacteristics</i> of the PE header.]
<P>
<font color="#A0A0A0">
<P>Specifying <b>INITGLOBAL</b> ( short form INITG ) will cause the initialization routine to be called the
first time the Dynamic Link Library is loaded.
<P>Specifying <b>INITINSTANCE</b> ( short form INITI ) will cause the initialization routine to be called each
time the Dynamic Link Library is referenced by a process.
<P>In either case, the initialization routine is defined by the start address.&nbsp; 
If neither INITGLOBAL nor INITINSTANCE is specified, INITGLOBAL is assumed.
<P>It is also possible to specify whether the initialization routine is to be called at DLL termination or not.&nbsp; Specifying
<b>TERMGLOBAL</b> ( short form TERMG ) will cause the initialization routine to be called when the last instance
of the Dynamic Link Library is terminated.&nbsp; Specifying <b>TERMINSTANCE</b> ( short form TERMI ) will cause
the initialization routine to be called each time an instance of the Dynamic Link Library is terminated.&nbsp; Note that the
initialization routine is passed an argument indicating whether it is being called during DLL initialization or DLL termination.
&nbsp;If INITINSTANCE is used and no termination option is specified, TERMINSTANCE is assumed.&nbsp;
If INITGLOBAL is used and no termination option is specified, TERMGLOBAL is assumed.
</font>

<P>For more information on Windows PE executable file formats, see the chapter entitled <A HREF="#Win32_Executable_and_DLL_File_Formats">Win32/Win64 Executable and DLL File Formats</A>.
</TD></TR>

<TR BGCOLOR="#F0F0F0" VALIGN="TOP" >
<TD>OS2</TD>
<TD>
tells JWlink to generate a 16-bit OS/2 executable file (NE format).
<P>The name of the executable file will have extension &quot;exe&quot;, unless
<b>DLL</b> ( short form DL ) is specified - in this case, a Dynamic Link Library will be generated and the
name of the executable file will have extension &quot;dll&quot;.&nbsp; Note that these default extensions can be overridden
by using the <A HREF="#NAME_Directive">NAME</A> directive.
<P>Specifying <b>INITGLOBAL</b> ( short form INITG ) will cause the initialization routine to be called the
first time the Dynamic Link Library is loaded.&nbsp; The INITGLOBAL option should be used with <A HREF="#ONEAUTODATA_Option">OPTION ONEAUTODATA</A>
(the default for Dynamic Link Libraries).&nbsp; If the INITGLOBAL option is used with <A HREF="#MANYAUTODATA_Option">OPTION MANYAUTODATA</A>,
the initialization code will be called once for the first data segment allocated but not for subsequent allocations (this
is generally not desirable behaviour and will likely cause a program fault).
<P>Specifying <b>INITINSTANCE</b> ( short form INITI ) will cause the initialization routine to be called each
time the Dynamic Link Library is referenced by a process.&nbsp; The INITINSTANCE option should be used with 
<A HREF="#MANYAUTODATA_Option">OPTION MANYAUTODATA</A> (the default for executable programs).
<P>In either case, the initialization routine is defined by the start address.&nbsp; If neither INITGLOBAL nor
INITINSTANCE is specified, INITGLOBAL is assumed.

<P>If <b>PM</b> is specified, a Presentation Manager application will be created.&nbsp; The application uses the API
provided by the Presentation Manager and must be executed in the Presentation Manager environment.
<P>lf <b>PMCOMPATIBLE</b> ( short form PMC ) is specified, an application compatible with Presentation Manager
will be created.&nbsp; The application can run inside the Presentation Manager or it can run in a separate screen group.&nbsp;
An application can be of this type if it uses the proper subset of OS/2 video, keyboard, and mouse functions supported in
the Presentation Manager applications.&nbsp; This is the default.
<P>If <b>FULLSCREEN</b> ( short form FULL ) is specified, an OS/2 full screen application will be created.
&nbsp;The application will run in a separate screen group from the Presentation Manager.
<P>If <b>PHYSDEVICE</b> ( short form PHYS ) is specified, the executable file is marked as a physical device
driver.
<P>If <b>VIRTDEVICE</b> ( short form VIRT ) is specified, the executable file is marked as a virtual device
driver.
<P>For more information on OS/2 executable file formats, see the chapter entitled <A HREF="#OSD2_Executable_and_DLL_File_Formats">OS/2 Executable and DLL File Formats</A>.
</TD></TR>

<TR BGCOLOR="#F0F0F0" VALIGN="TOP" >
<TD>OS2 FLAT | LE | LX</TD>
<TD>
tells JWlink to generate a 32-bit OS/2 executable file (LE or LX format).
<P>The name of the executable file will have extension &quot;exe&quot;, unless
<b>DLL</b> ( short form DL ) is specified - in this case, a Dynamic Link Library will be generated and the
name of the executable file will have extension &quot;dll&quot;.&nbsp; Note that these default extensions can be overridden
by using the <A HREF="#NAME_Directive">NAME</A> directive.

<P>If <b>LE</b> is specified, an early form of the OS/2 32-bit linear executable will be generated.&nbsp;
This executable file format is required by the CauseWay DOS extender, Tenberry Software's DOS/4G and DOS/4GW DOS extenders, and similar products.
In order to improve load time and minimize the size of the executable file, the OS/2 32-bit linear executable file format
was changed.&nbsp; If <b>LX</b> or <b>FLAT</b> ( short form FL ) is specified, this new form of the OS/2
32-bit linear executable will be generated.&nbsp; Besides OS/2, this file format is also used by the FlashTek DOS extender.

<P>Specifying <b>INITGLOBAL</b> ( short form INITG ) will cause the initialization routine to be called the
first time the Dynamic Link Library is loaded.&nbsp; The INITGLOBAL option should be used with <A HREF="#ONEAUTODATA_Option">OPTION ONEAUTODATA</A>
(the default for Dynamic Link Libraries).&nbsp; If the INITGLOBAL option is used with <A HREF="#MANYAUTODATA_Option">OPTION MANYAUTODATA</A>,
the initialization code will be called once for the first data segment allocated but not for subsequent allocations (this
is generally not desirable behaviour and will likely cause a program fault).
<P>Specifying <b>INITINSTANCE</b> ( short form INITI ) will cause the initialization routine to be called each
time the Dynamic Link Library is referenced by a process.&nbsp; The INITINSTANCE option should be used with 
<A HREF="#MANYAUTODATA_Option">OPTION MANYAUTODATA</A> (the default for executable programs).
<P>In either case, the initialization routine is defined by the start address.&nbsp; If neither INITGLOBAL nor
INITINSTANCE is specified, INITGLOBAL is assumed.

<P>It is also possible to specify whether the initialization routine is to be called
at DLL termination or not.&nbsp; Specifying <b>TERMGLOBAL</b> ( short form TERMG ) will cause the initialization
routine to be called when the last instance of the Dynamic Link Library is terminated.&nbsp; Specifying <b>TERMINSTANCE</b>
( short form TERMI ) will cause the initialization routine to be called each time an instance of the Dynamic Link
Library is terminated.&nbsp; Note that the initialization routine is passed an argument indicating whether it is being called
during DLL initialization or DLL termination.&nbsp; If INITINSTANCE is used and no termination option is specified,
TERMINSTANCE is assumed.&nbsp; If INITGLOBAL is used and no termination option is specified, TERMGLOBAL is assumed.

<P>If <b>PM</b> is specified, a Presentation Manager application will be created.&nbsp; The application uses the API
provided by the Presentation Manager and must be executed in the Presentation Manager environment.
<P>lf <b>PMCOMPATIBLE</b> ( short form PMC ) is specified, an application compatible with Presentation Manager
will be created.&nbsp; The application can run inside the Presentation Manager or it can run in a separate screen group.&nbsp;
An application can be of this type if it uses the proper subset of OS/2 video, keyboard, and mouse functions supported in
the Presentation Manager applications.&nbsp; This is the default.
<P>If <b>FULLSCREEN</b> ( short form FULL ) is specified, an OS/2 full screen application will be created.
&nbsp;The application will run in a separate screen group from the Presentation Manager.
<P>If <b>PHYSDEVICE</b> ( short form PHYS ) is specified, the executable file is marked as a physical device
driver.
<P>If <b>VIRTDEVICE</b> ( short form VIRT ) is specified, the executable file is marked as a virtual device
driver.
<P>For more information on OS/2 executable file formats, see the chapter entitled <A HREF="#OSD2_Executable_and_DLL_File_Formats">OS/2 Executable and DLL File Formats</A>.
</TD></TR>

<TR BGCOLOR="#F8F8F8" VALIGN="TOP" ><TD>PHARLAP<br>abbr: PHAR</TD>
<TD>
tells JWlink to generate an executable file that will run under Phar Lap's 386|DOS-Extender.
<P>There are 4 forms of executable files:&nbsp; simple, extended, relocatable and segmented.&nbsp; If <b>EXTENDED</b>
( short form EXT ) is specified, an extended form of the executable file with file extension &quot;exp&quot; will
be generated.&nbsp; If <b>REX</b> is specified, a relocatable executable file with file extension &quot;rex&quot; will
be generated.&nbsp; If <b>SEGMENTED</b> ( short form SEG ) is specified, a segmented executable file with file
extension &quot;exp&quot; will be generated.&nbsp; If neither EXTENDED, REX or SEGMENTED
is specified, a simple executable file with file extension &quot;exp&quot; will be generated.&nbsp; Note that the default
file extensions can be overridden by using the <A HREF="#NAME_Directive">NAME</A> directive.

<P>The <i>simple</i> form is for flat model 386 applications.&nbsp; It is the only format that can be loaded by earlier versions
of 386|DOS-Extender (earlier than 1.2).
<P>The <i>extended</i> form is used for flat model applications that have been linked in a way which requires a method of specifying
more information for 386|DOS-Extender than possible with the simple form.
<P>The <i>relocatable</i> form is similar to the simple form.&nbsp; Unique to the relocatable form is an offset relocation table.
&nbsp;This allows the loader to load the program at any location it chooses.
<P>The <i>segmented</i> form is used for embedded system applications like Intel RMX.&nbsp; These executables cannot be loaded by
386|DOS-Extender.
<P>A simple form of the executable file is generated in all but the following cases.
<OL>
<LI>EXTENDED is specified in the FORMAT directive.
<LI>The <A HREF="#RUNTIME_Directive">RUNTIME</A> directive is specified.&nbsp; Options specified by the RUNTIME directive can only
be specified in the extended form of the executable file.
<LI>The <A HREF="#OFFSET_Option">OFFSET</A> option is specified.&nbsp; The value specified in the OFFSET option can only be
specified in the extended form of the executable file.
<LI>REX is specified in the FORMAT directive.&nbsp; In this case, the relocatable form will be
generated.&nbsp; You must not specify the RUNTIME directive or the OFFSET option when generating the
relocatable form.
<LI>SEGMENTED is specified in the FORMAT directive.&nbsp; In this case, the segmented form will
be generated.
</OL>
<P>For more information on Phar Lap executable file formats, see the chapter entitled <A HREF="#Phar_Lap__The_Phar_Lap_Executable_File_Format">Phar Lap:&nbsp; The Phar Lap Executable File Format</A>.
</TD></TR>

<TR BGCOLOR="#F0F0F0" VALIGN="TOP" >
<TD>NOVELL<br>abbr: NOV</TD>
<TD>
tells JWlink to generate a NetWare executable file, more commonly called a NetWare
Loadable Module (NLM).
<P>NLMs are further classified according to their function.&nbsp; The executable file will have a file extension that depends
on the class of the NLM being generated.&nbsp; The following describes the classification of NLMs.

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">

<TR valign="top"><TD>LAN</TD>
<TD>instructs JWlink to generate a LAN driver.&nbsp; A LAN driver is a device driver for Local Area Network hardware.
&nbsp;A file extension of &quot;lan&quot; is used for the name of the executable file.
</TD></TR>
<TR valign="top"><TD>DSK</TD>
<TD>instructs JWlink to generate a disk driver.&nbsp; A file extension of &quot;dsk&quot; is used for the name
of the executable file.</TD></TR>
<TR valign="top"><TD>NAM</TD>
<TD>instructs JWlink to generate a file system name-space support module.&nbsp; A file extension of &quot;nam&quot;
is used for the name of the executable file.</TD></TR>
<TR valign="top"><TD>MSL</TD>
<TD>instructs JWlink to generate a Mirrored Server Link module.&nbsp; The default file extension is &quot;msl&quot;</TD></TR>
<TR valign="top"><TD>CDM</TD>
<TD>instructs JWlink to generate a Custom Device module.&nbsp; The default file extension is &quot;cdm&quot;</TD></TR>
<TR valign="top"><TD>HAM</TD>
<TD>instructs JWlink to generate a Host Adapter module.&nbsp; The default file extension is &quot;ham&quot;</TD></TR>
<TR valign="top"><TD>NLM</TD>
<TD>instructs JWlink to generate a utility or server application.&nbsp; This is the default.&nbsp; A file extension
of &quot;nlm&quot; is used for the name of the executable file.</TD></TR>
<TR valign="top"><TD>'number'</TD>
<TD>instructs JWlink to generate a specific type of NLM using 'number'.&nbsp; This is a 32 bit value that corresponds
to Novell allocated NLM types.
<P>These are the current defined values:

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#E0E0E0"><TD>0</TD><TD>Specifies a standard NLM (default extension .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>1</TD><TD>Specifies a disk driver module (default extension .DSK)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>2</TD><TD>Specifies a namespace driver module (default extension .NAM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>3</TD><TD>Specifies a LAN driver module (default extension .LAN)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>4</TD><TD>Specifies a utility NLM (default extension .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>5</TD><TD>Specifies a Mirrored Server Link module (default .MSL)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>6</TD><TD>Specifies an Operating System module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>7</TD><TD>Specifies a Page High OS module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>8</TD><TD>Specifies a Host Adapter module (default .HAM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>9</TD><TD>Specifies a Custom Device module (default .CDM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>10</TD><TD>Reserved for Novell usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>11</TD><TD>Reserved for Novell usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>12</TD><TD>Specifies a Ghost module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>13</TD><TD>Specifies an SMP driver module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>14</TD><TD>Specifies a NIOS module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>15</TD><TD>Specifies a CIOS CAD type module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>16</TD><TD>Specifies a CIOS CLS type module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>21</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>22</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>23</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>24</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>25</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>26</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>27</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>28</TD><TD>Reserved for Novell NICI usage</TD><TR>
</TABLE>
</TD></TR>
</TABLE>
</TD></TR>

<TR><TD>'description'</TD>
<TD>is a textual description of the program being linked.</TD></TR>

</TABLE>
</TD></TR>
</TABLE>

<P>For more information on NetWare executable file formats, see the chapter entitled <A HREF="#NetWare__The_NetWare_ODS_Executable_File_Format">NetWare:&nbsp; The NetWare O/S Executable File Format</A>.
</TD></TR>
<TR BGCOLOR="#F8F8F8" VALIGN="TOP" >
<TD>
QNX</TD>
<TD>
tells JWlink to generate a QNX executable file.
<P>If <b>FLAT</b> ( short form FL ) is specified, a 32-bit flat executable file is generated.
<P>Under QNX, no file extension is added to the executable file name.
<P>Under other operating systems, the name of the executable file will have the extension &quot;qnx&quot;.&nbsp; Note that
this default extension can be overridden by using the <A HREF="#NAME_Directive">NAME</A> directive.
<P>For more information on QNX executable file formats, see the chapter entitled <A HREF="#QNX__The_QNX_Executable_File_Format">QNX:&nbsp; The QNX Executable File Format</A>.
</TD></TR>
<TR BGCOLOR="#F0F0F0" VALIGN="TOP" >
<TD>ELF</TD>
<TD>
tells JWlink to generate an 32-bit or 64-bit ELF format executable file. 
A 64-bit ELF (ELF64) binary will be automatically selected if 64-bit ELF object modules are detected as input files.
<P>ELF format DLLs can also be created, but support for this variant should be regarded &quot;experimental&quot;.
<P>For more information on ELF executable file formats, see the chapter entitled <A HREF="#ELF_Executable_File_Format">ELF32/ELF64 Executable File Format</A>.
</TD></TR>
</TABLE>
</TD></TD>
</TABLE>

<P>If no FORMAT directive is specified, the executable file format will be selected for each of the following
host systems in the way described.
<DL>
<P><DT>DOS
<DD>If 16-bit object files are encountered, a 16-bit DOS executable will be created.&nbsp; If 32-bit object files are encountered,
a 32-bit DOS/4G executable will be created.
<P><DT>OS/2
<DD>If 16-bit object files are encountered, a 16-bit OS/2 executable will be created.&nbsp; If 32-bit object files are encountered,
a 32-bit OS/2 executable will be created.
<P><DT>Windows 9x/ME/NT/2000/XP/Vista/7
<DD>If 16-bit object files are encountered, a 16-bit Windows executable will be created.&nbsp; If 32-bit object files are encountered,
a 32-bit Win32 executable will be created.
</DL>

<H2 ID="FUZZYEXPORT_Option"> The FUZZYEXPORT Option </H2>
Formats:&nbsp; Win32 
<P>The FUZZYEXPORT option makes the linker search for mangled (aka &quot;decorated&quot;) names if
a symbol exported with the <A HREF="#EXPORT_Directive">EXPORT</A> directive cannot be found.
<P> The format of the FUZZYEXPORT option ( short form FUZ ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION FUZZYEXPORT</TT>
<P><B>Example:</B>
<P>A dll may contain 2 functions that are to be exported:
<P><PRE>
     int __stdcall Function1( int var1, long varlong );
     int __stdcall Function2( int var2 );
</PRE>
<P>If option FUZZYEXPORT is <b>not</b> set, one has to tell the linker the decorated names:
<P><PRE>
     jwlink format windows pe dll file test.obj export _Function1@8, _Function2@4
</PRE>
<P>If option FUZZYEXPORT is set, one may use the unmangled names instead:
<P><PRE>
     jwlink format windows pe dll file test.obj export Function1, Function2
</PRE>
<P>Note that option FUZZYEXPORT works with <b>cdecl</b> ( '_'-prefix ) and <b>stdcall</b> ( '_'-prefix and
'@nn'-suffix for functions ) naming conventions only.
Also, if keyword <TT>__export</TT> ( or <TT>__declspec(dllexport)</TT>) is used within the source - and hence
the EXPORT directive isn't necessary - the <A HREF="#NOSTDCALL_Option">NOSTDCALL</A> option is the better choice
to get rid of name decorations.


<H2 ID="HEAPSIZE_Option"> The HEAPSIZE Option </H2>
Formats:&nbsp; OS/2, QNX, Win16, Win32/Win64 
<P>The HEAPSIZE option specifies the size of the heap required by the application.&nbsp; The format of this
option ( short form H ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION HEAPSIZE=n</TT>
<DL><DT>
<P>where &lt;n&gt; represents a numeric value.&nbsp; The complete form of &lt;n&gt; is the following.
<DD>
<P><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>

<P>&lt;n&gt; specifies the size of the heap.&nbsp; 
The default heap size is 0x100000 (1 MB) for Win32/Win64 applications, else it is 0.&nbsp;
The maximum value of &lt;n&gt; is
0x10000 (64 kB) for 16-bit applications and 4 GB for 32-bit applications which is the maximum size of a physical segment.&nbsp;
Actually, for a particular application, the maximum value of &lt;n&gt; is 64K or 4G less the size of group &quot;DGROUP&quot;.

<P>For Win32/Win64, see the <A HREF="#COMMIT_Directive">COMMIT</A> directive for information on how to 
specify the <b>committed</b> size of the heap.

<H2 ID="HELP_Option"> The HELP Option </H2>
Formats:&nbsp; NetWare 
<P>The HELP option specifies the file name of an internationalized help file whose language corresponds to the
message file bound to this NLM.
<P>The format of the HELP option ( short form HE ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION HELP=help_file</TT>
<P>where &lt;help_file&gt; is the name of the help file.

<H2 ID="HSHIFT_Option"> The HSHIFT Option </H2>
Formats:&nbsp; DOS, OS/2, QNX, Win16 
<P>The HSHIFT option defines the relationship between segment and linear address in a segmented executable.&nbsp; The
format of the HSHIFT option is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION HSHIFT=n</TT>
<DL><DT>
<P>where &lt;n&gt; represents a value.&nbsp; The complete form of &lt;n&gt; is the following.
<P><DD><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>
<P>&lt;n&gt; specifies the number of digits to right shift a 32-bit value containing a segment address in its upper 16 bits
in order to convert it to part of a linear address.&nbsp; In more conventional terms, (16 - &lt;n&gt; ) is the amount to shift
a segment value left in order to convert it to part of a linear address.
<P>The HSHIFT option is useful for non-standard segmented architectures that have different alignment between
segments and linear addresses, such as the IP cores by ARC, Inc.&nbsp; These cores support a 24-bit addressing mode where
segment addresses are shifted 8 bits to form part of the linear address.&nbsp; The &lt;n&gt; value and its semantics match
the analogous variable used by the compiler for computing addresses in the huge memory model.
<P>The default value of &lt;n&gt; is 12, representing the 4-bit shift used in conventional x86 CPUs.

<H2 ID="IMPFILE_Option"> The IMPFILE Option </H2>
Formats:&nbsp; NetWare, OS/2, Win16, Win32/Win64 
<P>The IMPFILE option requests the linker to produce a command file for JWlib, the Library Manager. This file can be used
to create an import library that corresponds to the DLL that is being generated.&nbsp; This option is useful in situations
where JWlink cannot create an import library file when you have specified the <A HREF="#IMPLIB_Option">IMPLIB</A> option (i.e.,
the linker fails to launch JWlib, the Library Manager).
<P>The format of the IMPFILE option ( short form IMPF ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION IMPFILE[=imp_file]</TT>
<DL>
<P>where &lt;imp_file&gt; is a file specification for the name of the command file that can be used to create the import library file using the Open
Watcom Library Manager.&nbsp; If no file extension is specified, no file extension is assumed.
</DL>

<P>By default, no command file is generated.&nbsp; Specifying this option causes the linker to generate an import library
command file.&nbsp; The import library command file contains a list of the entry points in your DLL.&nbsp; When this command
file is processed by the Open Watcom Library Manager, an import library file will be produced.
<P>If no file name is specified, the import library command file will have a default file extension of &quot;lbc&quot; and
the same file name as the DLL file.&nbsp; Note that the import library command file will be created in the same directory
as the DLL file.&nbsp; The DLL file path and name can be specified in the <A HREF="#NAME_Directive">NAME</A> directive.
<P>Alternatively, a library command file path and name can be specified.&nbsp; The following directive instructs the linker
to generate a import library command file and call it &quot;mylib.lcf&quot; regardless of the name of the executable file.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; option impfile=mylib.lcf</TT>
<P>You can also specify a path and/or file extension when using the &quot;IMPFILE=&quot; form of the IMPFILE option.

<H2 ID="IMPLIB_Option"> The IMPLIB Option </H2>
Formats:&nbsp; NetWare, OS/2, Win16, Win32/Win64 
<P>The IMPLIB option requests the linker to produce an import library that corresponds to the DLL that is being
generated.&nbsp; The format of the IMPLIB option ( short form IMPL ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION IMPLIB[=imp_lib]</TT>

<P>where &lt;imp_lib&gt; is a file specification for the name of the import library file.&nbsp; If no file extension is specified, a file extension
of &quot;.lib&quot; is assumed.
<P>By default, no library file is generated.&nbsp; Specifying this option causes JWlink to generate an import
library file.&nbsp; The import library file contains a list of the entry points in your DLL.
<P>If no file name is specified, the import library file will have a default file extension of &quot;lib&quot; and the same
file name as the DLL file.&nbsp; Note that the import library file will be created in the same directory as the DLL file.
&nbsp;The DLL file path and name can be specified in the <A HREF="#NAME_Directive">NAME</A> directive.
<P>Alternatively, a library file path and name can be specified.&nbsp; The following directive instructs the linker to generate
a library file and call it &quot;mylib.imp&quot; regardless of the name of the executable file.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; option implib=mylib.imp</TT>
<P>You can also specify a path and/or file extension when using the &quot;IMPLIB=&quot; form of the IMPLIB option.
<HR>
<P><B><I>&nbsp; Note:</I></B>&nbsp; Currently, to create the import library file, the linker spawns JWlib, the Library Manager.
In case this fails, see the <A HREF="#IMPFILE_Option">IMPFILE</A> option.
<HR>

<H2 ID="IMPORT_Directive"> The IMPORT Directive </H2>
Formats:&nbsp; ELF, NetWare, OS/2, Win16, Win32/Win64 
<P>The IMPORT directive is used to tell JWlink what symbols are defined externally in other executables.

<OL>
<LI><A HREF="#IMPORT_M_OSD2__Win16__Win32_only"> IMPORT - OS/2, Win16, Win32/Win64 only </A></LI>
<LI><A HREF="#IMPORT_M_ELF_only"> IMPORT - ELF only </A></LI>
<LI><A HREF="#IMPORT_M_Netware_only"> IMPORT - Netware only </A></LI>
</OL>

<H3 ID="IMPORT_M_OSD2__Win16__Win32_only"> IMPORT - OS/2, Win16, Win32/Win64 only </H3>
<P>The IMPORT directive describes a function that belongs to a Dynamic Link Library.&nbsp; The format of the IMPORT
directive ( short form IMP ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPORT import{,import}</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; import ::= internal_name module_name[.entry_name | ordinal]</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>internal_name
<DD>is the name the application used to call the function.
<P><DT>module_name
<DD>is the name of the Dynamic Link Library.&nbsp; Note that this need not be the same as the file name of the executable file
containing the Dynamic Link Library.&nbsp; This name corresponds to the name specified by the &quot;MODNAME&quot; option when
the Dynamic Link Library was created.
<P><DT>entry_name
<DD>is the actual name of the function as defined in the Dynamic Link Library.
<P><DT>ordinal
<DD>is the ordinal value of the function.&nbsp; The ordinal number is an alternate method that can be used to reference a function
in a Dynamic Link Library.
</DL>
<P><B>Notes:</B>
<OL>
<P><LI>By default, the Open Watcom C and C++ compilers append an underscore ('_') to all function names.&nbsp; This should
be considered when specifying<B> internal_name</B> and<B> entry_name</B> in an IMPORT directive.
<P><LI>If the name contains characters that are special to the linker then the name may be placed inside apostrophes (e.g.,<TT>
import 'myfunc@8'</TT>).
</OL>
<P>The preferred method to resolve references to Dynamic Link Libraries is through the use of import libraries.&nbsp; See
the sections entitled <A HREF="#OSD2__Using_a_Dynamic_Link_Library">Using a Dynamic Link Library in OS/2</A>, <A HREF="#Win16__Using_a_Dynamic_Link_Library">Using a Dynamic Link Library in Win16</A>,
or <A HREF="#Win32__Using_a_Dynamic_Link_Library">Using a Dynamic Link Library in Win32/Win64</A> for more information on import
libraries.

<H3 ID="IMPORT_M_ELF_only"> IMPORT - ELF only </H3>
<P>The IMPORT directive is used to tell JWlink what symbols are defined externally in other executables.
&nbsp;The format of the IMPORT directive ( short form IMP ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPORT external_name{,external_name}</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>external_name
<DD>is the name of the external symbol.
</DL>
<P><B>Notes:</B>
<OL>
<P><LI>By default, the Open Watcom C and C++ compilers append an underscore ('_') to all function names.&nbsp; This should
be considered when specifying<B> external_name</B> in an IMPORT directive.
<P><LI>If the name contains characters that are special to the linker then the name may be placed inside apostrophes (e.g.,<TT>
import 'myfunc@8'</TT>).
</OL>

<H3 ID="IMPORT_M_Netware_only"> IMPORT - Netware only </H3>
The IMPORT directive is used to tell JWlink what symbols are defined externally in other NLMs.
&nbsp;The format of the IMPORT directive ( short form IMP ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPORT external_name{,external_name}</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>external_name
<DD>is the name of the external symbol.
</DL>
<P><B>Notes:</B>
<OL>
<P><LI>If the name contains characters that are special to the linker then the name may be placed inside apostrophes (e.g.,<TT>
import 'myfunc@8'</TT>).
</OL>
<P>If an NLM contains external symbols, the NLMs that define the external symbols must be loaded before the NLM that references
the external symbols is loaded.

<H2 ID="INCREMENTAL_Option"> The INCREMENTAL Option </H2>
Formats:&nbsp; ELF, OS/2, PharLap, QNX, Win16, Win32 
<P>The INCREMENTAL option can be used to enable incremental linking.&nbsp; Incremental linking is a process whereby
the linker attempts to modify the existing executable file by changing only those portions for which new object files are
provided.
<P>The format of the INCREMENTAL option ( short form INC ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION INCREMENTAL[=inc_file_name]</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>inc_file_name
<DD>is a file specification for the name of the incremental information file.&nbsp; If no file extension is specified, a file
extension of &quot;ilk&quot; is assumed.
</DL>
<P>This option engages the incremental linking feature of the linker.&nbsp; This option must be one of the first options encountered
in the list of directives and options supplied to the linker.&nbsp; If the option is presented too late, the linker will issue
a diagnostic message.
<P>By default, the incremental information file has the same name as the program except with an &quot;ilk&quot; extension
unless the <A HREF="#NAME_Directive">NAME</A> directive has not been seen yet.&nbsp; If this is the case then the file is called<TT> __jwlink.ilk.</TT>
<P>The linker's incremental linking technique is very resistant to changes in the underlying object files - there are very
few cases where an incremental re-link is not possible.&nbsp; The options <A HREF="#ELIMINATE_Option">ELIMINATE</A> and <A HREF="#VFREMOVAL_Option">VFREMOVAL</A>
cannot be used at the same time as incremental linking.
<P>It is possible, over time, to accumulate unneeded functions in the executable by using incremental linking.&nbsp; To guarantee
an executable of minimum size, you can cause a full relink by deleting the &quot;.ilk&quot; file or by not specifying the
INCREMENTAL option.
<P>Do not use a post processor like the Open Watcom Resource Compiler on the executable file since this will damage the data
structures maintained by the linker.&nbsp; Add resources to the executable file using the <A HREF="#RESOURCE_Option">RESOURCE</A> option.

<HR>
<P><B><I>&nbsp; Note:</I></B>&nbsp; Only DWARF debugging information is supported with incremental linking.
<HR>
<H2 ID="INTERNALRELOCS_Option"> The INTERNALRELOCS Option </H2>
Formats:&nbsp; OS/2 
<P>The INTERNALRELOCS option is used with LX format executables under 32-bit OS/2.&nbsp; By default, OS/2 executables
do not contain internal relocation information and OS/2 Dynamic Link Libraries do contain internal relocation information.
&nbsp;This option causes JWlink to include internal relocation information in OS/2 LX format executables.
<P>The format of the INTERNALRELOCS option ( short form INT ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION INTERNALRELOCS</TT>

<H2 ID="KNOWEAS_Option"> The KNOWEAS Option </H2>
Formats:&nbsp; DOS 
<P>The KNOWEAS option may be used with MZ format executables.
It makes JWlink reserve at least 0x40 bytes for the header, thus allowing to
use the binary as a stub for other formats (NE, LE, PE).
This option is only needed when the non-DOS executable
is to be created by a third-party linker which does not automatically extend the header size.

<P>The format of the KNOWEAS option is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION KNOWEAS</TT>

<H2 ID="LANGUAGE_Directive"> The LANGUAGE Directive </H2>
Formats:&nbsp; All 
<P>The LANGUAGE directive is used to specify the language in which strings in JWlink directives
are specified.&nbsp; The format of the LANGUAGE directive ( short form LANG ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LANGUAGE lang</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lang ::= JAPANESE | CHINESE | KOREAN</TT>
<DL>
<P><DT>JAPANESE
<DD>(short form &quot;JA&quot;) specifies that strings are to be handled as if they contained characters from the Japanese Double-Byte
Character Set (DBCS).
<P><DT>CHINESE
<DD>(short form &quot;CH&quot;) specifies that strings are to be handled as if they contained characters from the Chinese Double-Byte
Character Set (DBCS).
<P><DT>KOREAN
<DD>(short form &quot;KO&quot;) specifies that strings are to be handled as if they contained characters from the Korean Double-Byte
Character Set (DBCS).
</DL>

<H2 ID="LARGEADDRESSAWARE_Option"> The LARGEADDRESSAWARE Option </H2>
Formats:&nbsp; Win32/Win64
<P>The LARGEADDRESSAWARE option is used with PE format executables.&nbsp; This option will make
JWlink set a flag in the PE header telling the OS that this application is able to handle a private address space of more
than 2 GB. For PE32+ format executables (Win64), this is the default, hence this option has an effect for Win32 executables only.
<P>The format of the LARGEADDRESSAWARE option ( short form LARGE ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION LARGEADDRESSAWARE</TT>

<H2 ID="LIBFILE_Directive"> The LIBFILE Directive </H2>
Formats:&nbsp; All 
<P>The LIBFILE directive is used to specify the object files that JWlink is to process.&nbsp;
The format of this directive ( short form is LIBF ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LIBFILE obj_spec{,obj_spec}</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj_spec ::= obj_file | library_file</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>obj_file
<DD>is a file specification for the name of an object file.&nbsp; If no file extension is specified, a file extension of &quot;obj&quot;
is assumed if you are running a DOS, OS/2 or Windows-hosted version of JWlink.&nbsp; Also, if you are running
a DOS, OS/2 or Windows-hosted version of JWlink, the object file specification can contain wild cards (*,
?).&nbsp; A file extension of &quot;o&quot; is assumed if you are running a UNIX-hosted version of JWlink.
<P><DT>library_file
<DD>is a file specification for the name of a library file.&nbsp; Note that the file extension of the library file (usually &quot;lib&quot;)
must be specified; otherwise an object file will be assumed.&nbsp; When a library file is specified, all object files in the
library are included (whether required or not).
</DL>
<P>The difference between the LIBFILE and the <A HREF="#FILE_Directive">FILE</A> directives is as follows.
<OL>
<P><LI>When searching for an object or library file specified in a LIBFILE directive, the current working directory
will be searched first, followed by the paths specified in the <A HREF="#LIBPATH_Directive">LIBPATH</A> directive, and finally the paths specified
in the &quot;LIB&quot; environment variable.&nbsp; Note that if the object or library file name contains a path, only the
specified path will be searched.
<P><LI>Object or library file names specified in a LIBFILE directive will not be used to create the name of the
executable file when no <A HREF="#NAME_Directive">NAME</A> directive is specified.
</OL>
<P>Essentially, object files that appear in LIBFILE directives are viewed as components of a library that have
not been explicitly placed in a library file.
<P>Consider the following linker directive file.
<P>
<PRE>
     libpath \libs
     libfile mystart
     path \objs
     file file1, file2
</PRE>
<P>JWlink is instructed to process the following object files:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; \libs\mystart.obj</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; \objs\file1.obj</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; \objs\file2.obj</TT>
<P>Note that the executable file will have file name &quot;file1&quot; and not &quot;mystart&quot;.

<H2 ID="LIBPATH_Directive"> The LIBPATH Directive </H2>
Formats:&nbsp; All 
<P>The LIBPATH directive is used to specify the directories that are to be searched for library files appearing
in subsequent <A HREF="#LIBRARY_Directive">LIBRARY</A> directives and object files appearing in subsequent <A HREF="#LIBFILE_Directive">LIBFILE</A> directives.&nbsp;
The format of the LIBPATH directive ( short form LIBP ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LIBPATH [path_name{;path_name}]</TT>

<P>where &lt;path_name&gt; is a path name.

<P>Consider a directive file containing the following linker directives.
<P><PRE>
     file test
     libpath \math
     library trig
     libfile newsin
</PRE>
<P>First, JWlink will process the object file &quot;test.obj&quot; from the current working directory.&nbsp;
The object file &quot;newsin.obj&quot; will then be processed, searching the current working directory first.&nbsp; If &quot;newsin.obj&quot;
is not in the current working directory, the &quot;\math&quot; directory will be searched.&nbsp; If any unresolved references
remain after processing the object files, the library file &quot;trig.lib&quot; will be searched.&nbsp; If the file &quot;trig.lib&quot;
does not exist in the current working directory, the &quot;\math&quot; directory will be searched.

<P>It is also possible to specify a list of paths in a LIBPATH directive.&nbsp; Consider the following example.
<P><PRE>
     libpath \newmath;\math
     library trig
</PRE>
<P>When processing undefined references, JWlink will attempt to process the library file &quot;trig.lib&quot;
in the current working directory.&nbsp; If &quot;trig.lib&quot; does not exist in the current working directory, the &quot;\newmath&quot;
directory will be searched.&nbsp; If &quot;trig.lib&quot; does not exist in the &quot;\newmath&quot; directory, the &quot;\math&quot;
directory will be searched.
<P>If the name of a library file appearing in a <A HREF="#LIBRARY_Directive">LIBRARY</A> directive or the name of an object file appearing in a
<A HREF="#LIBFILE_Directive">LIBFILE</A> directive contains a path specification, only the specified path will be searched.
<P>Note that
<P><PRE>
     libpath path1
     libpath path2
</PRE>
<P>is equivalent to the following.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; libpath path2;path1</TT>

<H2 ID="LIBRARY_Directive"> The LIBRARY Directive </H2>
Formats:&nbsp; All 
<P>The LIBRARY directive is used to specify the library files to be searched when unresolved symbols remain after
processing all specified input object files.&nbsp; The format of the LIBRARY directive ( short form L ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LIBRARY library_file{,library_file}</TT>
<P>where &lt;library_file&gt; is a file specification for the name of a library file.&nbsp; If no file extension is specified, a file extension of &quot;lib&quot;
is assumed.

<P>Consider the following example.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os file trig lib \math\trig, \cmplx\trig</TT>
<P>JWlink is instructed to process the following object file:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; trig.obj</TT>
<P>If any unresolved symbol references remain after all object files have been processed, the following library files will
be searched:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; \math\trig.lib</TT><br>
<TT>&nbsp;&nbsp;&nbsp;&nbsp; \cmplx\trig.lib</TT>
<P>More than one LIBRARY directive may be used.&nbsp; The following example is equivalent to the preceding one.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os f trig lib \math\trig lib \cmplx\trig</TT>
<P>Thus other directives may be placed between lists of library files.

<H3 ID="Searching_for_Libraries_Specified_in_Environment_Variables"> Searching for Libraries Specified in Environment Variables </H3>
<P>The &quot;LIB&quot; environment variable can be used to specify a list of paths that will be searched for library files.
&nbsp;The &quot;LIB&quot; environment variable can be set using the &quot;set&quot; command as follows:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; set lib=\graphics\lib;\utility</TT>
<P>Consider the following LIBRARY directive and the above definition of the &quot;LIB&quot; environment variable.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; library \mylibs\util, graph</TT>
<P>If undefined symbols remain after processing all object files specified in all <A HREF="#FILE_Directive">FILE</A> directives, JWlink
will resolve these references by searching the following libraries in the specified order.
<OL>
<LI>the library file &quot;\mylibs\util.lib&quot;
<LI>the library file &quot;graph.lib&quot; in the current directory
<LI>the library file &quot;\graphics\lib\graph.lib&quot;
<LI>the library file &quot;\utility\graph.lib&quot;
</OL>
<P><B>Notes:</B>
<OL>
<P><LI>If a library file specified in a LIBRARY directive contains an absolute path specification, JWlink
will not search any of the paths specified in the &quot;LIB&quot; environment string for the library file.&nbsp; Under
QNX, an absolute path specification is one that begins the &quot;/&quot; character.&nbsp; Under all other operating systems,
an absolute path specification is one that begins with a drive specification or the &quot;\&quot; character.
<P><LI>Once a library file has been found, no further elements of the &quot;LIB&quot; environment variable are searched for
other libraries of the same name.&nbsp; That is, if the library file &quot;\graphics\lib\graph.lib&quot; exists, the library
file &quot;\utility\graph.lib&quot; will not be searched even though unresolved references may remain.
</OL>

<H3 ID="Converting_Libraries_Created_using_Phar_Lap_386_LIB"> Converting Libraries Created using Phar Lap 386|LIB </H3>
Phar Lap's librarian, 386|LIB, creates libraries whose dictionary is a different format from the one used by other librarians.
&nbsp;For this reason, linking an application using JWlink with libraries created using 386|LIB will not work.
&nbsp;Library files created using 386|LIB must be converted to the form recognized by JWlink.&nbsp; This is
achieved by issuing the following JWlib command.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlib newlib +pharlib.lib</TT>
<P>The library file &quot;pharlib.lib&quot; is a library created using 386|LIB.&nbsp; The library file &quot;newlib.lib&quot;
will be created so that JWlink can now process it.

<H2 ID="LINEARRELOCS_Option"> The LINEARRELOCS Option </H2>
Formats:&nbsp; QNX 
<P>The LINEARRELOCS option instructs the linker to generate offset fixups in addition to the normal segment fixups.
&nbsp;The offset fixups allow the system to move pieces of code and data that were loaded at a particular offset within a
segment to another offset within the same segment.
<P>The format of the LINEARRELOCS option ( short form LI ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION LINEARRELOCS</TT>

<H2 ID="LINKVERSION_Option"> The LINKVERSION Option </H2>
Formats:&nbsp; Win32/Win64 
<P>The LINKVERSION option specifies that the linker should apply the given major and minor version numbers to
the PE format image header.&nbsp; If a version number is not specified, then the built-in value of 2.18 is used.&nbsp; The
format of the LINKVERSION option ( short form LINKV ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION LINKVERSION = major[.minor]</TT>

<H2 ID="LONGLIVED_Option"> The LONGLIVED Option </H2>
Formats:&nbsp; QNX 
<P>The LONGLIVED option specifies that the application being linked will reside in memory, or be active, for a
long period of time (e.g., background tasks).&nbsp; The memory manager, knowing an application is &quot;LONGLIVED&quot;, allocates
memory for the application so as to reduce fragmentation.
<P>The format of the LONGLIVED option ( short form LO ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION LONGLIVED</TT>

<H2 ID="MANGLEDNAMES_Option"> The MANGLEDNAMES Option </H2>
Formats:&nbsp; All 
<P>The MANGLEDNAMES option should only be used if you are developing a Open Watcom C++ application.&nbsp; Due
to the nature of C++, the Open Watcom C++ compiler generates mangled names for symbols.&nbsp; A mangled name for a symbol
includes the following.
<OL>
<LI>symbol name
<LI>scoping information
<LI>typing information
</OL>
<P>This information is stored in a cryptic form with the symbol.&nbsp; When the linker encounters a mangled name in an object
file, it formats the above information and produces this name in the map file.
<P>If you would like the linker to produce the mangled name as it appeared in the object file, specify the MANGLEDNAMES
option.
<P>The format of the MANGLEDNAMES option ( short form MANG ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION MANGLEDNAMES</TT>

<H2 ID="MANYAUTODATA_Option"> The MANYAUTODATA Option </H2>
Formats:&nbsp; OS/2, Win16 
<P>The MANYAUTODATA option specifies that a copy of the automatic data segment (default data segment defined by
the group &quot;DGROUP&quot;), for the program module or Dynamic Link Library (DLL) being created, is made for each instance.
&nbsp;The format of the MANYAUTODATA option ( short form MANY ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION MANYAUTODATA</TT>
<P>The default for a program module is MANYAUTODATA and for a Dynamic Link Library is <A HREF="#ONEAUTODATA_Option">ONEAUTODATA</A>
&nbsp;If you do not want the data area of a DLL to be shared across multiple applications, then you should specify OPTION
MANYAUTODATA.
<DL>
<P><DT>Win16:
<DD>Note, however, that this attribute is not supported by Windows 3.x for 16-bit DLLs.
</DL>
<P>See the <A HREF="#FORMAT_Directive">FORMAT</A> directive for more information
on the INITINSTANCE, TERMINSTANCE, INITGLOBAL and TERMGLOBAL DLL attributes.

<H2 ID="MAP_Option"> The MAP Option </H2>
Formats:&nbsp; All 
<P>The MAP option controls the generation of a map file.&nbsp; The format of this option ( short
form M ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION MAP[=map_file]</TT>
<P>where &lt;map_file&gt; is a file specification for the name of the map file.&nbsp; If no file extension is specified, a file extension of &quot;map&quot;
is assumed.

<P>By default, no map file is generated.&nbsp; Specifying this option causes JWlink to generate a map file.
&nbsp;The map file is simply a memory map of your program.&nbsp; That is, it specifies the relative location of all global
symbols in your program.&nbsp; The map file also contains the size of your program.
<P>If no file name is specified, the map file will have a default file extension of &quot;map&quot; and the same file name
as the executable file.&nbsp; Note that the map file will be created in the current directory even if the executable file
name specified in the <A HREF="#NAME_Directive">NAME</A> directive contains a path specification.
<P>Alternatively, a file name can be specified.&nbsp; The following directive instructs the linker to generate a map file
and call it &quot;myprog.map&quot; regardless of the name of the executable file.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; option map=myprog</TT>
<P>You can also specify a path and/or file extension when using the &quot;MAP=&quot; form of the MAP option.
<P>Other options and directives that may influence the contents of the map file: 
<UL>
<LI><A HREF="#SORT_Directive">SORT</A> directive - how to change the sorting of symbols in the map file
<LI><A HREF="#STATICS_Option">STATICS</A> option - how to add static symbols to the memory map
<LI><A HREF="#ARTIFICIAL_Option">ARTIFICIAL</A> option - how to add Open Watcom C++ compiler-generated symbols to the map file.
<LI><A HREF="#SHOWDEAD_Option">SHOWDEAD</A> option
<LI><A HREF="#MODTRACE_Directive">MODTRACE</A> directive
<LI><A HREF="#SYMTRACE_Directive">SYMTRACE</A> directive
</UL>

<H2 ID="MAXDATA_Option"> The MAXDATA Option </H2>
Formats:&nbsp; PharLap 
<P>The format of the &quot;MAXDATA&quot; option (short form &quot;MAXD&quot;) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION MAXDATA=n</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>n
<DD>represents a value.&nbsp; The complete form of<B> n</B> is the following.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; [0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>
<P><B>n</B> specifies the maximum number of bytes, in addition to the memory required by executable image, that may be allocated
by 386|DOS-Extender at the end of the loaded executable image.&nbsp; No more than<B> n</B> bytes will be allocated.
<P>If the MAXDATA option is not specified, a default value of hexadecimal ffffffff is assumed.&nbsp; This means
that 386|DOS-Extender will allocate all available memory to the program at load time.

<H2 ID="MAXERRORS_Option"> The MAXERRORS Option </H2>
Formats:&nbsp; All 
<P>The MAXERRORS option can be used to set a limit on the number of error messages generated by the linker.&nbsp;
Note that this does not include warning messages.&nbsp; When this limit is reached, the linker will issue a fatal error and
terminate.
<P>The format of the MAXERRORS option ( short form MAXE ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION MAXERRORS=n</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>n
<DD>is the maximum number of error messages issued by the linker.
</DL>

<H2 ID="MESSAGES_Option"> The MESSAGES Option </H2>
Formats:&nbsp; NetWare 
<P>The MESSAGES option specifies the file name of an internationalized message file that contains the default
messages for the NLM.&nbsp; This is the name of the default message file to load for NLMs that are enabled.&nbsp; Enabling
allows the same NLM to display messages in different languages by switching message files.
<P>The format of the MESSAGES option ( short form MES ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION MESSAGES=msg_file</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>msg_file
<DD>is the name of the message file.
</DL>

<H2 ID="MINDATA_Option"> The MINDATA Option </H2>
Formats:&nbsp; PharLap 
<P>The format of the MINDATA option ( short form MIND ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION MINDATA=n</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>n
<DD>represents a value.&nbsp; The complete form of<B> n</B> is the following.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; [0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>
<P><B>n</B> specifies the minimum number of bytes, in addition to the memory required by executable image, that must be allocated
by 386|DOS-Extender at the end of the loaded executable image.&nbsp; If<B> n</B> bytes are not available, the program will
not be executed.
<P>If the MINDATA option is not specified, a default value of zero is assumed.&nbsp; This means that 386|DOS-Extender
will load the program as long as there is enough memory for the load image; no extra memory is required.

<H2 ID="MIXED1632_Option"> The MIXED1632 Option </H2>
Formats:&nbsp; OS/2 
<P>The MIXED1632 option specifies that 16-bit and 32-bit logical segments may be grouped into a single physical
segment.&nbsp; This applies to both code and data segments.
<P>The format of the MIXED1632 option ( short form MIX ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION MIXED1632</TT>
<P>This option is useful certain specialized applications, such as OS/2 physical device drivers.&nbsp; In most cases, mixing
of 16-bit and 32-bit segments should be avoided.

<H2 ID="MODNAME_Option"> The MODNAME Option </H2>
Formats:&nbsp; OS/2, Win16, Win32/Win64 
<P>The MODNAME option specifies a name to be given to the module being created.&nbsp; The format of the MODNAME
option ( short form MODN ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION MODNAME=module_name</TT>
<P>where &lt;module_name&gt; is the name of a Dynamic Link Library.

<P>Once a module has been loaded (whether it be a program module or a Dynamic Link Library), &lt;mod_name&gt; is the name of
the module known to the operating system.&nbsp; If the MODNAME option is not used to specify a module name, the
default module name is the name of the executable file without the file extension.

<H2 ID="MODFILE_Directive"> The MODFILE Directive </H2>
Formats:&nbsp; All 
<P>The MODFILE directive instructs the linker that only the specified object files have changed.&nbsp; The format
of the MODFILE directive ( short form MODF ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MODFILE obj_file{,obj_file}</TT>
<P>where &lt;obj_file&gt; is a file specification for the name of an object file.&nbsp; If no file extension is specified, a file extension of &quot;obj&quot;
is assumed if you are running a DOS, OS/2 or Windows-hosted version of JWlink.&nbsp; Also, if you are running
a DOS, OS/2 or Windows-hosted version of JWlink, the object file specification can contain wild cards (*,
?).&nbsp; A file extension of &quot;o&quot; is assumed if you are running a UNIX-hosted version of JWlink.

<P>This directive is used only in concert with incremental linking.&nbsp; This directive tells the linker that only the specified
object files have changed.&nbsp; When this option is specified, the linker will not check the dates on any of the object files
or libraries when incrementally linking.

<H2 ID="MODTRACE_Directive"> The MODTRACE Directive </H2>
Formats:&nbsp; All 
<P>The MODTRACE directive instructs JWlink to print a list of all modules that reference the symbols
defined in the specified modules.&nbsp; The format of this directive ( short form MODT ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MODTRACE&nbsp; module_name{,module_name}</TT>
<P>where &lt;module_name&gt; is the name of an object module defined in an object or library file.

<P>The information is displayed in the map file ( see the <A HREF="#MAP_Option">MAP</A> option ).
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os op map file test lib math modt trig</TT>
<P>If the module &quot;trig&quot; defines the symbols &quot;sin&quot; and &quot;cos&quot;, JWlink will list,
in the map file, all modules that reference the symbols &quot;sin&quot; and &quot;cos&quot;.
<P>Also see the <A HREF="#SYMTRACE_Directive">SYMTRACE</A> directive.

<H2 ID="MODULE_Directive"> The MODULE Directive </H2>
Formats:&nbsp; ELF, NetWare 
<P>The MODULE directive is used to specify the DLLs or NLMs to be loaded before this executable is loaded.&nbsp;
The format of the MODULE directive ( short form MODU ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MODULE module_name{,module_name}</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>module_name
<DD>is the file name of a DLL or NLM.
</DL>
<HR>
<B><I>&nbsp; WARNING!</I></B>&nbsp; Versions 3.0 and 3.1 of the NetWare operating system do not support the automatic loading
of modules specified in the &quot;MODULE&quot; directive.&nbsp; You must load them manually.
<HR>

<H2 ID="MULTILOAD_Option"> The MULTILOAD Option </H2>
Formats:&nbsp; NetWare 
<P>The MULTILOAD option specifies that the module can be loaded more than once by a &quot;load&quot; command.
&nbsp;The format of the MULTILOAD option ( short form MULTIL ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION MULTILOAD</TT>
<P>If the MULTILOAD option is not specified, it will not be possible to load the module more than once using the
&quot;load&quot; command.

<H2 ID="NAME_Directive"> The NAME Directive </H2>
Formats:&nbsp; All 
<P>The NAME directive is used to provide a name for the executable file generated by JWlink.&nbsp;
The format of the NAME directive ( short form is N ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAME exe_file</TT>
<P>where &lt;exe_file&gt; specifies the name of the executable file.&nbsp;
Under UNIX, or if the <A HREF="#NOEXTENSION_Option">NOEXTENSION</A> option was
specified, no file extension is appended.&nbsp; In all other cases, a file extension suitable for the current executable file
format is appended if no file extension is specified.

<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os name myprog file test, test2, test3</TT>
<P>Here the linker is instructed to generate an executable file called &quot;myprog.exe&quot; if you are running a DOS, OS/2 or
Windows-hosted version of the linker.&nbsp; If you are running a UNIX-hosted version of the linker, or the <A HREF="#NOEXTENSION_Option">NOEXTENSION</A>
option was specified, an executable file called &quot;myprog&quot; will be generated.
<P><B>Notes:</B>
<OL>
<P><LI>No file extension was given when the executable file name was specified.&nbsp; The linker assumes a file extension
that depends on the format of the executable file being generated.&nbsp; If you are running a UNIX-hosted version of the linker,
or the <A HREF="#NOEXTENSION_Option">NOEXTENSION</A> option was specified, no file extension will be assumed.&nbsp;
The <A HREF="#FORMAT_Directive">FORMAT</A> directive describes in more detail
how the file extension is chosen for each executable file format.
<P><LI>If no NAME directive is present, the executable file will have the file name of the first object file processed
by the linker.&nbsp; If the first object file processed is called &quot;test.obj&quot; and no NAME directive is
specified, an executable file called &quot;test.exe&quot; will be generated if you are running a DOS or OS/2-hosted version
of the linker.&nbsp; If you are running a UNIX-hosted version of the linker, or the <A HREF="#NOEXTENSION_Option">NOEXTENSION</A> option was used,
an executable file called &quot;test&quot; will be generated.
</OL>

<H2 ID="NAMELEN_Option"> The NAMELEN Option </H2>
Formats:&nbsp; All 
<P>The NAMELEN option tells JWlink to limit the significant characters of symbols.&nbsp;
<P>The format of this option ( short form NAMEL ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NAMELEN=n</TT>
<DL>
<P>where &lt;n&gt; is a numeric value.&nbsp; The complete form of &lt;n&gt; is:
<DD>
<P><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>

<P>The number of significant characters for any symbol will be restricted to &lt;n&gt;.
If the significant part of any global symbol is not unique, a warning or error message will be issued,
depending on the <A HREF="#REDEFSOK_Option">[NO]REDEFSOK</A> option.&nbsp;

<P>Some computer systems, for example, require that all global symbols be uniquely identified in 8 characters.&nbsp; By specifying
an appropriate value for the NAMELEN option, you can ease the task of porting your application to other computer
systems.

<H2 ID="NEWFILES_Option"> The NEWFILES Option </H2>
Formats:&nbsp; OS/2 
<P>The NEWFILES option specifies that the application uses the high-performance file system.&nbsp; This option
is applicable to 16-bit OS/2 applications only.&nbsp; The format of the NEWFILES option ( short form NEWF )
is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NEWFILES</TT>

<H2 ID="NEWSEGMENT_Directive"> The NEWSEGMENT Directive </H2>
Formats:&nbsp; DOS, OS/2, QNX, Win16 
<P>This directive is intended for 16-bit segmented applications.&nbsp; By default, JWlink automatically groups
logical code segments into physical segments.&nbsp; By default, these segments are 64K bytes in size.&nbsp; However, the 
<A HREF="#PACKCODE_Option">PACKCODE</A> option can be used to specify a maximum size for all physical segments that is smaller than 64K bytes.
<P>The NEWSEGMENT directive provides an alternate method of grouping code segments into physical segments.&nbsp;
By placing this directive after a sequence of <A HREF="#FILE_Directive">FILE</A> directives, all code segments appearing in object modules specified
by the sequence of <A HREF="#FILE_Directive">FILE</A> directives will be packed into a physical segment.&nbsp; Note that the size of a physical
segment may vary in size.&nbsp; The format of the NEWSEGMENT directive ( short form NEW ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEWSEGMENT</TT>
<P>Consider the following example.
<P><PRE>
     file file1, file2, file3
     newsegment
     file file4
     file file5
</PRE>
<P>Code segments from<B> file1, file2</B> and<B> file3</B> will be grouped into one physical segment.&nbsp; Code segments
from<B> file4</B> and<B> file5</B> will be grouped into another physical segment.
<P>Note that code segments extracted from library files will be grouped into physical segments as well.&nbsp; The size of
these physical segments is determined by the <A HREF="#PACKCODE_Option">PACKCODE</A> option and is 64k by default.

<H2 ID="NLMFLAGS_Option"> The NLMFLAGS Option </H2>
Formats:&nbsp; NetWare 
<P>The NLMFLAGS option is used to set bits in the flags field of the header of the Netware executable file.&nbsp;
The format of the NLMFLAGS option ( short form NLMF ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NLMFLAGS=some_value</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>some_value
<DD>is an integer value that is OR'ed into the flags field of the header of the Netware executable.
</DL>

<H2 ID="NOAUTODATA_Option"> The NOAUTODATA Option </H2>
Formats:&nbsp; OS/2, Win16 
<P>The NOAUTODATA option specifies that no automatic data segment (default data segment defined by the group &quot;DGROUP&quot;),
exists for the program module or Dynamic Link Library being created.&nbsp; This option applies to 16-bit applications only.
&nbsp;The format of the NOAUTODATA option ( short form NOA ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NOAUTODATA</TT>

<H2 ID="NODEFAULTLIBS_Option"> The NODEFAULTLIBS Option </H2>
Formats:&nbsp; All 
<P>Special object module records that specify default libraries are placed in object files generated by Open Watcom compilers.
&nbsp;These libraries reflect the memory and floating-point model that a source file was compiled for and are automatically
searched by JWlink when unresolved symbols are detected.&nbsp; These libraries can exist in the current directory,
in one of the paths specified in <A HREF="#LIBPATH_Directive">LIBPATH</A> directives, or in one of the paths specified in the <B>LIB</B> environment
variable.
<P>Note that all library files that appear in a <A HREF="#LIBRARY_Directive">LIBRARY</A> directive are searched before default libraries.&nbsp;
The NODEFAULTLIBS option instructs JWlink to ignore default libraries.&nbsp; That is, only libraries
appearing in a <A HREF="#LIBRARY_Directive">LIBRARY</A> directive are searched.
<P>The format of the NODEFAULTLIBS option ( short form NOD ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NODEFAULTLIBS</TT>

<H2 ID="NOEXTENSION_Option"> The NOEXTENSION Option </H2>
Formats:&nbsp; All 
<P>The NOEXTENSION option suppresses automatic addition of an extension to the name of the executable file generated
by JWlink.&nbsp; This affects both names specified explicitly through the <A HREF="#NAME_Directive">NAME</A> directive as well as
default names chosen in the absence of a <A HREF="#NAME_Directive">NAME</A> directive.
<P>The format of the NOEXTENSION option ( short form NOEXT ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NOEXTENSION</TT>

<H2 ID="NOINDIRECT_Option"> The NOINDIRECT Option </H2>
Formats:&nbsp; DOS 
<P>The NOINDIRECT option suppresses the generation of overlay vectors for symbols that are referenced indirectly
(their address is taken) when the module containing the symbol is not an ancestor of at least one module that indirectly references
the symbol.&nbsp; This can greatly reduce the number of overlay vectors and is a safe optimization provided there are no indirect
calls to these symbols.&nbsp; If, for example, the set of symbols that are called indirectly is known, you can use the &quot;VECTOR&quot;
option to force overlay vectors for these symbols.
<P>The format of the NOINDIRECT option ( short form NOI ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NOINDIRECT</TT>
<P>For more information on overlays, see the section entitled <A HREF="#DOS__Using_Overlays">DOS:&nbsp; Using Overlays</A>.

<H2 ID="NOLARGEADDRESSAWARE_Option"> The NOLARGEADDRESSAWARE Option </H2>
Formats:&nbsp; Win32/Win64 
<P>The NOLARGEADDRESSAWARE option ( short form NOLARGE ) is used with PE format executables. This option will make
JWlink set a flag in the PE header telling the OS that this application cannot handle an address space of more
than 2 GB. For Win32 binaries, this is the default setting, hence this option will have an effect for Win64 binaries only.
<P>The format of the NOLARGEADDRESSAWARE option is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NOLARGEADDRESSAWARE</TT>

<H2 ID="NORELOCS_Option"> The NORELOCS Option </H2>
Formats:&nbsp; QNX, Win32/Win64 
<P>The NORELOCS option ( short form NOR ) specifies that no relocation information is to be written to the executable file.&nbsp;
<P>The format of this option is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NORELOCS</TT>

<P>QNX only: when the NORELOCS option is specified, the executable file can only be run in protected mode and will not run
in real mode.&nbsp; In real mode, the relocation information is required; in protected mode, the relocation information is
not required unless your application is running at privilege level 0.

<H2 ID="NOSTDCALL_Option"> The NOSTDCALL Option </H2>
Formats:&nbsp; Win32 
<P>The NOSTDCALL option specifies that the characters unique to the<B><I> __stdcall</I></B> calling convention
be trimmed from all of the symbols that are exported from the DLL being created.&nbsp; The format of the NOSTDCALL
option ( short form NOSTDC ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NOSTDCALL</TT>
<P>Considering the following declarations.
<P><B>Example:</B>
<P><PRE>
     short PASCAL __export Function1( short var1,
                                      long varlong,
                                      short var2 );
     short PASCAL __export Function2( long varlong,
                                      short var2 )
</PRE>
<P>Under ordinary circumstances, these<B><I> __stdcall</I></B> symbols are mapped to &quot;_Function1@12&quot; and &quot;_Function2@8&quot;
respectively.&nbsp; The &quot;@12&quot; and &quot;@8&quot; reflect the number of bytes in the argument list (short is passed
as int).&nbsp; When the NOSTDCALL option is specified, these symbols are stripped of the &quot;_&quot; and &quot;@xx&quot;
adornments.&nbsp; Thus they are exported from the DLL as &quot;Function1&quot; and &quot;Function2&quot;.
<P>This option makes it easier to access functions exported from DLLs, especially when using other software languages such
as FORTRAN which do not add on the<B><I> __stdcall</I></B> adornments.
<HR>
<P><B><I>&nbsp; Note:</I></B>&nbsp; Use the <A HREF="#IMPLIB_Option">IMPLIB</A> option to create an import library for the DLL which can be
used with software languages that add on the<B><I> __stdcall</I></B> adornments.
<HR>

<H2 ID="NOSTUB_Option"> The NOSTUB Option </H2>
Formats:&nbsp; OS/2, Win16, Win32/Win64 
<P>The NOSTUB option specifies that no &quot;stub&quot; program is to be placed at the beginning of the executable
file being generated.&nbsp; The format of the NOSTUB option is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NOSTUB</TT>
<P>This option is helpful in cases when the executable file being generated cannot be directly executed by the user, such
as a device driver, and hence the stub program would be redundant.

<H2 ID="NOVECTOR_Directive"> The NOVECTOR Directive </H2>
Formats:&nbsp; DOS 
<P>The NOVECTOR directive forces JWlink to not generate an overlay vector for the specified symbols.
&nbsp;The format of the NOVECTOR directive ( short form NOV ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOVECTOR symbol_name{,symbol_name}</TT>
<P><DT>where &lt;symbol_name&gt; is a symbol name.
<P>The linker will create an overlay vector in the following cases.
<OL>
<P><LI>If a function in section A calls a function in section B and section B is not an ancestor of section A, an overlay
vector will be generated for the function in section B.&nbsp; See the section entitled <A HREF="#DOS__Using_Overlays">DOS:&nbsp; Using Overlays</A>
for a description of ancestor.
<P><LI>If a global symbol's address is referenced (except by a direct call) and that symbol is defined in an overlay section,
an overlay vector for that symbol will be generated.
</OL>
<P>Note that in the latter case, more overlay vectors may be generated that necessary.&nbsp; Suppose section A contains three
global functions,<B> f, g</B> and<B> h.</B>&nbsp; Function<B> f</B> passes the address of function<B> g</B> to function<B>
h</B> who can then calls function<B> g</B> indirectly.&nbsp; Also, suppose function<B> g</B> is only called from sections
that are ancestors of section A.&nbsp; The linker will generate an overlay vector for function<B> g</B> even though none is
required.&nbsp; In such a case, the &quot;NOVECTOR&quot; directive can be used to remove the overhead associated with calling
a function through an overlay vector.

<H2 ID="NXCOMPAT_Option"> The NXCOMPAT Option </H2>
Formats:&nbsp; Win32/Win64
<P>The NXCOMPAT option is used with PE format executables.&nbsp; A flag in the PE header is set
to tell the OS that the binary is compatible with data execution prevention (DEP).
<P>The format of the NXCOMPAT option ( short form NXC ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NXCOMPAT</TT>

<H2 ID="OBJALIGN_Option"> The OBJALIGN Option </H2>
Formats:&nbsp; ELF, OS/2 32-bit, Win32/Win64 
<P>The OBJALIGN option ( short form OBJA ) specifies the alignment for objects in memory.&nbsp;
The format of this option is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION OBJALIGN=n</TT>
<DL><DT>
<P>where &lt;n&gt; represents a numeric value.&nbsp; The complete form of &lt;n&gt; is
<P>
<DD><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>
<P>&lt;n&gt; must be a value that is a power of 2 and is between 16 bytes and 256 megabytes inclusive.
<P>
<P>The default value of &lt;n&gt; is 4k for PE, ELF and WinVxD, else it is 64k.
<P>For alignment of objects in the image file, see the <A HREF="#ALIGNMENT_Option">ALIGNMENT</A> Option.

<H2 ID="OLDLIBRARY_Option"> The OLDLIBRARY Option </H2>
Formats:&nbsp; OS/2, Win16, Win32/Win64 
<P>The OLDLIBRARY option is used to preserve the export ordinals for successive versions of a Dynamic Link Library.
&nbsp;This ensures that any application that references functions in a Dynamic Link Library by ordinal will continue to execute
correctly.&nbsp; The format of the OLDLIBRARY option ( short form OLD ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION OLDLIBRARY=dll_name</TT>
<P>where &lt;dll_name&gt; is a file specification for the name of a Dynamic Link Library.&nbsp; If no file extension is specified, a file extension
of &quot;DLL&quot; is assumed.

<P>Only the current directory or a specified directory will be searched for Dynamic Link Libraries specified in the OLDLIBRARY
option.

<H2 ID="OFFSET_Option"> The OFFSET Option </H2>
Formats:&nbsp; RAW, ELF, OS/2, PharLap, QNX, Win32/Win64

<OL>
<LI><A HREF="#OFFSET_M_RAW_only"> OFFSET - RAW only </A></LI>
<LI><A HREF="#OFFSET_M_OSD2__Win32__ELF_only"> OFFSET - OS/2, Win32/Win64, ELF only </A></LI>
<LI><A HREF="#OFFSET_M_PharLap_only"> OFFSET - PharLap only </A></LI>
<LI><A HREF="#OFFSET_M_QNX_only"> OFFSET - QNX only </A></LI>
</OL>

<H3 ID="OFFSET_M_RAW_only"> OFFSET - RAW only </H3>

<P>The OFFSET option specifies the linear base address of the raw output image.&nbsp;

<P>The format of the OFFSET option ( short form OFF ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION OFFSET=n</TT>
<DL>
<P><DT>where &lt;n&gt; is a numeric value.&nbsp; The complete form of &lt;n&gt; is the following.
<P><DD><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>

<P>&lt;n&gt; specifies the offset at which the output image will be located.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; option offset=0xc0000000</TT>
<P>The image will be virtually/physically located to the linear address 0xc0000000.

<H3 ID="OFFSET_M_OSD2__Win32__ELF_only"> OFFSET - OS/2, Win32/Win64, ELF only </H3>

<P>The OFFSET option specifies the preferred base linear address at which the executable or DLL will be loaded.

<P>The format of the OFFSET option ( short form OFF ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION OFFSET=n</TT>
<DL>
<P><DT>where &lt;n&gt; is a numeric value.&nbsp; The complete form of &lt;n&gt; is the following.
<P><DD><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>

The linker will round value &lt;n&gt; up to a multiple of 64K if it is not already a multiple of 64K.&nbsp; 
&nbsp;JWlink will relocate the application for the specified base linear address so that when it is loaded
by the operating system, no relocation will be required.&nbsp; This decreases the load time of the application.
<P>If the operating system is unable to load the application at the specified base linear address, it will load it at a different
location which will increase the load time since a relocation phase must be performed.&nbsp;

<P>The default base linear address is 0x10000 for OS/2 executables, 
0x400000 for Win32/Win64 applications and 0x10000000 for Win32/Win64 DLLs.&nbsp; 
For ELF, the default base address depends on the CPU architecture.
<P>This option is most useful for improving the load time of DLLs, especially for an application that uses multiple DLLs.

<H3 ID="OFFSET_M_PharLap_only"> OFFSET - PharLap only </H3>
<P>The OFFSET option specifies the offset in the program's segment in which the first byte of code or data is
loaded.&nbsp;

<P>The format of the OFFSET option ( short form OFF ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION OFFSET=n</TT>
<DL>
<P><DT>where &lt;n&gt; is a numeric value.&nbsp; The complete form of &lt;n&gt; is the following.
<P><DD><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>

<P>&lt;n&gt; specifies the offset (in bytes) at which the program is loaded and must be a multiple of 4K.&nbsp; JWlink
will round the value up to a multiple of 4K if it is not already a multiple of 4K.
<P>It is possible to detect NULL pointer references by linking the program at an offset which is a multiple of 4K.&nbsp; Usually
an offset of 4K is sufficient.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; option offset=4k</TT>
<P>When the program is loaded by 386|DOS-Extender, the pages skipped by the OFFSET option are not mapped.&nbsp;
Any reference to an unmapped area (such as a NULL pointer) will cause a page fault preventing the NULL reference from corrupting
the program.

<H3 ID="OFFSET_M_QNX_only"> OFFSET - QNX only </H3>
<P>The OFFSET option specifies the offset in the program's segment in which the first byte of code or data is
loaded.&nbsp; This option does not apply to 16-bit QNX applications.&nbsp;
<P>The format of the OFFSET option ( short form OFF ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION OFFSET=n</TT>
<DL>
<P><DT>where &lt;n&gt; is a numeric value.&nbsp; The complete form of &lt;n&gt; is the following.
<P><DD><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>
<P>&lt;n&gt; specifies the offset (in bytes) at which the program is loaded and must be a multiple of 4K.&nbsp; JWlink
will round the value up to a multiple of 4K if it is not already a multiple of 4K.&nbsp; The following describes a
use of the OFFSET option.
<P>It is possible to detect NULL pointer references by linking the program at an offset which is a multiple of 4K.&nbsp; Usually
an offset of 4K is sufficient.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; option offset=4k</TT>
<P>When the program is loaded, the pages skipped by the OFFSET option are not mapped.&nbsp; Any reference to an
unmapped area (such as a NULL pointer) will cause a page fault preventing the NULL reference from corrupting the program.

<H2 ID="ONEAUTODATA_Option"> The ONEAUTODATA Option </H2>
Formats:&nbsp; OS/2, Win16 
<P>The ONEAUTODATA option specifies that the automatic data segment (default data segment defined by the group
&quot;DGROUP&quot;), for the program module or Dynamic Link Library (DLL) being created, will be shared by all instances.
&nbsp;The format of the ONEAUTODATA option ( short form ONE ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION ONEAUTODATA</TT>
<P>The default for a Dynamic Link Library is ONEAUTODATA and for a program module is <A HREF="#MANYAUTODATA_Option">MANYAUTODATA</A>.
&nbsp;If you do not want the data area of a DLL to be shared across multiple applications, then you should specify 
<A HREF="#MANYAUTODATA_Option">OPTION MANYAUTODATA</A>.
<DL>
<P><DT>Win16:
<DD>Note, however, that this attribute is not supported by Windows 3.x for 16-bit DLLs.
</DL>
<P>See the <A HREF="#FORMAT_Directive">FORMAT</A> directive for more information
on the INITINSTANCE, TERMINSTANCE, INITGLOBAL and TERMGLOBAL DLL attributes.

<H2 ID="OPTION_Directive"> The OPTION Directive </H2>
Formats:&nbsp; All 
<P>The OPTION directive ( short form OP ) is used to specify options to JWlink.&nbsp; 
The format of this directive is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION option{,option}</TT>
<P>where &lt;option&gt; is any of the linker options available for the executable format that is being generated.

<H2 ID="OPTLIB_Directive"> The OPTLIB Directive </H2>
Formats:&nbsp; All 
<P>The OPTLIB directive is used to specify the library files to be searched when unresolved symbols remain after
processing all specified input object files.&nbsp; The format of the OPTLIB directive (no short form) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTLIB library_file{,library_file}</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>library_file
<DD>is a file specification for the name of a library file.&nbsp; If no file extension is specified, a file extension of &quot;lib&quot;
is assumed.
</DL>
<P>This directive is similar to the <A HREF="#LIBRARY_Directive">LIBRARY</A> directive except that the linker will not issue a warning message
if the library file cannot be found.
<P>Consider the following example.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os file trig optlib \math\trig, \cmplx\trig</TT>
<P>JWlink is instructed to process the following object file:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; trig.obj</TT>
<P>If any unresolved symbol references remain after all object files have been processed, the following library files will
be searched:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; \math\trig.lib</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; \cmplx\trig.lib</TT>
<P>More than one OPTLIB directive may be used.&nbsp; The following example is equivalent to the preceding one.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os f trig optlib \math\trig optlib \cmplx\trig</TT>
<P>Thus other directives may be placed between lists of library files.
<H3 ID="Searching_for_Optional_Libraries_Specified_in_Environment_Variables"> Searching for Optional Libraries Specified in Environment Variables </H3>
<P>The &quot;LIB&quot; environment variable can be used to specify a list of paths that will be searched for library files.
&nbsp;The &quot;LIB&quot; environment variable can be set using the &quot;set&quot; command as follows:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; set lib=\graphics\lib;\utility</TT>
<P>Consider the following &quot;OPTLIB&quot; directive and the above definition of the &quot;LIB&quot; environment variable.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; optlib \mylibs\util, graph</TT>
<P>If undefined symbols remain after processing all object files specified in all &quot;FILE&quot; directives, JWlink
will resolve these references by searching the following libraries in the specified order.
<OL>
<LI>the library file &quot;\mylibs\util.lib&quot;
<LI>the library file &quot;graph.lib&quot; in the current directory
<LI>the library file &quot;\graphics\lib\graph.lib&quot;
<LI>the library file &quot;\utility\graph.lib&quot;
</OL>
<P><B>Notes:</B>
<OL>
<P><LI>If a library file specified in a &quot;OPTLIB&quot; directive contains an absolute path specification, JWlink
will not search any of the paths specified in the &quot;LIB&quot; environment string for the library file.&nbsp; On
UNIX platforms, an absolute path specification is one that begins the &quot;/&quot; character.&nbsp; On all other hosts, an
absolute path specification is one that begins with a drive specification or the &quot;\&quot; character.
<P><LI>Once a library file has been found, no further elements of the &quot;LIB&quot; environment variable are searched for
other libraries of the same name.&nbsp; That is, if the library file &quot;\graphics\lib\graph.lib&quot; exists, the library
file &quot;\utility\graph.lib&quot; will not be searched even though unresolved references may remain.
</OL>

<H2 ID="ORDER_Directive"> The ORDER Directive </H2>
Formats:&nbsp; All 
<P>The ORDER directive is used to specify the order in which classes are placed into the output image, and the
order in which segments are linked within a class.&nbsp; The directive can optionally also specify the starting address of
a class or segment, control whether the segment appears in the output image, and facilitate copying of data from one segment
to another.&nbsp; The ORDER Directive is primarily intended for embedded (ROMable) targets that do not run under
an operating system, or for other special purpose applications.&nbsp; The format of the ORDER directive ( short
form ORD ) is:
<P><PRE>
         ORDER {CLNAME class_name [class_options]}+

         class_options ::= [SEGADDR=n][OFFSET=n][copy_option][NOEMIT]{seglist}
         copy_option ::= [COPY source_class_name]
         seglist := {SEGMENT seg_name [SEGADDR=n][OFFSET=n][NOEMIT]}+
</PRE>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>n
<DD>represents a value.&nbsp; The complete form of<B> n</B> is the following.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; [0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
<P><DT>class_name
<DD>is the name of a class defined in one or more object files.&nbsp; If the class is not defined in an object file, the<B> class_name</B>
and all associated options are ignored.&nbsp; Note that the ORDER directive does<B> not</B> create classes or
segments.&nbsp; Classes specified with CLNAME keywords will be placed in the output image in the order listed.
&nbsp;Any classes that are not listed will be placed after the listed ones.
<P><DT>SEGADDR=n
<DD>(short form SEGA) specifies the segment portion of the starting address of the class or segment in the output
image.&nbsp; It is combined with OFFSET to represent a unique linear address.&nbsp; SEGADDR is only
valid for segmented formats.&nbsp; Its use in other contexts is undefined.&nbsp; The <A HREF="#HSHIFT_Option">HSHIFT</A> value affects how
the segment value is converted to a linear address.
<P><DT>OFFSET=n
<DD>(short form OFF) specifies the offset portion of the starting address of the class or segment in the output image.
&nbsp;It is combined with SEGADDR to represent a unique linear address.&nbsp; The OFFSET value is limited to a range of
0 to 65535 in segmented architectures, but can be a larger value for non-segmented architectures, up to the limits of the
architecture.
<P>When SEGADDR and/or OFFSET are specified, the location counter used to generate the executable
is advanced to that address.&nbsp; Any gaps are filled with the <A HREF="#FILLCHAR_Option">FILLCHAR</A> value, except for HEX output format,
in which case they are simply skipped.&nbsp; If the location counter is already beyond the specified location, an error message
is generated.&nbsp; This would likely be the result of having specified classes or segments in incorrect order, or not providing
enough room for preceding ones.&nbsp; Without the SEGADDR and OFFSET options, classes and segments
are placed in the executable consecutively, possibly with a small gap in between if required by the alignment specified for
the class.&nbsp; If SEGADDR is specified without corresponding OFFSET, the offset portion of the address
defaults to 0.
<P><DT>COPY
<DD>(short form CO) indicates that the data from the segment named<B> source_class_name</B> is to be used in this
segment.
<P><DT>NOEMIT
<DD>(short form NOE) indicates that the data in this segment should not be placed in the executable.
<P><DT>SEGMENT
<DD>indicates the order of segments within a class, and possibly other options associated with that segment.&nbsp; Segments listed
are placed in the executable in the order listed.&nbsp; They must be part of the class just named.&nbsp; Any segments in that
class not listed will follow the last listed segment.&nbsp; The segment options are a subset of the class options and conform
to the same specifications.
</DL>
<P>In ROM-based applications it is often necessary to:
<UL>
<P><LI>Fix the program location
<P><LI>Separate code and data to different fixed parts of memory
<P><LI>Place a copy of initialized data in ROM (usually right after the code)
<P><LI>Prevent the original of the initialized data from being written to the loadfile, since it resides in RAM and cannot
be saved there.
</UL>
<P>The ORDER directive caters for these requirements.&nbsp; Classes can be placed in the executable in a specific
order, with absolute addresses specified for one or more classes, and segments within a class can be forced into a specified
order with absolute addresses specified for one or more of them.&nbsp; Initialized data can be omitted at its target address,
and a copy included at a different address.
<P>Following is a sample ORDER directive for an embedded target (AM186ER).&nbsp; The bottom 32K of memory is RAM
for data.&nbsp; A DGROUP starting address of 0x80:0 is required.&nbsp; The upper portion of memory is FLASH ROM.&nbsp; Code
starts at address 0xD000:0.&nbsp; The initialized data from DGROUP is placed immediately after the code.
<P><PRE>

    order clname BEGDATA NOEMIT segaddr=0x80 segment _NULL segment _AFTERNULL
          clname DATA NOEMIT segment _DATA
          clname BSS
          clname STACK
          clname START segaddr=0xD000
          clname CODE segment BEGTEXT segment _TEXT
          clname ROMDATA COPY BEGDATA
          clname ROMDATAE
</PRE>
<P>DGROUP consists of classes &quot;BEGDATA&quot;, &quot;DATA&quot;, &quot;BSS&quot;, &quot;BSS2&quot; and &quot;STACK&quot;.
&nbsp;Note that these are marked &quot;NOEMIT&quot; (except for the BSS classes and STACK which are not initialized, and therefore
have no data in them anyway) to prevent data from being placed in the loadfile at 0x80:0.&nbsp; The first class of DGROUP
is given the fixed starting segment address of 0x80 (offset is assumed to be 0).&nbsp; The segments &quot;_NULL&quot;, &quot;_AFTERNULL&quot;
and &quot;_DATA&quot; will be allocated consecutively in that order, and because they are part of DGROUP, will all share the
same segment portio of the address, with offsets adjusted accordingly.
<P>The code section consists of classes &quot;START&quot; and &quot;CODE&quot;.&nbsp; These are placed beginning at 0xD000:0.
&nbsp;&quot;START&quot; contains only one segment, which will be first.&nbsp; It will have a CS value of 0xD000.&nbsp; Code
has two segments, &quot;BEGTEXT&quot; and &quot;_TEXT&quot; which will be placed after &quot;START&quot;, in that order, and
packed into a single CS value of their own (perhaps 0xD001 in this example), unless they exceed 64K in size, which should
not be the case if the program was compiled using the small memory model.
<P>The classes &quot;ROMDATA&quot; and &quot;ROMDATAE&quot; were created in assembly with one segment each and no symbols
or data in them.&nbsp; The class names can be used to identify the beginning and end of initialized data so it can be copied
to RAM by the startup code.
<P>The &quot;COPY&quot; option actually works at the group level, because that is the way it is generally needed.&nbsp; The
entire data is in DGROUP.&nbsp; &quot;ROMDATA&quot; will be placed in a group of its own called &quot;AUTO&quot;.&nbsp; (Note:
&nbsp;each group mentioned in the map file under the name &quot;AUTO&quot; is a separate group.&nbsp; They are not combined
or otherwise related in any way, other than they weren't explicitly created by the programmer, compiler or assembler, but
rather automatically created by the linker in the course of its work.) Therefore there is a unique group associated with this
class.&nbsp; The &quot;COPY&quot; option finds the group associated with &quot;BEGDATA&quot; and copies all the object data
from there to &quot;ROMDATA&quot;.&nbsp; Specifically, it places a copy of this data in the executable at the location assigned
to &quot;ROMDATA&quot;, and adjusts the length of &quot;ROMDATA&quot; to account for this.&nbsp; All symbol references to
this data are to its execution address (0x80:0), not where it ended up in the executable (for instance 0xD597:0).&nbsp; The
starting address of &quot;ROMDATAE&quot; is also adjusted to account for the data assigned to &quot;ROMDATA&quot;.&nbsp; That
way, the program can use the symbol &quot;ROMDATAE&quot; to identify the end of the copy of DGROUP.&nbsp; It is also necessary
in case more than one &quot;COPY&quot; class exists consecutively, or additional code or data need to follow it.

<P>It should also be noted that the <A HREF="#DOSSEG_Option">DOSSEG</A> option (whether explicitly given to the linker, or passed in an object
file) performs different class and segment ordering.&nbsp; If the ORDER directive is used, it overrides the <A HREF="#DOSSEG_Option">DOSSEG</A>
option, causing it to be ignored.

<H2 ID="OSDOMAIN_Option"> The OSDOMAIN Option </H2>
Formats:&nbsp; NetWare 
<P>The OSDOMAIN option is used when the application is to run in the operating system domain (ring 0).
<P>The format of the OSDOMAIN option ( short form OSD ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION OSDOMAIN</TT>

<H2 ID="OSNAME_Option"> The OSNAME Option </H2>
Formats:&nbsp; All 
<P>The OSNAME option can be used to set the name of the target operating system of the executable file generated
by the linker.&nbsp; The format of the OSNAME option ( short form OSN ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION OSNAME='string'</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>string
<DD>is any sequence of characters.
</DL>
<P>The information specified by the OSNAME option will be displayed in the<B> creating a ?&nbsp; executable</B>
message.&nbsp; This is the last line of output produced by the linker, provided the <A HREF="#QUIET_Option">QUIET</A> option is not specified.
&nbsp;Consider the following example.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; option osname='SuperOS'</TT>
<P>The last line of output produced by the linker will be as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; creating a SuperOS executable</TT>
<P>Some executable formats have a stub executable file that is run under 16-bit DOS.&nbsp; The message displayed by the default
stub executable file will be modified when the OSNAME option is used.&nbsp; The default stub executable displays
the following message:
<DL>
<P><DT>OS/2:
<DD><TT> this is an OS/2 executable</TT>
<P><DT>Win16:
<DD><TT> this is a Windows executable</TT>
<P><DT>Win32/Win64:
<DD><TT> this is a Windows NT executable</TT>
</DL>
<P>If the OSNAME option used in the previous example was specified, the default stub executable would generate
the following message.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; this is a SuperOS executable</TT>

<H2 ID="OSVERSION_Option"> The OSVERSION Option </H2>
Formats:&nbsp; Win32/Win64 
<P>The OSVERSION option specifies that the linker should apply the given major and minor version numbers to the
PE format image header.&nbsp; This specifies the major and minor versions of the operating system required to load this image.
&nbsp;If a version number is not specified, then the built-in value of 1.11 is used.&nbsp; The format of the OSVERSION
option ( short form OSV ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION OSVERSION = major[.minor]</TT>

<H2 ID="OUTPUT_Directive"> The OUTPUT Directive </H2>
Formats:&nbsp; All 
<P>The OUTPUT directive overrides the normal operating system specific executable format and creates either a
raw binary image or an Intel Hex file.&nbsp; The format of the OUTPUT directive ( short form OUT ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUTPUT RAW|HEX [OFFSET=n][HSHIFT=n][STARTREC]</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>n
<DD>represents a value.&nbsp; The complete form of<B> n</B> is the following.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; [0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
<P><DT>RAW
<DD>specifies the output file to be a raw binary and will contain an absolute image of the executable's code and data.&nbsp; Default
file extension is &quot;bin&quot;.
<P><DT>HEX
<DD>specifies the output file to contain a representation of the absolute image of the code and data using the Intel standard
hex file format.&nbsp; Default file extension is &quot;hex&quot;.
<P><DT>OFFSET=n
<DD>(short form &quot;OFF&quot;) specifies that linear addresses below<B> n</B> should be skipped when outputting the executable
image.&nbsp; This option does not affect address calculations and is intended to avoid unwanted padding when writing executable
images that do not start at linear address zero.
<P><DT>HSHIFT
<DD>defines the relationship between segment values for type 02 records and linear addresses.&nbsp; The value<B> n</B> is the
number of digits to right shift a 32-bit value containing a segment address in its upper 16 bits in order to convert it to
part of a linear address.&nbsp; In more conventional terms, (16 -<B> n</B> ) is the amount to shift a segment value left in
order to convert it to part of a linear address.
<P><DT>STARTREC
<DD>(short form &quot;ST&quot;) specifies that a Starting Address record will be included in Intel Hex output.&nbsp; This option
is ignored if output type is not Intel hex.
</DL>
<P>For raw binary files, the position in the file is the linear address after the offset is subtracted from it.&nbsp; Any
gaps filled with the value specified through <A HREF="#FILLCHAR_Option">OPTION FILLCHAR</A> (default is 0).
<P>For hex files, the linear address (after subtracting the offset) is used to determine the output record generated.&nbsp;
Records contain 16 bytes, unless a gap occurs prior to that in which case the record is shorter, and a new record starts after
the gap.&nbsp; There are three types of Intel Hex records.&nbsp; The oldest and most widely used is HEX80, which can only
deal with 16-bit addresses.&nbsp; For many ROM-based applications, this is enough, especially once an offset has been subtracted.
&nbsp;For maximum versatility, all addresses less than 65536 are generated in this form.
<P>The HEX86 standard creates a segmentation that mirrors the CPU segmentation.&nbsp; Type 02 records define the segment,
and all subsequent addresses are based on that segment value.&nbsp; For addresses above 64K, This form is used.&nbsp; A program
that understands HEX86 should assume the segment value is zero until an 02 record is encountered.&nbsp; This preserves backward
compatibility with HEX80, and allows the automatic selection algorithm used in JWlink to work properly.
<P>Type 02 records are assumed to have segment values that, when shifted left four bits, form a linear address.&nbsp; However,
this is not suitable for 24-bit segmented addressing schemes.&nbsp; Therefore, JWlink uses the value specified
through <A HREF="#HSHIFT_Option">OPTION HSHIFT</A> to determine the relationship between segments and offsets.&nbsp; This approach can work
with any 16:16 segmented architecture regardless of the segment alignment.&nbsp; The default shift value is 12, representing
the conventional 8086 architecture.&nbsp; This is not to be confused with the optional &quot;OUTPUT HSHIFT&quot; value discussed
below.
<P>Of course, PROM programmers or third-party tools probably were<B> not</B> designed to work with unconventional shift values,
hence for cases where code for a 24-bit (or other non-standard) target needs to be programmed into a PROM or processed by
a third-party tool, the &quot;OUTPUT HSHIFT&quot; option can be used to override the <A HREF="#HSHIFT_Option">OPTION HSHIFT</A> value.&nbsp;
This would usually be of the form &quot;OUTPUT HSHIFT=12&quot; to restore the industry standard setting.&nbsp; The default
for &quot;OUTPUT HSHIFT&quot; is to follow <A HREF="#HSHIFT_Option">OPTION HSHIFT</A>.&nbsp; When neither is specified, the default
<A HREF="#HSHIFT_Option">OPTION HSHIFT</A> value of 12 applies, providing industry standard compliance.
<P>If the address exceeds the range of type 02 records (1 MB for HSHIFT=12 and 16 MB for HSHIFT=8), type 04 extended linear
records are generated, again ensuring seamless compatibility and migration to large file sizes.
<P>If &quot;STARTREC&quot; is specified for &quot;OUTPUT HEX&quot;, the penultimate record in the file (just before the end
record) will be a start address record.&nbsp; The value of the start address will be determined by the module start record
in an object file, typically the result of an &quot;END start&quot; assembler directive.&nbsp; If the start address is less
than 65536 (always for 16-bit applications, and where applicable for 32-bit applications), a type 03 record with segment and
offset values will be emitted.&nbsp; If the start address is equal to or greater than 65536, then a type 05 linear starting
address record will be generated.&nbsp; Note that neither of these cases depends directly on the &quot;HSHIFT&quot; or &quot;OUTPUT
HSIFT&quot; settings.&nbsp; If HSHIFT=8, then the segment and offset values for the start symbol will be based on that number
and used accordingly, but unlike other address information in a hex file, this is not derived from a linear address and hence
not converted based on the HSHIFT value.

<H2 ID="OVERLAY_Directive"> The OVERLAY Directive </H2>
Formats:&nbsp; DOS 
<P>The OVERLAY directive allows you to specify the class of segments which are to be overlayed.&nbsp; The format
of the OVERLAY directive ( short form OV ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OVERLAY class{,class}</TT>

<P>where &lt;class&gt; is the class name of the segments to be overlayed.

<P>The <A HREF="#FILE_Directive">FILE</A> directive is used to specify the object files that belong to the overlay structure.&nbsp; Each object
file defines segments that contain code or data.&nbsp; Segments are assigned a class name by the compiler.&nbsp; A class is
essentially a collection of segments with common attributes.&nbsp; For example, compilers assign class names to segments so
that segments containing code belong to one class(es) and segments containing data belong to another class(es).&nbsp; When
an overlay structure is defined, only segments belonging to certain classes are allowed in the overlay structure.&nbsp; By
default, JWlink overlays all segments whose class name ends with &quot;CODE&quot;.&nbsp; These segments usually
contain the executable code for a program.
<P>It is also possible to overlay other classes.&nbsp; This is done using the OVERLAY directive.&nbsp; For example,
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; overlay code, far_data</TT>
<P>places all segments belonging to the classes &quot;CODE&quot; and &quot;FAR_DATA&quot; in the overlay structure.&nbsp;
Segments belonging to the class &quot;FAR_DATA&quot; contain only data.&nbsp; The above OVERLAY directive causes
code and data to be overlayed.&nbsp; Therefore, for any module that contains segments in both classes, data in segments with
class &quot;FAR_DATA&quot; will be in memory only when code in segments with class &quot;CODE&quot; are in memory.&nbsp; This
results in a more efficient use of memory.&nbsp; Of course the data must be referenced only by code in the overlay and it
must not be modified.
<HR>
<P><B><I>&nbsp; WARNING!</I></B>&nbsp; Care must be taken when overlaying data.&nbsp; If a routine modifies data in an overlayed
data segment, it should not assume it contains that value if it is invoked again.&nbsp; The data may have been overwritten
by another overlay.
<HR>
<B>Notes:</B>
<OL>
<P><LI>You should not specify a class in an OVERLAY directive that belongs to the group &quot;DGROUP&quot;.&nbsp;
These classes are &quot;BEGDATA&quot;, &quot;DATA&quot;, &quot;BSS&quot; and &quot;STACK&quot;.
</OL>
<P>If you are linking object files generated by a compiler that uses a class name that does not end with &quot;CODE&quot;
for segments containing executable code, the &quot;OVERLAY&quot; directive can be used to identify the classes that belong
to the overlay structure.&nbsp; Consider the following example.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; overlay code1, code2</TT>
<P>Any segment belonging to the class called &quot;CODE1&quot; or &quot;CODE2&quot; is placed in the overlay structure.&nbsp;
Segments belonging to a class whose name ends with &quot;CODE&quot; will no longer be placed in the overlay structure.

<H2 ID="PACKCODE_Option"> The PACKCODE Option </H2>
Formats:&nbsp; DOS, OS/2, QNX, Win16 
<P>This option is intended for 16-bit segmented applications.&nbsp; By default, JWlink automatically groups
logical code segments into physical segments.&nbsp; The PACKCODE option is used to specify the size of the physical
segment.&nbsp; The format of the PACKCODE option ( short form PACKC ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION PACKCODE=n</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>n
<DD>represents a value.&nbsp; The complete form of<B> n</B> is the following.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; [0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>
<P><B>n</B> specifies the size of the physical segments into which code segments are packed.&nbsp; The default value of<B>
n</B> is 64K for 16-bit applications.&nbsp; Note that this is also the maximum size of a physical segment.&nbsp; To suppress
automatic grouping of code segments, specify a value of 0 for<B> n.</B>
<P><B>Notes:</B>
<OL>
<LI>Only adjacent segments are packed into a physical segment.
<LI>Segments belonging to the same group are packed in a physical segment.&nbsp; Segments belonging to different groups
are not packed into a physical segment.
<LI>Segments with different attributes are not packed together unless they are explicitly grouped.
</OL>

<H2 ID="PACKDATA_Option"> The PACKDATA Option </H2>
Formats:&nbsp; DOS, OS/2, QNX, Win16 
<P>This option is intended for 16-bit segmented applications.&nbsp; By default, JWlink automatically groups
logical far data segments into physical segments.&nbsp; The PACKDATA option is used to specify the size of the
physical segment.&nbsp; The format of the PACKDATA option ( short form PACKD ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION PACKDATA=n</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>n
<DD>represents a value.&nbsp; The complete form of<B> n</B> is the following.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; [0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>
<P><B>n</B> specifies the size of the physical segments into which far data segments are packed.&nbsp; The default value of<B>
n</B> is 64K for 16-bit applications.&nbsp; Note that this is also the maximum size of a physical segment.&nbsp; To suppress
automatic grouping of far data segments, specify a value of 0 for<B> n.</B>
<P><B>Notes:</B>
<OL>
<LI>Only adjacent segments are packed into a physical segment.
<LI>Segments belonging to the same group are packed in a physical segment.&nbsp; Segments belonging to different groups
are not packed into a physical segment.
<LI>Segments with different attributes are not packed together unless they are explicitly grouped.
</OL>

<H2 ID="PATH_Directive"> The PATH Directive </H2>
Formats:&nbsp; All 
<P>The PATH directive is used to specify the directories that are to be searched for object files appearing in
subsequent <A HREF="#FILE_Directive">FILE</A> directives. When the PATH directive is specified, the current directory will
no longer be searched unless it appears in the PATH directive. The format of the PATH directive
( short form P ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATH path_name{;path_name}</TT>
<P>where &lt;path_name&gt; is a path name.

<P>Consider a directive file containing the following linker directives.
<P><PRE>
    path \math
    file sin
    path \stats
    file mean, variance
</PRE>
<P>It instructs JWlink to process the following object files:
<P><PRE>
    \math\sin.obj
    \stats\mean.obj
    \stats\variance.obj
</PRE>
<P>It is also possible to specify a list of paths in a PATH directive. Consider the following example.
<P><PRE>
    path \math;\stats
    file sin
</PRE>
<P>First, the linker will attempt to load the file &quot;\math\sin.obj&quot;. If unsuccessful, the linker will attempt
to load the file &quot;\stats\sin.obj&quot;.
<P>It is possible to override the path specified in a PATH directive by preceding the object file name in a <A HREF="#FILE_Directive">FILE</A>
directive with an absolute path specification. On UNIX platforms, an absolute path specification is one that begins
the &quot;/&quot; character. On all other hosts, an absolute path specification is one that begins with a drive specification
or the &quot;\&quot; character.
<P><PRE>
    path \math
    file sin
    path \stats
    file mean, \mydir\variance
</PRE>
<P>The above directive file instructs the linker to process the following object files:
<P><PRE>
    \math\sin.obj
    \stats\mean.obj
    \mydir\variance.obj
</PRE>

<H2 ID="PRIVILEGE_Option"> The PRIVILEGE Option </H2>
Formats:&nbsp; QNX 
<P>The PRIVILEGE option specifies the privilege level (0, 1, 2 or 3) at which the application will run.&nbsp;
The format of the PRIVILEGE option ( short form PRIV ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION PRIVILEGE=n</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>n
<DD>represents a value.&nbsp; The complete form of<B> n</B> is the following.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; [0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>
<P>The default privilege level is 0.

<H2 ID="PROTMODE_Option"> The PROTMODE Option </H2>
Formats:&nbsp; OS/2, Win16
<P>The PROTMODE option specifies that the application will only run in protected mode.&nbsp; This option applies
to 16-bit OS/2 or Windows applications only.&nbsp; The format of the PROTMODE option ( short form PROT ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION PROTMODE</TT>

<H2 ID="PSEUDOPREEMPTION_Option"> The PSEUDOPREEMPTION Option </H2>
Formats:&nbsp; NetWare 
<P>The PSEUDOPREEMPTION option specifies that an additional set of system calls will yield control to other processes.
&nbsp;Multitasking in current NetWare operating systems is non-preemptive.&nbsp; That is, a process must give up control in
order for other processes to execute.&nbsp; Using the PSEUDOPREEMPTION option increases the probability that all
processes are given an equal amount of CPU time.
<P>The format of the PSEUDOPREEMPTION option ( short form PS ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION PSEUDOPREEMPTION</TT>

<H2 ID="QUIET_Option"> The QUIET Option </H2>
Formats:&nbsp; All 
<P>The QUIET option tells JWlink to suppress all informational messages.&nbsp; Only warning, error
and fatal messages will be issued.&nbsp; By default, JWlink issues informational messages.&nbsp; The format
of the QUIET option ( short form Q ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION QUIET</TT>

<H2 ID="REDEFSOK_Option"> The REDEFSOK Option </H2>
Formats:&nbsp; All 
<P>The <b>REDEFSOK</b> option tells JWlink to accept redefined symbols and to generate an executable
file anyway.&nbsp; A warning message is displayed if a redefined symbol is detected.
<P>The format of this option ( short form RED ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION REDEFSOK</TT>
<P>The <b>NOREDEFSOK</b> option tells JWlink to reject redefined symbols (this is the default setting).&nbsp;
An error message is displayed if a redefined symbol is detected, and the executable file is not generated.
<P>The format of the NOREDEFSOK option ( short form NORED ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NOREDEFSOK</TT>

<H2 ID="REENTRANT_Option"> The REENTRANT Option </H2>
Formats:&nbsp; NetWare 
<P>The REENTRANT option specifies that the module is reentrant.&nbsp; That is, if an NLM is LOADed twice, the
actual code in the server's memory is reused.&nbsp; The NLM's start procedure is called once for each LOAD.&nbsp; The format
of the REENTRANT option ( short form RE ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION REENTRANT</TT>

<H2 ID="REFERENCE_Directive"> The REFERENCE Directive </H2>
Formats:&nbsp; All 
<P>The REFERENCE directive is used to explicitly reference a symbol that is not referenced by any object file
processed by the linker.&nbsp; If any symbol appearing in a REFERENCE directive is not resolved by the linker,
an error message will be issued for that symbol specifying that the symbol is undefined.
<P>The REFERENCE directive can be used to force object files from libraries to be linked with the application.
&nbsp;Also note that a symbol appearing in a REFERENCE directive will not be eliminated by dead code elimination.
&nbsp;For more information on dead code elimination, see the section entitled <A HREF="#ELIMINATE_Option">The ELIMINATE Option</A>.
<P>The format of the REFERENCE directive ( short form REF ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFERENCE symbol_name{, symbol_name}</TT>

<P><DT>where &lt;symbol_name&gt; is the symbol for which a reference is made.

<P>Consider the following example.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; reference domino</TT>
<P>The symbol<TT> domino</TT> will be searched for.&nbsp; The object module that defines this symbol will be linked with the
application.&nbsp; Note that the linker will also attempt to resolve symbols referenced by this module.

<H2 ID="RESOURCE_Directive"> The RESOURCE Directive </H2>
Formats:&nbsp; Win32/Win64 
<P>The RESOURCE directive is used to specify resource files to add to the executable file being generated.&nbsp;
The format of the RESOURCE directive ( short form RES ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RESOURCE resource_file{,resource_file}</TT>
<P>where &lt;resource_file&gt; is a file specification for the name of the resource file that to be added to the executable file.&nbsp; If no file extension
is specified, a file extension of &quot;res&quot; is assumed.

<H2 ID="RESOURCE_Option"> The RESOURCE Option </H2>
Formats:&nbsp; OS/2, QNX, Win16, Win32/Win64 
<P>For <A HREF="#RESOURCE_M_OSD2__Win16__Win32_only">16-bit OS/2, Win16 or Win32/Win64</A> executable files, the RESOURCE option requests the linker
to add the specified resource file to the executable file being generated.&nbsp; 
<P>For <A HREF="#RESOURCE_M_QNX_only">QNX</A> executable files, the RESOURCE
option specifies the contents of the resource record.

<H3 ID="RESOURCE_M_OSD2__Win16__Win32_only"> RESOURCE - OS/2, Win16, Win32/Win64 only </H3>
<P>The RESOURCE option requests the linker to add the specified resource file to the executable file that is being
generated.&nbsp; The format of the RESOURCE option ( short form RES ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION RESOURCE[=resource_file]</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>resource_file
<DD>is a file specification for the name of the resource file that is to be added to the executable file.&nbsp; If no file extension
is specified, a file extension of &quot;RES&quot; is assumed for all but QNX format executables.
</DL>
<P>The RESOURCE option cannot be used for 32-bit OS/2 executables.

<H3 ID="RESOURCE_M_QNX_only"> RESOURCE - QNX only </H3>
<P>The RESOURCE option specifies the contents of the resource record in QNX executable files.&nbsp; The format
of the RESOURCE option ( short form RES ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION RESOURCE resource_info</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resource_info ::= 'string' | =resource_file</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>resource_file
<DD>is a file specification for the name of the resource file.&nbsp; No file extension is assumed.
<P><DT>string
<DD>is a sequence of characters which is placed in the resource record.
</DL>
<P>If a resource file is specified, the contents of the resource file are included in the resource record.
<P>The resource record contains, for example, help information and is displayed when the following command is executed.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; use &lt;executable&gt;</TT>
<P>QNX also provides the<B> usemsg</B> utility to manipulate the resource record of an executable file.&nbsp; Its use is recommended.
&nbsp;This utility is described in the QNX &quot;Utilities Reference&quot; manual.

<H2 ID="RUNTIME_Directive"> The RUNTIME Directive </H2>
Formats:&nbsp; ELF, PharLap, Win32/Win64
<OL>
<LI>For <A HREF="#RUNTIME_M_Win32_only">Win32/Win64</A> applications, the RUNTIME directive specifies the environment under which the application will run.
<LI>For <A HREF="#RUNTIME_M_PharLap_only">PharLap</A> applications, the RUNTIME directive describes information that is used by 386|DOS-Extender to setup
the environment for execution of the program.
<LI>For <A HREF="#RUNTIME_M_ELF_only">ELF</A> applications, the RUNTIME directive specifes ABI type and version under which the application will
run.
</OL>

<H3 ID="RUNTIME_M_Win32_only"> RUNTIME - Win32/Win64 only </H3>
<P>The RUNTIME directive specifies the environment under which the application will run.&nbsp; The format of the
RUNTIME directive ( short form RU ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUNTIME&nbsp; env[=major[.minor]]</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env ::= NATIVE | WINDOWS | CONSOLE | POSIX | OS2 | DOSSTYLE</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>env=major.minor
<DD>Specifying a system version in the form &quot;major&quot; or &quot;major.minor&quot; indicates the minimum operating system
version required for the application.&nbsp; For example, the following indicates that the application requires Windows 95.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; runtime windows=4.0</TT>
<P><DT>NATIVE
<DD>(short form NAT) indicates that the application is a native Windows NT application.
<P><DT>WINDOWS
<DD>(short form WIN) indicates that the application is a Windows application.
<P><DT>CONSOLE
<DD>(short form CON) indicates that the application is a character-mode (command line oriented) application.
<P><DT>POSIX
<DD>(short form POS) indicates that the application uses the POSIX subsystem available with Windows NT.
<P><DT>OS2
<DD>indicates that the application is a 16-bit OS/2 1.x application.
<P><DT>DOSSTYLE
<DD>(short form DOS) indicates that the application is a Phar Lap TNT DOS extender application that uses INT 21 to
communicate to the DOS extender rather than calls to a DLL.
</DL>

<H3 ID="RUNTIME_M_PharLap_only"> RUNTIME - PharLap only </H3>
The RUNTIME directive describes information that is used by 386|DOS-Extender to setup the environment for execution
of the program.&nbsp; The format of the RUNTIME directive ( short form RU ) is:
<PRE>
         RUNTIME run_option{,run_option}
         run_option ::= MINREAL=n | MAXREAL=n | CALLBUFS=n | MINIBuf=n
                      | MAXIBUF=n | NISTACK=n | ISTKSIZE=n
                      | REALBREAK=offset | PRIVILEGED | UNPRIVILEGED
         offset ::= n | symbol_name
</PRE>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>n
<DD>represents a value.&nbsp; The complete form of<B> n</B> is the following.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; [0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
<P><DT>symbol_name
<DD>is a symbol name.
<P><DT>MINREAL
<DD>(short form MINR) specifies the minimum number of bytes of conventional memory required to be free after a program
is loaded by 386|DOS-Extender.&nbsp; Note that this memory is no longer available to the executing program.&nbsp; The default
value of<B> n</B> is 0 in which case 386|DOS-Extender allocates all conventional memory for the executing program.&nbsp; The
JWlink truncates the specified value to a multiple of 16.<B>&nbsp; n</B> must be less than or equal to hexadecimal
100000 (64K*16).
<P><DT>MAXREAL
<DD>(short form MAXR) specifies the maximum number of bytes of conventional memory than can be left free after a program
is loaded by 386|DOS-Extender.&nbsp; Note that this memory is not available to the executing program.&nbsp; The default value
of<B> n</B> is 0 in which case 386|DOS-Extender allocates all conventional memory for the executing program.<B>&nbsp; n</B>
must be less than or equal to hexadecimal ffff0.&nbsp; JWlink truncates the specified value to a multiple
of 16.
<P><DT>CALLBUFS
<DD>(short form CALLB) specifies the size of the call buffer allocated for switching between 32-bit protected mode
and real mode.&nbsp; This buffer is used for communicating information between real-mode and 32-bit protected-mode procedures.
&nbsp;The buffer address is obtained at run-time with a 386|DOS-Extender system call.&nbsp; The size returned is the size
of the buffer in kilobytes and is less than or equal to 64.
<P>The default buffer size is zero unless changed using the &quot;CALLBUFS&quot; option.&nbsp; JWlink truncates
the specified value to a multiple of 1024.<B>&nbsp; n</B> must be less than or equal to 64K.&nbsp; Note that<B> n</B> is the
number of bytes, not kilobytes.
<P><DT>MINIBUF
<DD>(short form MINIB) specifies the minimum size of the data buffer that is used when DOS and BIOS functions are
called.&nbsp; The size of this buffer is particularly important for file I/O.&nbsp; If your program reads or writes large
amounts of data, a large value of<B> n</B> should be specified.<B>&nbsp; n</B> represents the number of bytes and must be
less than or equal to 64K.&nbsp; The default value of<B> n</B> is 1K.&nbsp; JWlink truncates the specified
value to a multiple of 1024.
<P><DT>MAXIBUF
<DD>(short form MAXIB) specifies the maximum size of the data buffer that is used when DOS and BIOS functions are
called.&nbsp; The size of this buffer is particularly important for file I/O.&nbsp; If your program reads or writes large
amounts of data, a large value of<B> n</B> should be specified.<B>&nbsp; n</B> represents the number of bytes and must be
less than or equal to 64K.&nbsp; The default value of<B> n</B> is 4K.&nbsp; JWlink truncates the specified
value to a multiple of 1024.
<P><DT>NISTACK
<DD>(short form NIST) specifies the number of stack buffers to be allocated for use by 386|DOS-Extender when switching
from 32-bit protected mode to real mode.&nbsp; By default, 4 stack buffers are allocated.<B>&nbsp; n</B> must be greater than
or equal to 4.
<P><DT>ISTKSIZE
<DD>(short form ISTK) specifies the size of the stack buffers allocated for use by 386|DOS-Extender when switching
from 32-bit protected mode to real mode.&nbsp; By default, the size of a stack buffer is 1K.&nbsp; The value of<B> n</B> must
be greater than or equal to 1K and less than or equal to 64K.&nbsp; JWlink truncates the specified value to
a multiple of 1024.
<P><DT>REALBREAK
<DD>(short form REALB) specifies how much of the program must be loaded into conventional memory so that it can be
accessed and/or executed in real mode.&nbsp; If<B> n</B> is specified, the first<B> n</B> bytes of the program must be loaded
into conventional memory.&nbsp; If<B> symbol</B> is specified, all bytes up to but not including the symbol must be loaded
into conventional memory.
<P><DT>PRIVILEGED
<DD>(short form PRIV) specifies that the executable is to run at Ring 0 privilege level.
<P><DT>UNPRIVILEGED
<DD>(short form UNPRIV) specifies that the executable is to run at Ring 3 privilege level (i.e., unprivileged).&nbsp;
This is the default privilege level.
</DL>

<H3 ID="RUNTIME_M_ELF_only"> RUNTIME - ELF only </H3>
The RUNTIME directive specifies the Application Binary Interface (ABI) type and version under which the application
will run.&nbsp; The format of the RUNTIME directive ( short form RU ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUNTIME&nbsp; ABIVER[=abinum.abiversion] | abispec</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abispec ::= abiname[=abiversion]</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abiname ::= SVR4 | LINUX | FREEBSD | NETBSD | SOLARIS</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>abi=abinum.abiversion
<DD>Specifying ABI/OS type and optional version indicates specific ABI that an ELF application is written for.&nbsp; This information
may affect how the ELF executable will be interpreted by the operating system.&nbsp; If ABI version is not specified, zero
will be used.&nbsp; A list of official ABI types may be found in the System V Application Binary Interface specification.
<P>For example, both of the following example indicate that the application requires Linux, but does not specify ABI version
(numeric value zero).
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; runtime linux</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; runtime abiver=3.0</TT>
<P><DT>SVR4
<DD>indicates that the application is a generic ELF application conforming to the System V Release 4 ABI.&nbsp; This is the default.
<P><DT>LINUX
<DD>(short form &quot;LIN&quot;) indicates that the application is a Linux application.
<P><DT>FREEBSD
<DD>(short form &quot;FRE&quot;) indicates that the application is a FreeBSD application.
<P><DT>NETBSD
<DD>(short form &quot;NET&quot;) indicates that the application is a NetBSD application.
<P><DT>SOLARIS
<DD>(short form &quot;SOL&quot;) indicates that the application is a Sun Solaris application.
<P><DT>ABIVER
<DD>(short form &quot;ABI&quot;) specifies the numeric ABI type and optionally version.&nbsp; This method allows specification
of ABI types not explicitly supported by JWlink.
</DL>

<H2 ID="RWRELOCCHECK_Option"> The RWRELOCCHECK Option </H2>
Formats:&nbsp; Win16 
<P>The RWRELOCCHECK option causes the linker to check for segment relocations to a read/write data segment and
issue a warning if any are found.&nbsp; This option is useful if you are building a 16-bit Windows application that may have
more than one instance running at a given time.
<P>The format of the RWRELOCCHECK option ( short form RWR ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION RWRELOCCHECK</TT>

<H2 ID="SCREENNAME_Option"> The SCREENNAME Option </H2>
Formats:&nbsp; NetWare 
<P>The &quot;SCREENNAME&quot; option specifies the name of the first screen (the screen that is automatically created when
an NLM is loaded).&nbsp; The format of the &quot;SCREENNAME&quot; option (short form &quot;SCR&quot;) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION SCREENNAME 'name'</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>name
<DD>specifies the screen name.
</DL>
<P>If the &quot;SCREENNAME&quot; option is not specified, the<B> description</B> text specified in the &quot;FORMAT&quot;
directive is used as the screen name.

<H2 ID="SECTION_Directive"> The SECTION Directive </H2>
Formats:&nbsp; DOS 
<P>The SECTION directive is used to define the start of an overlay.&nbsp; All object files in subsequent 
<A HREF="#FILE_Directive">FILE</A> directives, up to the next SECTION or <A HREF="#END_Directive">END</A> directive, belong to that overlay.&nbsp; The format of the
SECTION directive ( short form S ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECTION [INTO ovl_file]</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>INTO
<DD>specifies that the overlay is to be placed into a separate file, namely<B> ovl_file.</B>&nbsp; If &quot;INTO&quot; (short
form &quot;IN&quot;) is not specified, the overlay is placed in the executable file.&nbsp; Note that more than one overlay
can be placed in the same file by specifying the same file name in multiple SECTION directives.
<P><DT>ovl_file
<DD>is the file specification for the name of an overlay file.&nbsp; If no file extension is specified, a file extension of &quot;ovl&quot;
is assumed.
</DL>
<P>Placing overlays in separate files has a number of advantages.&nbsp; For example, if your application was linked into one
file, it may not fit on a single diskette, making distribution of your application difficult.
<P>
<HR>
Note: in COFF, PE or ELF documentation, a <i>section</i> is usually what is called a segment
in this document. Hence, to set <i>section</i> attributes in PE or ELF binaries, use the <A HREF="#SEGMENT_Directive">SEGMENT</A> directive.
<HR>

<H2 ID="SEGMENT_Directive"> The SEGMENT Directive </H2>
Formats:&nbsp; OS/2, QNX, Win16, Win32/Win64 
<P>The SEGMENT directive is used to set attributes of code and data segments.&nbsp; The format of the
SEGMENT directive ( short form SEG ) is:
<PRE>
         SEGMENT seg_desc{,seg_desc}
         seg_desc ::= seg_id {seg_attrs}
         seg_id ::= 'seg_name' | CLASS 'class_name' | TYPE [CODE | DATA]
     <i>OS/2</i>:
         seg_attrs ::= PRELOAD | LOADONCALL
                     | IOPL | NOIOPL
                     | EXECUTEONLY | EXECUTEREAD
                     | READONLY | READWRITE
                     | SHARED | NONSHARED
                     | CONFORMING | NONCONFORMING
                     | PERMANENT | NONPERMANENT
                     | INVALID | RESIDENT
                     | CONTIGUOUS | DYNAMIC
     <i>Win32/Win64</i>:
         seg_attrs ::= PAGEABLE | NONPAGEABLE
                     | SHARED | NONSHARED
                     | EXECUTABLE | WRITABLE
                     | READONLY
     <i>Win16</i>:
         seg_attrs ::= PRELOAD | LOADONCALL
                     | EXECUTEONLY | EXECUTEREAD
                     | READONLY | READWRITE
                     | SHARED | NONSHARED
                     | MOVEABLE | FIXED
                     | DISCARDABLE
     <i>VxD</i>:
         seg_attrs ::= PRELOAD | LOADONCALL
                     | IOPL | NOIOPL
                     | SHARED | NONSHARED
                     | DISCARDABLE | NONDISCARDABLE
                     | CONFORMING | NONCONFORMING
                     | RESIDENT
     <i>QNX</i>:
         seg_attrs ::= EXECUTEONLY | EXECUTEREAD
                     | READONLY | READWRITE
</PRE>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>seg_name
<DD>is the name of the code or data segment whose attributes are being specified.
<P><DT>class_name
<DD>is a class name.&nbsp; The attributes will be assigned to all segments belonging to the specified class.
<P><DT>PRELOAD
<DD>(short form PR, OS/2, VxD and Win16 only) specifies that the segment is loaded as soon as the executable file
is loaded.
<P><DT>LOADONCALL
<DD>(short form LO, OS/2, VxD and Win16 only) specifies that the segment is loaded only when accessed. This is the default.
<P><DT>PAGEABLE
<DD>(short form PAGE, Win32/Win64 only) specifies that the segment can be paged from memory.&nbsp; This is the default.
<P><DT>NONPAGEABLE
<DD>(short form NONP, Win32/Win64 only) specifies that the segment, once loaded into memory, must remain in memory.
<P><DT>CONFORMING
<DD>(short form CON, OS/2 and VxD only) specifies that the segment will assume the I/O privilege of the segment that
referenced it.&nbsp; By default, the segment is &quot;NONCONFORMING&quot;.
<P><DT>NONCONFORMING
<DD>(short form NONC, OS/2 and VxD only) specifies that the segment will not assume the I/O privilege of the segment
that referenced it.&nbsp; This is the default.
<P><DT>IOPL
<DD>(short form I, OS/2 and VxD only) specifies that the segment requires I/O privilege.&nbsp; That is, they can access
the hardware directly.
<P><DT>NOIOPL
<DD>(short form NOI, OS/2 and VxD only) specifies that the segment does not require I/O privilege.&nbsp; This is the default.
<P><DT>PERMANENT
<DD>(short form PERM, OS/2 32-bit only) specifies that the segment is permanent.
<P><DT>NONPERMANENT
<DD>(short form NONPERM, OS/2 32-bit only) specifies that the segment is not permanent.
<P><DT>INVALID
<DD>(short form INV, OS/2 32-bit only) specifies that the segment is invalid.
<P><DT>RESIDENT
<DD>(short form RES, OS/2 32-bit and VxD only) specifies that the segment is resident.
<P><DT>CONTIGUOUS
<DD>(short form CONT, OS/2 32-bit only) specifies that the segment is contiguous.
<P><DT>DYNAMIC
<DD>(short form DYN, OS/2 32-bit only) specifies that the segment is dynamic.
<P><DT>EXECUTEONLY
<DD>(short form EXECUTEO, OS/2, QNX and Win16 only) specifies that the segment can only be executed.&nbsp; This attribute
should only be specified for code segments.&nbsp; This attribute should not be specified if it is possible for the code segment
to contain jump tables which is the case with the Open Watcom C, C++ and FORTRAN 77 optimizing compilers.
<P><DT>EXECUTEREAD
<DD>(short form EXECUTER, OS/2, QNX and Win16 only) specifies that the segment can only be executed and read.&nbsp;
This attribute, the default for code segments, should only be specified for code segments.&nbsp; This attribute is appropriate
for code segments that contain jump tables as is possible with the Open Watcom C, C++ and FORTRAN 77 optimizing compilers.
<P><DT>READONLY
<DD>(short form READO, OS/2, QNX, Win16 and Win32/Win64 only) specifies that the segment can only be read.&nbsp; This attribute
should only be specified for data segments.
<P><DT>READWRITE
<DD>(short form READW, OS/2, QNX and Win16 only) specifies that the segment can be read and written.&nbsp; This is
the default for data segments.&nbsp; This attribute should only be specified for data segments.
<P><DT>SHARED
<DD>(short form SH) specifies that a single copy of the segment will be loaded and will be shared by all processes.
<P><DT>NONSHARED
<DD>(short form NONS) specifies that a unique copy of the segment will be loaded for each process.&nbsp; This is the default.
<P><DT>MOVEABLE
<DD>(short form MOV, Win16 only) specifies that the segment is moveable.&nbsp; By default, segments are moveable.
<P><DT>FIXED
<DD>(short form FIX, Win16 only) specifies that the segment is fixed.
<P><DT>DISCARDABLE
<DD>(short form DIS, Win16 and VxD only) specifies that the segment is discardable.&nbsp; By default, segments are not discardable.
<P><DT>NONDISCARDABLE
<DD>(short form NOND, VxD only) specifies that the segment is not discardable.&nbsp; By default, segments are not discardable.
<P><DT>EXECUTABLE
<DD>(short form EXECUTA, Win32/Win64 only) specifies that the segment is executable.
<P><DT>WRITABLE
<DD>(short form WRITA, Win32/Win64 only) specifies that the code segment is writable.
</DL>
<HR>
<B><I>&nbsp; Note:</I></B>&nbsp; Attributes specified for segments identified by a segment name override attributes specified
for segments identified by a class name.
<HR>

<H2 ID="SHARELIB_Option"> The SHARELIB Option </H2>
Formats:&nbsp; NetWare 
<P>The SHARELIB option specifies the file name of an NLM to be loaded as a shared NLM.&nbsp; Shared NLMs contain
global code and global data that are mapped into all memory protection domains.&nbsp; This method of loading APIs can be used
to avoid ring transitions to call other APIs in other domains.
<P>The format of the SHARELIB option ( short form SHA ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION SHARELIB=shared_nlm</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>shared_nlm
<DD>is the file name of the shared NLM.
</DL>

<H2 ID="SHOWDEAD_Option"> The SHOWDEAD Option </H2>
Formats:&nbsp; All 
<P>The SHOWDEAD option instructs the linker to list, in the map file ( see the <A HREF="#MAP_Option">MAP</A> option ), the symbols associated with dead code and
unused C++ virtual functions that it has eliminated from the link.&nbsp; The format of the SHOWDEAD option (short
form SHO ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION SHOWDEAD</TT>
<P>The SHOWDEAD option works best in concert with the <A HREF="#ELIMINATE_Option">ELIMINATE</A> and <A HREF="#VFREMOVAL_Option">VFREMOVAL</A> options.

<H2 ID="SMALL_Option"> The SMALL Option </H2>
Formats:&nbsp; DOS 
<P>The SMALL option tells JWlink to use the standard overlay manager (as opposed to the dynamic
overlay manager) and that near calls can be generated to overlay vectors corresponding to routines defined in the overlayed
portion of your program.&nbsp; The format of the SMALL option ( short form SM ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION SMALL</TT>
<P>This option should only be specified in the following circumstances.
<OL>
<LI>Your program has been compiled for a small code memory model.
<LI>You are creating an overlayed application.
<LI>The code in your program, including overlay areas, does not exceed 64K.
</OL>
<P>If the SMALL option is not specified and you are creating an overlayed application, the linker will generate
far calls to overlay vectors.&nbsp; In this case, your application must have been compiled using a big code memory model.

<H2 ID="SORT_Directive"> The SORT Directive </H2>
Formats:&nbsp; All 
<P>The SORT directive is used to sort the symbols in the &quot;Memory Map&quot; section of the map file ( see the <A HREF="#MAP_Option">MAP</A> option ).&nbsp;
By default, symbols are listed on a per module basis in the order the modules were encountered by the linker.&nbsp; That is,
a module header is displayed followed by the symbols defined by the module.
<P>The format of the SORT directive ( short form SO ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SORT [GLOBAL] [ALPHABETICAL]</TT>
<P>If the SORT directive is specified without any options, as in the following example, the module headers will
be displayed each followed by the list of symbols it defines sorted by address.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; sort</TT>
<P>If only the &quot;GLOBAL&quot; sort option (short form &quot;GL&quot;) is specified, as in the following example, the module
headers will not be displayed and all symbols will be sorted by address.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; sort global</TT>
<P>If only the &quot;ALPHABETICAL&quot; sort option (short form &quot;ALP&quot;) is specified, as in the following example,
the module headers will be displayed each followed by the list of symbols it defines sorted alphabetically.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; sort alphabetical</TT>
<P>If both the &quot;GLOBAL&quot; and &quot;ALPHABETICAL&quot; sort options are specified, as in the following example, the
module headers will not be displayed and all symbols will be sorted alphabetically.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; sort global alphabetical</TT>
<P>If you are linking a Open Watcom C++ application, mangled names are sorted by using the base name.&nbsp; The base name
is the name of the symbol as it appeared in the source file.&nbsp; See the section entitled <A HREF="#MANGLEDNAMES_Option">The MANGLEDNAMES Option</A>
for more information on mangled names.

<H2 ID="STACK_Option"> The STACK Option </H2>
Formats:&nbsp; All 
<P>The STACK option can be used to increase the size of the stack.&nbsp; The format of this option
( short form ST ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION STACK=n</TT>
<DL><DT>
<P>where &lt;n&gt; is a numeric value.&nbsp; The complete form of &lt;n&gt; is:
<DD>
<P><TT>[0x]d{d}[k|m]</TT>
<P><B>d</B> represents a decimal digit.&nbsp; If<B> 0x</B> is specified, the string of digits represents a hexadecimal number.
&nbsp;If<B> k</B> is specified, the value is multiplied by 1024.&nbsp; If<B> m</B> is specified, the value is multiplied by
1024*1024.
</DL>

<P>The default stack size varies for both 16-bit and 32-bit applications depending on the executable format.
&nbsp;You can determine the default stack size by looking at the map file that can be generated when an application is linked
( <A HREF="#MAP_Option">OPTION MAP</A> ).
<P>Note that for <A HREF="#ELF_Executable_File_Format">ELF</A> binaries the
value of the STACK option is ignored, because the size of the stack is not intended to be stored in the binary.
<P>During execution of your program, you may get an error message indicating your stack has overflowed.
&nbsp;If you encounter such an error, you must link your application again, this time specifying a larger stack size using
the STACK option.
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; option stack=8192</TT>
<P>For Win32/Win64, see the <A HREF="#COMMIT_Directive">COMMIT</A> directive for information on how to 
specify the <b>committed</b> size of the stack.

<H2 ID="STANDARD_Option"> The STANDARD Option </H2>
Formats:&nbsp; DOS 
<P>The STANDARD option instructs JWlink to use the standard overlay manager (as opposed to the
dynamic overlay manager).&nbsp; Your application must be compiled for a big code memory model.&nbsp; The format of the STANDARD
option ( short form STAN ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION STANDARD</TT>
<P>The standard overlay manager is the default.&nbsp; For more information on overlays, see the section entitled <A HREF="#DOS__Using_Overlays">DOS:&nbsp; Using Overlays</A>.

<H2 ID="START_Option"> The START Option </H2>
Formats:&nbsp; All 
<P>The format of the START option is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION START=symbol_name</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>symbol_name
<DD>specifies the name of the procedure where execution begins.
</DL>
<P>For the Netware executable format, the default name of the start procedure is &quot;_Prelude&quot;.

<H2 ID="STARTLINK_Directive"> The STARTLINK Directive </H2>
Formats:&nbsp; All 
<P>The STARTLINK directive is used to indicate the start of a new set of linker commands that are to be processed
after the current set of commands has been processed.&nbsp; The format of the STARTLINK directive ( short form
STARTL ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STARTLINK</TT>
<P>The <A HREF="#ENDLINK_Directive">ENDLINK</A> directive is used to indicate the end of the set of commands identified by the STARTLINK
directive.

<H2 ID="STATICS_Option"> The STATICS Option </H2>
Formats:&nbsp; All 
<P>Static symbols are symbols that cannot be used to resolve externals. They may be contained
in a module's symbol table for various reasons. By default, these static
symbols do not appear in the map file ( see the <A HREF="#MAP_Option">MAP</A> option ). If you want static symbols to be displayed in the map file, use the STATICS
option.
<P>The format of the STATICS option ( short form STAT ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION STATICS</TT>

<H2 ID="STUB_Option"> The STUB Option </H2>
Formats:&nbsp; OS/2, Win16, Win32/Win64 
<P>The STUB option specifies an executable file containing a <i>stub</i> program that is to be placed at
the beginning of the executable file being generated.&nbsp; The <i>stub</i> program will be executed if the module is
executed under DOS.&nbsp; The format of the STUB option is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION STUB=stub_name</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>stub_name
<DD>is a file specification for the name of the stub executable file.&nbsp; If no file extension is specified, a file extension
of &quot;EXE&quot; is assumed.
</DL>
<P>JWlink will search all paths specified in the<B> PATH</B> environment variable for the stub executable
file.&nbsp; The stub executable file specified by the STUB option must not be the same as the executable file
being generated.

<H2 ID="SYMFILE_Option"> The SYMFILE Option </H2>
Formats:&nbsp; All 
<P>The SYMFILE option provides a method for specifying an alternate file for debugging information.&nbsp; The
format of the SYMFILE option ( short form SYMF ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION SYMFILE[=symbol_file]</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>symbol_file
<DD>is a file specification for the name of the symbol file.&nbsp; If no file extension is specified, a file extension of &quot;sym&quot;
is assumed.
</DL>
<P>By default, no symbol file is generated; debugging information is appended at the end of the executable file.&nbsp; Specifying
this option causes JWlink to generate a symbol file.&nbsp; The symbol file contains the debugging information
generated by the linker when the <A HREF="#DEBUG_Directive">DEBUG</A> directive is used.&nbsp; The symbol file can then be used by Open Watcom
Debugger.&nbsp; If no debugging information is requested, no symbol file is created, regardless of the presence of the SYMFILE
option.
<P>If no file name is specified, the symbol file will have a default file extension of &quot;sym&quot; and the same path and
file name as the executable file.&nbsp; Note that the symbol file will be placed in the same directory as the executable file.
<P>Alternatively, a file name can be specified.&nbsp; The following directive instructs the linker to generate a symbol file
and call it &quot;myprog.sym&quot; regardless of the name of the executable file.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; option symf=myprog</TT>
<P>You can also specify a path and/or file extension when using the &quot;SYMFILE=&quot; form of the SYMFILE option.
<P><B>Notes:</B>
<OL>
<P><LI>This option should be used to debug a DOS &quot;COM&quot; executable file.&nbsp; A DOS &quot;COM&quot; executable file
must not contain any additional information other than the executable information itself since DOS uses the size of the file
to determine what to load.
<P><LI>This option should be used when creating a Microsoft Windows executable file.&nbsp; Typically, before an executable
file can be executed as a Microsoft Windows application, a resource compiler takes the Windows executable file and a resource
file as input and combines them.&nbsp; If the executable file contains debugging information, the resource compiler will strip
the debugging information from the executable file.&nbsp; Therefore, debugging information must not be part of the executable
file created by the linker.
</OL>

<H2 ID="SYMTRACE_Directive"> The SYMTRACE Directive </H2>
Formats:&nbsp; All 
<P>The SYMTRACE directive instructs JWlink to print a list of all modules that reference the specified
symbols.&nbsp; The format of this directive ( short form SYMT ) is
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYMTRACE&nbsp; symbol_name{,symbol_name}</TT>

<P>where &lt;symbol_name&gt; is the name of a symbol.

<P>The information is displayed in the map file ( see the <A HREF="#MAP_Option">MAP</A> option ).
<P><B>Example:</B>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink system my_os op map file test lib math symt sin, cos</TT>
<P>JWlink will list, in the map file, all modules that reference the symbols &quot;sin&quot; and &quot;cos&quot;.

<P>Also see the <A HREF="#MODTRACE_Directive">MODTRACE</A> directive.

<H2 ID="SYNCHRONIZE_Option"> The SYNCHRONIZE Option </H2>
Formats:&nbsp; NetWare 
<P>The SYNCHRONIZE option forces an NLM to complete loading before starting to load other NLMs.&nbsp; Normally,
the other NLMs are loading during the startup procedure.&nbsp; The format of the SYNCHRONIZE option ( short form SY ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION SYNCHRONIZE</TT>

<H2 ID="SYSTEM_Directive"> The SYSTEM Directive </H2>
Formats:&nbsp; All 
<P>The SYSTEM directive implements a simple macro/script mechanism.
You can define, use and delete such macros, and these options are reflected by
the three forms of the SYSTEM directive.

<P>The first form of the SYSTEM directive ( short form SYS ) is called a <b>system definition directive</b>.
&nbsp;It allows you to associate a set of linker directives with a specified name called the <i>system name</i>.&nbsp; This
set of linker directives is called a <i>system definition block</i>.&nbsp; The syntax of a system definition directive is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEM BEGIN system_name {directive} END</TT>
<P>where &lt;system_name&gt; is a unique system name and &lt;directive&gt; is one or more linker directives.
Note that a system definition directive cannot be specified within another system definition directive.

<P>The second form of the SYSTEM directive is called a <b>system deletion directive</b>.&nbsp; It allows you to remove
the association of a set of linker directives with a system name.&nbsp; The syntax of a system deletion directive is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEM DELETE system_name</TT>
<P>where &lt;system_name&gt; is a defined system name.

<P>The third form of the SYSTEM directive is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYSTEM system_name</TT>
<P>where &lt;system_name&gt; is a defined system name. When this form of 
the SYSTEM directive is encountered, all directives specified in the system definition block
identified by &lt;system_name&gt; will be processed.

<P>Let us consider an example that demonstrates the use of the SYSTEM directive.&nbsp; The following linker directives
define a system called<B> statistics.</B>
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system begin statistics<BR>
&nbsp;&nbsp;&nbsp;&nbsp; format dos<BR>
&nbsp;&nbsp;&nbsp;&nbsp; libpath \libs<BR>
&nbsp;&nbsp;&nbsp;&nbsp; library stats, graphics<BR>
&nbsp;&nbsp;&nbsp;&nbsp; option stack=8k<BR>
&nbsp;&nbsp;&nbsp;&nbsp; end<BR>
</TT>
<P>They specify that a<B> statistics</B> application is to be created by using the libraries &quot;stats.lib&quot; and &quot;graphics.lib&quot;.
&nbsp;These library files are located in the directory &quot;\libs&quot;.&nbsp; The application requires a stack size of 8k
and the specified format of executable will be generated.
<P>Suppose the linker directives in the above example are contained in the file &quot;stats.lnk&quot;.&nbsp; If we wish to
create a<B> statistics</B> application, we can issue the following command.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink @stats system statistics file myappl</TT>
<P>As demonstrated by the above example, the SYSTEM directive can be used to localize the common attributes that
describe a class of applications.
<P>The system deletion directive can be used to redefine a previously defined system.&nbsp; Consider the following example:
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system begin at_dos<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libpath %WATCOM%\lib286<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libpath %WATCOM%\lib286\dos<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format dos ^<BR>
&nbsp;&nbsp;&nbsp;&nbsp; end<BR>
&nbsp;&nbsp;&nbsp;&nbsp; system begin n98_dos<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sys at_dos ^<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libpath %WATCOM%\lib286\dos\n98<BR>
&nbsp;&nbsp;&nbsp;&nbsp; end<BR>
&nbsp;&nbsp;&nbsp;&nbsp; system begin dos<BR>
&nbsp;&nbsp;&nbsp;&nbsp; sys at_dos ^<BR>
&nbsp;&nbsp;&nbsp;&nbsp; end<BR>
</TT>
<P>If you wish to redefine the definition of the &quot;dos&quot; system, you can specify the following set of directives:
<P><TT>
&nbsp;&nbsp;&nbsp;&nbsp; system delete dos<BR>
&nbsp;&nbsp;&nbsp;&nbsp; system begin dos<BR>
&nbsp;&nbsp;&nbsp;&nbsp; sys n98_dos ^<BR>
&nbsp;&nbsp;&nbsp;&nbsp; end<BR>
</TT>
<P>This effectively redefines a &quot;dos&quot; system to be equivalent to a &quot;n98_dos&quot; system (NEC PC-9800 DOS),
rather than the previously defined &quot;at_dos&quot; system (AT-compatible DOS).
<P>For additional examples on the use of the SYSTEM directive, examine the contents of the<TT> jwlink.lnk</TT> file.
The file<TT> jwlink.lnk</TT> is a special linker directive file that is automatically processed by JWlink
before processing any other directives.
<P>The default name of the linker directive file (<TT>jwlink.lnk</TT>) can be overridden by the<B> JWLINK_LNK</B> environment
variable.&nbsp; If the specified file can't be opened, the default file name will be used.&nbsp; For example, if the<B> JWLINK_LNK</B>
environment variable is defined as follows
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; set JWLINK_LNK=my.lnk</TT>
<P>then JWlink will attempt to use a<TT> my.lnk</TT> directive file, and if that file cannot be opened, the
linker will revert to using the default<TT> jwlink.lnk</TT> file.

<H3 ID="Special_System_Names"> Special System Names </H3>
<P>There are two special system names.&nbsp; When the linker has processed all object files and the executable file format
has not been determined, and a system definition block has not been processed, the directives specified in the &quot;286&quot;
or &quot;386&quot; system definition block will be processed.&nbsp; The &quot;386&quot; system definition block will be processed
if a 32-bit object file has been processed.&nbsp; Furthermore, only a restricted set of linker directives is allowed in a
&quot;286&quot; and &quot;386&quot; system definition block.&nbsp; They are as follows.
<UL>
<LI>FORMAT
<LI>LIBFILE
<LI>LIBPATH
<LI>LIBRARY
<LI>NAME
<LI>OPTION
<LI>RUNTIME (for Phar Lap executable files only)
<LI>SEGMENT (for OS/2 and QNX executable files only)
</UL>

<H2 ID="THREADNAME_Option"> The THREADNAME Option </H2>
Formats:&nbsp; NetWare 
<P>The THREADNAME option is used to specify the pattern to be used for generating thread names.&nbsp; The format
of the THREADNAME option ( short form THR ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION THREADNAME 'thread_name'</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>thread_name
<DD>specifies the pattern used for generating thread names and must be a string of 1 to 5 characters.
</DL>
<P>The first thread name is generated by appending &quot;0&quot; to<B> thread_name,</B> the second by appending &quot;1&quot;
to<B> thread_name,</B> etc.&nbsp; If the THREADNAME option is not specified, the first 5 characters of the description
specified in the <A HREF="#FORMAT_Directive">FORMAT</A> directive are used as the pattern for generating thread names.

<H2 ID="TOGGLERELOCS_Option"> The TOGGLERELOCS Option </H2>
Formats:&nbsp; OS/2 
<P>The TOGGLERELOCS option is used with LX format executables under 32-bit DOS/4G only.&nbsp; The <A HREF="#INTERNALRELOCS_Option">INTERNALRELOCS</A>
option causes JWlink to include internal relocation information in DOS/4G LX format executables.&nbsp; Having
done so, the linker normally clears the &quot;internal fixups done&quot; flag in the LX executable header (bit 0x10).&nbsp;
The TOGGLERELOCS option causes the linker to toggle the value of the &quot;internal fixups done&quot; flag in
the LX executable header (bit 0x10).&nbsp; This option is used with DOS/4G non-zero based executables.&nbsp; Contact Tenberry
Software for further explanation.
<P>The format of the TOGGLERELOCS option ( short form TOG ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION TOGGLERELOCS</TT>

<H2 ID="UNDEFSOK_Option"> The UNDEFSOK Option </H2>
Formats:&nbsp; All 
<P>The <b>UNDEFSOK</b> option tells JWlink to generate an executable file even if undefined symbols are
present.&nbsp; By default, no executable file will be generated if undefined symbols are present.
<P>The format of the UNDEFSOK option ( short form U ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION UNDEFSOK</TT>
<P>The <b>NOUNDEFSOK</b> option tells JWlink to not generate an executable file if undefined symbols
are present.&nbsp; This is the default behaviour.
<P>The format of the NOUNDEFSOK option ( short form NOU ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION NOUNDEFSOK</TT>

<H2 ID="VECTOR_Directive"> The VECTOR Directive </H2>
Formats:&nbsp; DOS 
<P>The VECTOR directive forces JWlink to generate an overlay vector for the specified symbols
and is intended to be used when the <A HREF="#NOINDIRECT_Option">NOINDIRECT</A> option is specified.
<P>The format of the VECTOR directive ( short form VE ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR symbol_name{,symbol_name}</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>symbol_name
<DD>is a symbol name.
</DL>
<P>For more information on overlays, see the section entitled <A HREF="#DOS__Using_Overlays">DOS:&nbsp; Using Overlays</A>.

<H2 ID="VERBOSE_Option"> The VERBOSE Option </H2>
Formats:&nbsp; All 
<P>The VERBOSE option controls the amount of information produced by JWlink in the map file.&nbsp;
The format of the VERBOSE option ( short form V ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION VERBOSE</TT>
<P>If the VERBOSE option is specified, the linker will list, for each object file, all segments it defines and
their sizes.&nbsp; By default, this information is not produced in the map file.

<H2 ID="VERSION_Option"> The VERSION Option </H2>
Formats:&nbsp; NetWare, OS/2, Win16, Win32/Win64 
<P>The VERSION option can be used to identify the application so that it can be distinguished from other versions
(releases) of the same application.
<P>This option is most useful when creating a DLL or NLM since applications that use the DLL or NLM may only execute with
a specific version of the DLL or NLM.
<P>The format of the VERSION option ( short form VERS ) is:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS/2, Win16, Win32/Win64:</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION VERSION=major[.minor]</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; Netware:</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION VERSION=major[.minor[.revision]]</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>major
<DD>specifies the major version number.
<P><DT>minor
<DD>specifies the minor version number and must be less than 100.
<P><DT>revision
<DD>specifies the revision.&nbsp; The revision should be a number or a letter.&nbsp; If it is a number, it must be less than 27.
</DL>

<H2 ID="VFREMOVAL_Option"> The VFREMOVAL Option </H2>
Formats:&nbsp; All 
<P>The VFREMOVAL option is an Open Watcom peculiarity - it probably has no effect at all
for modules generated by other compilers. This option instructs the linker to remove unused C++ virtual functions.&nbsp; The format of the VFREMOVAL
option ( short form VFR ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION VFREMOVAL</TT>
<P>If the VFREMOVAL option is specified, the linker will attempt to eliminate unused virtual functions.&nbsp;
In order for the linker to do this, the Open Watcom C++ &quot;zv&quot; compiler option must be used for<B> all</B> object
files in the executable.&nbsp; The VFREMOVAL option works best in concert with the <A HREF="#ELIMINATE_Option">ELIMINATE</A> option.

<H2 ID="XDCDATA_Option"> The XDCDATA Option </H2>
Formats:&nbsp; NetWare 
<P>The XDCDATA option specifies the name of a file that contains Remote Procedure Call (RPC) descriptions for
calls in this NLM.&nbsp; RPC descriptions for APIs make it possible for APIs to be exported across memory-protection domain
boundaries.
<P>The format of the XDCDATA option ( short form XDC ) is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPTION XDCDATA=rpc_file</TT>
<DL>
<P><DT>where
<DD><B>description</B>
<P><DT>rpc_file
<DD>is the name of the file containing RPC descriptions.
</DL>

<H1 ID="DOS_Executable_File_Format"> DOS Executable File Format </H1>
This chapter deals specifically with aspects of DOS executable files.&nbsp; The DOS executable file format will only run under
the DOS operating system.
<P>Input to JWlink is specified on the command line and can be redirected to one or more files or environment
strings.&nbsp; JWlink command line format is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; JWLINK {directive}</TT>
<P>where<B><I> directive</I></B> is any of the following:
<DL>
<DT><A HREF="#ALIAS_Directive">ALIAS</a> alias_name=symbol_name{,alias_name=symbol_name}</DT>
<DT><A HREF="#AUTOSECTION_Directive">AUTOSECTION</a></DT>
<DT><A HREF="#BEGIN_Directive">BEGIN</a> {section_type [INTO ovl_file] {directive}} <A HREF="#END_Directive">END</a></DT>
<DT><A HREF="#DEBUG_Directive">DEBUG</a> dbtype [dblist] | DEBUG [dblist]</DT>
<DT><A HREF="#DISABLE_Directive">DISABLE</a> msg_num{,msg_num}</DT>
<DT><A HREF="#ENDLINK_Directive">ENDLINK</a></DT>
<DT><A HREF="#FILE_Directive">FILE</a> obj_spec{,obj_spec}</DT>
<DT><A HREF="#FIXEDLIB_Directive">FIXEDLIB</a> library_file{,library_file}</DT>
<DT><A HREF="#FORCEVECTOR_Directive">FORCEVECTOR</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#FORMAT_Directive">FORMAT</a> DOS [COM]</DT>
<DT><A HREF="#LANGUAGE_Directive">LANGUAGE</a> lang</DT>
<DT><A HREF="#LIBFILE_Directive">LIBFILE</a> obj_file{,obj_file}</DT>
<DT><A HREF="#LIBPATH_Directive">LIBPATH</a> path_name{;path_name}</DT>
<DT><A HREF="#LIBRARY_Directive">LIBRARY</a> library_file{,library_file}</DT>
<DT><A HREF="#MODTRACE_Directive">MODTRACE</a> obj_module{,obj_module}</DT>
<DT><A HREF="#NAME_Directive">NAME</a> exe_file</DT>
<DT><A HREF="#NEWSEGMENT_Directive">NEWSEGMENT</a></DT>
<DT><A HREF="#NOVECTOR_Directive">NOVECTOR</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#OPTION_Directive">OPTION</a> option{,option}
<DL>
<DT><A HREF="#AREA_Option">AREA</a>=n</DT>
<DT><A HREF="#ARTIFICIAL_Option">ARTIFICIAL</a></DT>
<DT>[NO]<A HREF="#CACHE_Option">CACHE</a></DT>
<DT>[NO]<A HREF="#CASEEXACT_Option">CASEEXACT</a></DT>
<DT><A HREF="#CVPACK_Option">CVPACK</a></DT>
<DT><A HREF="#DISTRIBUTE_Option">DISTRIBUTE</a></DT>
<DT><A HREF="#DOSSEG_Option">DOSSEG</a></DT>
<DT><A HREF="#DYNAMIC_Option">DYNAMIC</a></DT>
<DT><A HREF="#ELIMINATE_Option">ELIMINATE</a></DT>
<DT>[NO]<A HREF="#FARCALLS_Option">FARCALLS</a></DT>
<DT><A HREF="#KNOWEAS_Option">KNOWEAS</a></DT>
<DT><A HREF="#MANGLEDNAMES_Option">MANGLEDNAMES</a></DT>
<DT><A HREF="#MAP_Option">MAP</a>[=map_file]</DT>
<DT><A HREF="#MAXERRORS_Option">MAXERRORS</a>=n</DT>
<DT><A HREF="#NAMELEN_Option">NAMELEN</a>=n</DT>
<DT><A HREF="#NODEFAULTLIBS_Option">NODEFAULTLIBS</a></DT>
<DT><A HREF="#NOEXTENSION_Option">NOEXTENSION</a></DT>
<DT><A HREF="#NOINDIRECT_Option">NOINDIRECT</a></DT>
<DT><A HREF="#OSNAME_Option">OSNAME</a>='string'</DT>
<DT><A HREF="#PACKCODE_Option">PACKCODE</a>=n</DT>
<DT><A HREF="#PACKDATA_Option">PACKDATA</a>=n</DT>
<DT><A HREF="#QUIET_Option">QUIET</a></DT>
<DT>[NO]<A HREF="#REDEFSOK_Option">REDEFSOK</a></DT>
<DT><A HREF="#SHOWDEAD_Option">SHOWDEAD</a></DT>
<DT><A HREF="#SMALL_Option">SMALL</a></DT>
<DT><A HREF="#STACK_Option">STACK</a>=n</DT>
<DT><A HREF="#STANDARD_Option">STANDARD</a></DT>
<DT><A HREF="#START_Option">START</a>=symbol_name</DT>
<DT><A HREF="#STATICS_Option">STATICS</a></DT>
<DT><A HREF="#SYMFILE_Option">SYMFILE</a>[=symbol_file]</DT>
<DT>[NO]<A HREF="#UNDEFSOK_Option">UNDEFSOK</a></DT>
<DT><A HREF="#VERBOSE_Option">VERBOSE</a></DT>
<DT><A HREF="#VFREMOVAL_Option">VFREMOVAL</DT>
</DL>
</DT>
<DT><A HREF="#OPTLIB_Directive">OPTLIB</a> library_file{,library_file}</DT>
<DT><A HREF="#ORDER_Directive">ORDER</a> CLNAME class_name [class_options]</DT>
<DT><A HREF="#OUTPUT_Directive">OUTPUT</a> RAW | HEX [options]</DT>
<DT><A HREF="#OVERLAY_Directive">OVERLAY<a> class{,class}</DT>
<DT><A HREF="#PATH_Directive">PATH</a> path_name{;path_name}</DT>
<DT><A HREF="#REFERENCE_Directive">REFERENCE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SECTION_Directive">SECTION</a></DT>
<DT><A HREF="#SORT_Directive">SORT</a> [GLOBAL] [ALPHABETICAL]</DT>
<DT><A HREF="#STARTLINK_Directive">STARTLINK</a></DT>
<DT><A HREF="#SYMTRACE_Directive">SYMTRACE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> BEGIN system_name {directive} END</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> system_name</DT>
<DT><A HREF="#VECTOR_Directive">VECTOR</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#hash_Directive">#</a> comment</DT>
<DT><A HREF="#atsign_Directive">@</a> directive_file</DT>
</DL>
<P>You can view all the directives specific to DOS executable files by simply typing the following:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink ? dos</TT>

<H2 ID="DOS__JWlink_Memory_Requirements"> DOS:&nbsp; JWlink Memory Requirements </H2>
<P>JWlink uses all available memory when linking an application.&nbsp; It is possible for the size of the image being
linked to exceed the amount of memory available in your machine, particularly if the image file is to contain debugging information.
&nbsp;For this reason, a temporary disk file is used when all available memory is used by JWlink.
<P>Normally, the temporary file is created in the current working directory.&nbsp; However, by defining the &quot;tmp&quot;
environment variable to be a directory, you can tell JWlink where to create the temporary file.&nbsp; This
can be particularly useful if you have a RAM disk.&nbsp; Consider the following definition of the &quot;tmp&quot; environment
variable.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; set tmp=\tmp</TT>
<P>JWlink will create the temporary file in the directory &quot;\tmp&quot;.

<H2 ID="DOS__Using_Overlays"> DOS:&nbsp; Using Overlays </H2>
<P>Overlays are used primarily for large programs where memory requirements do not permit all portions of the program to reside
in memory at the same time.&nbsp; An overlayed program consists of a<B> root</B> and a number of<B> overlay areas.</B>
<P>The root always resides in memory.&nbsp; The root usually contains routines that are frequently used.&nbsp; For example,
a floating-point library might be placed in the root.&nbsp; Also, any modules extracted from a library file during the linking
process are placed in the root unless the <A HREF="#DISTRIBUTE_Option">DISTRIBUTE</A> option is specified.&nbsp; This option tells JWlink
to distribute modules extracted from libraries throughout the overlay structure.&nbsp;
Libraries can also be placed in the overlay structure by using the <A HREF="#FIXEDLIB_Directive">FIXEDLIB</A> directive.

<P>An<B> overlay area</B> is a piece of memory shared by various parts of a program.&nbsp; Each overlay area has a structure
associated with it.&nbsp; This structure defines where in the overlay area sections of a program are loaded.&nbsp; Sections
of a program that are loaded into an overlay area are called<B> overlays.</B>
<P>JWlink supports two overlay managers:&nbsp; the standard overlay manager and the dynamic overlay manager.
&nbsp;The standard overlay manager requires the user to create an overlay structure that defines the &quot;call&quot; relationship
between the object modules that comprise an application.&nbsp; It is the responsibility of the user to define an optimal overlay
structure so as to minimize the number of calls that cause overlays to be loaded.&nbsp; The <A HREF="#SMALL_Option">SMALL</A> and <A HREF="#STANDARD_Option">STANDARD</A>
options select the standard overlay manager.&nbsp; The <A HREF="#SMALL_Option">SMALL</A> option is required if you are linking an application
compiled for a small code memory model.&nbsp; The <A HREF="#STANDARD_Option">STANDARD</A> option is required if you are linking an application
compiled for a big code memory model.&nbsp; By default, JWlink assumes your application has been compiled
using a memory model with a big code model.&nbsp; Option STANDARD is the default.
<P>The <A HREF="#DYNAMIC_Option">DYNAMIC</A> option 
selects the dynamic overlay manager.&nbsp; The dynamic overlay manager is more sophisticated than the standard overlay manager.
&nbsp;The user need not be concerned about the &quot;call&quot; relationship between the object modules that comprise an application.
&nbsp;Basically, each module is placed in its own overlay.&nbsp; The dynamic overlay manager swaps each module (overlay) into
a single overlay area.&nbsp; This overlay area is used as a pool of memory from which memory for overlays is allocated.&nbsp;
The larger the memory pool, the greater the number of modules that can simultaneously reside in memory.&nbsp; The size of
the overlay area can be controlled by the <A HREF="#AREA_Option">AREA</A> option.

<P>Note that the dynamic overlay manager can only be used with applications that have been compiled using the &quot;of&quot;
option and a big code memory model.

<H3 ID="DOS__Defining_Overlay_Structures"> DOS:&nbsp; Defining Overlay Structures </H3>
<P>Consider the following directive file.
<PRE>
     #
     # Define files that belong in the root.
     #
     file file0, file1
     #
     # Define an overlay area.
     #
     begin
       section file file2
       section file file3, file4
       section file file5
     end
</PRE>
<OL>
<P><LI>The root consists of<TT> file0</TT> and<TT> file1.</TT>
<P><LI>Three overlays are defined.&nbsp; The first overlay (overlay #1) contains<TT> file2,</TT> the second overlay (overlay
#2) contains<TT> file3</TT> and<TT> file4,</TT> and the third overlay (overlay #3) contains<TT> file5.</TT>
</OL>
<P>The following diagram depicts the overlay structure.
<P>
<PRE>
     +-----------------------------------+ &lt;- start of root
     |                                   |
     |               file0               |
     |               file1               |
     |                                   |
     +-----------+-----------+-----------+ &lt;- start of overlay
     | #1        | #2        | #3        |    area
     |           |           |           |
     |   file2   |   file3   |   file5   |
     |           |   file4   |           |
     |           |           |           |
     +-----------+-----------+-----------+
</PRE>
<P><B>Notes:</B>
<OL>
<P><LI>The 3 overlays are all loaded at the same memory location.&nbsp; Such overlays are called <B> parallel.</B>
</OL>
<P>In the previous example, only one overlay area was defined.&nbsp; It is possible to define more than one overlay area as
demonstrated by the following example.
<P><PRE>
     #
     # Define files that belong in the root.
     #
     file file0, file1
     #
     # Define an overlay area.
     #
     begin
       section file file2
       section file file3, file4
       section file file5
     end
     #
     # Define an overlay area.
     #
     begin
       section file file6
       section file file7
       section file file8
     end
</PRE>
<P>Two overlay areas are defined.&nbsp; The first is identical to the overlay area defined in the previous example.&nbsp;
The second overlay area contains three overlays; the first overlay (overlay #4) contains<TT> file6,</TT> the second overlay
(overlay #5) contains<TT> file7,</TT> and the third overlay (overlay #6) contains<TT> file8.</TT>
<P>The following diagram depicts the overlay structure.
<P>
<PRE>
     +-----------------------------------+ &lt;- start of root
     |                                   |
     |               file0               |
     |               file1               |
     |                                   |
     +-----------+-----------+-----------+ &lt;- start of overlay
     | #1        | #2        | #3        |    area
     |           |           |           |
     |   file2   |   file3   |   file5   |
     |           |   file4   |           |
     |           |           |           |
     +-----------+-----------+-----------+ &lt;- start of overlay
     | #4        | #5        | #6        |    area
     |           |           |           |
     |   file6   |   file7   |   file8   |
     |           |           |           |
     +-----------+-----------+-----------+
</PRE>
<P>In the above example, the <A HREF="#AUTOSECTION_Directive">AUTOSECTION</A> directive could have been used to define the overlays for the second
overlay area.&nbsp; The following example illustrates the use of the <A HREF="#AUTOSECTION_Directive">AUTOSECTION</A> directive.
<P>
<PRE>
     #
     # Define files that belong in the root.
     #
     file file0, file1
     #
     # Define an overlay area.
     #
     begin
       section file file2
       section file file3, file4
       section file file5
     end
     #
     # Define an overlay area.
     #
     begin
       autosection
       file file6
       file file7
       file file8
     end
</PRE>

<P>In all of the above examples the overlays are placed in the executable file.&nbsp; It is possible to place overlays in
separate files by specifying the INTO option in the <A HREF="#SECTION_Directive">SECTION</A> directive that starts the definition of
an overlay.&nbsp; By specifying the INTO option in the <A HREF="#AUTOSECTION_Directive">AUTOSECTION</A> directive, all overlays created
as a result of the AUTOSECTION directive are placed in one overlay file.
<P>Consider the following example.&nbsp; It is similar to the previous example except for the following.&nbsp; Overlay #1
is placed in the file &quot;ovl1.ovl&quot;, overlay #2 is placed in the file &quot;ovl2.ovl&quot;, overlay #3 is placed in
the file &quot;ovl3.ovl&quot; and overlays #4, #5 and #6 are placed in file &quot;ovl4.ovl&quot;.
<P><PRE>
     #
     # Define files that belong in the root.
     #
     file file0, file1
     #
     # Define an overlay area.
     #
     begin
       section into ovl1 file file2
       section into ovl2 file file3, file4
       section into ovl3 file file5
     end
     #
     # Define an overlay area.
     #
     begin
       autosection into ovl4
       file file6
       file file7
       file file8
     end
</PRE>

<H4 ID="DOS__The_Dynamic_Overlay_Manager"> DOS:&nbsp; The Dynamic Overlay Manager </H4>
<P>Let us again consider the above example but this time we will use the dynamic overlay manager.&nbsp; The easiest way to
take the above overlay structure and use it with the dynamic overlay manager is to simply specify the <A HREF="#DYNAMIC_Option">DYNAMIC</A> option.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; option DYNAMIC</TT>
<P>Even though we have defined an overlay structure with more than one overlay area, JWlink will allocate
one overlay area and overlays from both overlay areas will be loaded into a single overlay area.&nbsp; The size of the overlay
area created by JWlink will be twice the size of the largest overlay area (unless the <A HREF="#AREA_Option">AREA</A> option
is used).
<P>To take full advantage of the dynamic overlay manager, the following sequence of directives should be used.
<PRE>
     #
     # Define files that belong in the root.
     #
     file file0, file1
     #
     # Define an overlay area.
     #
     begin
       autosection into ovl1
       file file2
       autosection into ovl2
       file file3
       file file4
       autosection into ovl3
       file file5
       autosection into ovl4
       file file6
       file file7
       file file8
     end
</PRE>
<P>In the above example, each module will be in its own overlay.&nbsp; This will result in a module being loaded into memory
only when it is required.&nbsp; If separate overlay files are not required, a single <A HREF="#AUTOSECTION_Directive">AUTOSECTION</A> directive could
be used as demonstrated by the following example.
<PRE>
     #
     # Define files that belong in the root.
     #
     file file0, file1
     #
     # Define an overlay area.
     #
     begin
       autosection
       file file2
       file file3
       file file4
       file file5
       file file6
       file file7
       file file8
     end
</PRE>

<H3 ID="DOS__Nested_Overlay_Structures"> DOS:&nbsp; Nested Overlay Structures </H3>
<P>Nested overlay structures occur when the <A HREF="#BEGIN_Directive">BEGIN</A>-<A HREF="#END_Directive">END</A> directives are nested and are only useful if
the standard overlay manager is being used.&nbsp; If you have selected the dynamic overlay manager, the nesting levels will
be ignored and each overlay will be loaded into a single overlay area.
<P>Consider the following directive file.
<PRE>
     #</TT>
     # Define files that belong in the root.</TT>
     #</TT>
     file file0, file1</TT>
     #</TT>
     # Define a nested overlay structure.</TT>
     #</TT>
     begin</TT>
       section file file2</TT>
       section file file3</TT>
       begin</TT>
         section file file4, file5</TT>
         section file file6</TT>
       end</TT>
     end</TT>
</PRE>
<P><B>Notes:</B>
<OL>
<P><LI>The root contains<TT> file0</TT> and<TT> file1.</TT>
<P><LI>Four overlays are defined.&nbsp; The first overlay (overlay #1) contains<TT> file2,</TT> the second overlay (overlay
#2) contains<TT> file3,</TT> the third overlay (overlay #3) contains<TT> file4</TT> and<TT> file5,</TT> and the fourth overlay
(overlay #4) contains<TT> file6.</TT>
</OL>
<P>The following diagram depicts the overlay structure.
<P>
<PRE>
     +-----------------------------------+ &lt;- start of root
     |                                   |
     |              file0                |
     |              file1                |
     |                                   |
     +-----------+-----------------------+ &lt;- start of overlay
     | #1        | #2                    |    area
     |           |                       |
     |   file2   |         file3         |
     |           |                       |
     |           |                       |
     |           +-----------+-----------+ &lt;- start of overlay
     |           | #3        | #4        |    area
     |           |           |           |
     |           |   file4   |   file6   |
     |           |   file5   |           |
     |           |           |           |
     +-----------+-----------+-----------+
</PRE>
<P><B>Notes:</B>
<OL>
<P><LI>Overlay #1 and overlay #2 are parallel overlays.&nbsp; Overlay #3 and overlay #4 are also parallel overlays.
<P><LI>Overlay #3 and overlay #4 are loaded in memory following overlay #2.&nbsp; In this case, overlay #2 is called an <B>
ancestor</B> of overlay #3 and overlay #4.&nbsp; Conversely, overlay #3 and overlay #4 are <B> descendants</B> of overlay
#2.
<P><LI>The root is an ancestor of all overlays.
</OL>
<P>Nested overlays are particularly useful when the routines that make up one overlay are used only by a few other overlays.
&nbsp;In the above example, the routines in overlay #2 would only be used by routines in overlay #3 and overlay #4 but not
by overlay #1.

<H3 ID="DOS__Rules_About_Overlays"> DOS:&nbsp; Rules About Overlays </H3>
<P>JWlink handles all the details of loading overlays.&nbsp; No changes to a program have to be made if, for
example, it becomes so large that you have to change to an overlay structure.&nbsp; Certain rules have to be followed to ensure
the proper execution of your program.&nbsp; These rules pertain more to the organization of the components of your program
and less to the way it was coded.
<OL>
<P><LI>Care should be taken when passing addresses of functions as arguments.&nbsp; Consider the following example.
<P>
<PRE>
     +-----------------------+ &lt;- start of root
     |                       |
     |         main          |
     |                       |
     +-----------+-----------+ &lt;- start of overlay
     |  modulea  |  moduleb  |    area
     |           |           |
     |     f     |     h     |
     |     g     |           |
     |           |           |
     +-----------+-----------+</TT>
</PRE>
<P>Function<B> f</B> passes the address of<B> static</B> function<B> g</B> to function<B> h.</B>&nbsp; Function<B> h</B> then
calls function<B> g</B> indirectly.&nbsp; Function<B> f</B> and function<B> g</B> are defined in<B> modulea</B> and function<B>
h</B> is defined in<B> moduleb.</B>&nbsp; Furthermore, suppose that<B> modulea</B> and<B> moduleb</B> are parallel overlays.
&nbsp;The linker will not generate an overlay vector for function<B> g</B> since it is static so when function<B> h</B> calls
function<B> g</B> indirectly, unpredictable results may occur.&nbsp; Note that if<B> g</B> is a global function, an overlay
vector will be generated and the program will execute correctly.
<P><LI>You should organize the overlay structure to minimize the number of times overlays have to be loaded into memory.&nbsp;
Consider a loop calling two routines, each routine in a different overlay.&nbsp; If the overlay structure is such that the
overlays are parallel, that is they occupy the same memory, each iteration of the loop will cause 2 overlays to be loaded
into memory.&nbsp; This will significantly increase execution time if the loop is iterated many times.
<P><LI>If a number of overlays have a number of common routines that they all reference, the common routines will most likely
be placed in an ancestor overlay of the overlays that reference them.&nbsp; For this reason, whenever an overlay is loaded,
all its ancestors are also loaded.
<P><LI>In an overlayed program, the<B> overlay loader</B> is included in the executable file.&nbsp; If we are dealing with
relatively small programs, the size of the overlay loader may be larger than the amount of memory saved by overlaying the
program.&nbsp; In a larger application, the size of the overlayed version would be smaller than the size of the non-overlayed
version.&nbsp; Note that overlaying a program results in a larger executable file but the memory requirements are less.
<P><LI>The symbols &quot;__OVLTAB__&quot;, &quot;__OVLSTARTVEC__&quot;, &quot;__OVLENDVEC__&quot;, &quot;__LOVLLDR__&quot;,
&quot;__NOVLLDR__&quot;, &quot;__SOVLLDR__&quot;, &quot;__LOVLINIT__&quot;, &quot;__NOVLINIT__&quot; and &quot;__SOVLINIT__&quot;
are defined when you use overlays.&nbsp; Your program should not define these symbols.
<P><LI>When using the dynamic overlay manager, you should not take the address of static functions.&nbsp; Static functions
are not given overlay vectors, so if the module in which the address of a static function is taken, is moved by the dynamic
overlay manager, that address will no longer point to the static function.
</OL>

<H3 ID="DOS__Increasing_the_Dynamic_Overlay_Area"> DOS:&nbsp; Increasing the Dynamic Overlay Area </H3>
Unless the <A HREF="#AREA_Option">AREA</A> option has been specified, the default size of the dynamic overlay area is twice the size of the
largest overlay (or module if each module is its own overlay).&nbsp; It is possible to add additional overlay areas at run-time
so that the dynamic overlay manager can use the additional memory.&nbsp; A routine has been provided, called<TT> _ovl_addarea.</TT>
&nbsp;This function is defined as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; void far _ovl_addarea(unsigned segment,unsigned size);</TT>
<P>The first argument is the segment address of the block memory you wish to add.&nbsp; The second argument is the size, in
paragraphs, of the memory block.
<P>In assembly language, the function is called<TT> _ovl_addarea_</TT> with the first argument being passed in register AX
and the second argument in register DX.

<H3 ID="DOS__How_Overlay_Files_are_Opened"> DOS:&nbsp; How Overlay Files are Opened </H3>
<P>The overlay manager normally opens overlay files, including executable files containing overlays, in compatibility mode.
&nbsp;Compatibility mode is a sharing mode.&nbsp; A file opened in compatibility mode means that it can be opened any number
of times provided that it is not currently opened under one of the other sharing modes.&nbsp; In other words, the file must
always be opened in compatibility mode.
<P>The overlay manager keeps most recently used overlay files open for efficiency.&nbsp; This means that any application,
including the currently executing application, that may want to open an overlay file, must open it in compatibility mode.
&nbsp;For example, the executing application may have data at the end of the executable file that it wishes to access.
<P>If an application wishes to open the file in a sharing mode other than compatibility mode, the function<TT> _ovl_openflags</TT>
has been defined which allows the caller to specify the sharing mode with which the overlay files will be opened by the overlay
manager.&nbsp; This function is defined as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned far _ovl_openflags(unsigned sharing_mode);</TT>
<P>Legal values for the sharing mode are as follows.
<PRE>
     Sharing Mode          Value
     --------------------  -----
     compatibility mode    0x00
     deny read/write mode  0x01
     deny write mode       0x02
     deny read mode        0x03
     deny none mode        0x04
</PRE>
<P>The return value is the previous sharing mode used by the overlay manager to open overlay files.
<P>Note that DOS opens executable files in compatibility mode when loading them for execution.&nbsp; This is important for
executable files on networks that may be accessed simultaneously by many users.
<P>In assembly language, the function is called<TT> _ovl_openflags_</TT> with its argument being passed in register AX.

<H1 ID="RAW__The_RAW_File_Format"> RAW:&nbsp; The RAW File Format </H1>
<P>This chapter deals specifically with aspects of RAW executable files.
<P>Input to JWlink is specified on the command line and can be redirected to one or more files or environment
strings.&nbsp; JWlink command line format is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; JWLINK {directive}</TT>
<P>where<B><I> directive</I></B> is any of the following:
<DL>
<DT><A HREF="#ALIAS_Directive">ALIAS</A> alias_name=symbol_name{,alias_name=symbol_name}</DT>
<DT><A HREF="#DEBUG_Directive">DEBUG</A> dbtype [dblist] | DEBUG [dblist]</DT>
<DT><A HREF="#DISABLE_Directive">DISABLE</A> msg_num{,msg_num}</DT>
<DT><A HREF="#ENDLINK_Directive">ENDLINK</A></DT>
<DT><A HREF="#FILE_Directive">FILE</A> obj_spec{,obj_spec}</DT>
<DT><A HREF="#FORMAT_Directive">FORMAT</A> RAW [BIN | HEX]</DT>
<DT><A HREF="#LANGUAGE_Directive">LANGUAGE</A> lang</DT>
<DT><A HREF="#LIBFILE_Directive">LIBFILE</A> obj_file{,obj_file}</DT>
<DT><A HREF="#LIBPATH_Directive">LIBPATH</A> path_name{;path_name}</DT>
<DT><A HREF="#LIBRARY_Directive">LIBRARY</A> library_file{,library_file}</DT>
<DT><A HREF="#MODFILE_Directive">MODFILE</A> obj_file{,obj_file}</DT>
<DT><A HREF="#MODTRACE_Directive">MODTRACE</A> obj_module{,obj_module}</DT>
<DT><A HREF="#NAME_Directive">NAME</A> exe_file</DT>
<DT><A HREF="#OPTION_Directive">OPTION</A> option{,option}
<DL>
<DT><A HREF="#ARTIFICIAL_Option">ARTIFICIAL</A></DT>
<DT>[NO]<A HREF="#CACHE_Option">CACHE</A></DT>
<DT>[NO]<A HREF="#CASEEXACT_Option">CASEEXACT</A></DT>
<DT><A HREF="#CVPACK_Option">CVPACK</A></DT>
<DT><A HREF="#DOSSEG_Option">DOSSEG</A></DT>
<DT><A HREF="#ELIMINATE_Option">ELIMINATE</A></DT>
<DT>[NO]<A HREF="#FARCALLS_Option">FARCALLS</A></DT>
<DT><A HREF="#INCREMENTAL_Option">INCREMENTAL</A></DT>
<DT><A HREF="#MANGLEDNAMES_Option">MANGLEDNAMES</A></DT>
<DT><A HREF="#MAP_Option">MAP[=map_file]</A></DT>
<DT><A HREF="#MAXERRORS_Option">MAXERRORS</A>=n</DT>
<DT><A HREF="#NAMELEN_Option">NAMELEN</A>=n</DT>
<DT><A HREF="#NODEFAULTLIBS_Option">NODEFAULTLIBS</A></DT>
<DT><A HREF="#NOEXTENSION_Option">NOEXTENSION</A></DT>
<DT><A HREF="#OFFSET_M_RAW_only">OFFSET</A>=n</DT>
<DT><A HREF="#OSNAME_Option">OSNAME</A>='string'</DT>
<DT><A HREF="#QUIET_Option">QUIET</A></DT>
<DT>[NO]<A HREF="#REDEFSOK_Option">REDEFSOK</A></DT>
<DT><A HREF="#STACK_Option">STACK</A>=n</DT>
<DT><A HREF="#START_Option">START</A>=symbol_name</DT>
<DT><A HREF="#STATICS_Option">STATICS</A></DT>
<DT><A HREF="#SYMFILE_Option">SYMFILE</A>[=symbol_file]</DT>
<DT>[NO]<A HREF="#UNDEFSOK_Option">UNDEFSOK</A></DT>
<DT><A HREF="#VERBOSE_Option">VERBOSE</A></DT>
<DT><A HREF="#VFREMOVAL_Option">VFREMOVAL</A></DT>
</DL>
</DT>
<DT><A HREF="#OPTLIB_Directive">OPTLIB</A> library_file{,library_file}</DT>
<DT><A HREF="#ORDER_Directive">ORDER</a> CLNAME class_name [class_options]</DT>
<DT><A HREF="#OUTPUT_Directive">OUTPUT</a> RAW | HEX [options]</DT>
<DT><A HREF="#PATH_Directive">PATH</A> path_name{;path_name}</DT>
<DT><A HREF="#REFERENCE_Directive">REFERENCE</A> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SORT_Directive">SORT</A> [GLOBAL] [ALPHABETICAL]</DT>
<DT><A HREF="#STARTLINK_Directive">STARTLINK</A></DT>
<DT><A HREF="#SYMTRACE_Directive">SYMTRACE</A> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</A> BEGIN system_name {directive} END</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</A> system_name</DT>
<DT><A HREF="#hash_Directive">#</A> comment</DT>
<DT><A HREF="#atsign_Directive">@</A> directive_file</DT>
</DL>
<P>You can view all the directives specific to RAW executable files by simply typing the following:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink ? raw</TT>

<H2 ID="RAW__JWlink_Memory_Requirements"> RAW:&nbsp; JWlink Memory Requirements </H2>
<P>JWlink uses all available memory when linking an application.&nbsp; It is possible for the size of the image being
linked to exceed the amount of memory available in your machine, particularly if the image file is to contain debugging information.
&nbsp;For this reason, a temporary disk file is used when all available memory is used by JWlink.
<P>Normally, the temporary file is created in the current working directory.&nbsp; However, by defining the &quot;tmp&quot;
environment variable to be a directory, you can tell JWlink where to create the temporary file.&nbsp; This
can be particularly useful if you have a RAM disk.&nbsp; Consider the following definition of the &quot;tmp&quot; environment
variable.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; set tmp=\tmp</TT>
<P>JWlink will create the temporary file in the directory &quot;\tmp&quot;.

<H1 ID="ELF_Executable_File_Format"> ELF32/ELF64 Executable File Format </H1>
<P>This chapter deals specifically with aspects of ELF executable files.&nbsp; The ELF executable file format will only run
under the operating systems that support the ELF executable file format.
<P>Input to JWlink is specified on the command line and can be redirected to one or more files or environment
strings.&nbsp; JWlink command line format is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; JWLINK {directive}</TT>
<P>where<B><I> directive</I></B> is any of the following:
<DL>
<DT><A HREF="#ALIAS_Directive">ALIAS</a> alias_name=symbol_name{,alias_name=symbol_name}</DT>
<DT><A HREF="#DEBUG_Directive">DEBUG</a> dbtype [dblist] | DEBUG [dblist]</DT>
<DT><A HREF="#DISABLE_Directive">DISABLE</a> msg_num{,msg_num}</DT>
<DT><A HREF="#ENDLINK_Directive">ENDLINK</a></DT>
<DT><A HREF="#EXPORT_M_ELF_only">EXPORT</a> entry_name {,entry_name}</DT>
<DT><A HREF="#FILE_Directive">FILE</a> obj_spec{,obj_spec}</DT>
<DT><A HREF="#FORMAT_Directive">FORMAT</a> ELF [DLL]</DT>
<DT><A HREF="#IMPORT_M_ELF_only">IMPORT</a> external_name {,external_name}</DT>
<DT><A HREF="#LANGUAGE_Directive">LANGUAGE</a> lang</DT>
<DT><A HREF="#LIBFILE_Directive">LIBFILE</a> obj_file{,obj_file}</DT>
<DT><A HREF="#LIBPATH_Directive">LIBPATH</a> path_name{;path_name}</DT>
<DT><A HREF="#LIBRARY_Directive">LIBRARY</a> library_file{,library_file}</DT>
<DT><A HREF="#MODFILE_Directive">MODFILE</a> obj_file{,obj_file}</DT>
<DT><A HREF="#MODTRACE_Directive">MODTRACE</a> obj_module{,obj_module}</DT>
<DT><A HREF="#MODULE_Directive">MODULE</a> module_name {,module_name}</DT>
<DT><A HREF="#NAME_Directive">NAME</a> exe_file</DT>
<DT><A HREF="#OPTION_Directive">OPTION</a> option{,option}
<DL>
<DT><A HREF="#ALIGNMENT_Option">ALIGNMENT</a>=n</DT>
<DT><A HREF="#ARTIFICIAL_Option">ARTIFICIAL</a></DT>
<DT>[NO]<A HREF="#CACHE_Option">CACHE</a></DT>
<DT>[NO]<A HREF="#CASEEXACT_Option">CASEEXACT</a></DT>
<DT><A HREF="#CVPACK_Option">CVPACK</a></DT>
<DT><A HREF="#DOSSEG_Option">DOSSEG</a></DT>
<DT><A HREF="#ELIMINATE_Option">ELIMINATE</a></DT>
<DT><A HREF="#EXPORTALL_Option">EXPORTALL</a></DT>
<DT>[NO]<A HREF="#FARCALLS_Option">FARCALLS</a></DT>
<DT><A HREF="#INCREMENTAL_Option">INCREMENTAL</a></DT>
<DT><A HREF="#MANGLEDNAMES_Option">MANGLEDNAMES</a></DT>
<DT><A HREF="#MAP_Option">MAP</a>[=map_file]</DT>
<DT><A HREF="#MAXERRORS_Option">MAXERRORS</a>=n</DT>
<DT><A HREF="#NAMELEN_Option">NAMELEN</a>=n</DT>
<DT><A HREF="#NODEFAULTLIBS_Option">NODEFAULTLIBS</a></DT>
<DT><A HREF="#NOEXTENSION_Option">NOEXTENSION</a></DT>
<DT><A HREF="#OFFSET_M_OSD2__Win32__ELF_only">OFFSET</a>=n</DT>
<DT><A HREF="#OSNAME_Option">OSNAME</a>='string'</DT>
<DT><A HREF="#QUIET_Option">QUIET</a></DT>
<DT>[NO]<A HREF="#REDEFSOK_Option">REDEFSOK</a></DT>
<DT><A HREF="#SHOWDEAD_Option">SHOWDEAD</a></DT>
<DT><A HREF="#STACK_Option">STACK</a>=n</DT>
<DT><A HREF="#START_Option">START</a>=symbol_name</DT>
<DT><A HREF="#STATICS_Option">STATICS</a></DT>
<DT><A HREF="#SYMFILE_Option">SYMFILE</a>[=symbol_file]</DT>
<DT>[NO]<A HREF="#UNDEFSOK_Option">UNDEFSOK</a></DT>
<DT><A HREF="#VERBOSE_Option">VERBOSE</a></DT>
<DT><A HREF="#VFREMOVAL_Option">VFREMOVAL</a></DT>
</DL>
</DT>
<DT><A HREF="#OPTLIB_Directive">OPTLIB</a> library_file{,library_file}</DT>
<DT><A HREF="#ORDER_Directive">ORDER</a> CLNAME class_name [class_options]</DT>
<DT><A HREF="#OUTPUT_Directive">OUTPUT</a> RAW | HEX [options]</DT>
<DT><A HREF="#PATH_Directive">PATH</a> path_name{;path_name}</DT>
<DT><A HREF="#REFERENCE_Directive">REFERENCE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#RUNTIME_M_ELF_only">RUNTIME</a> run_option</DT>
<DT><A HREF="#SORT_Directive">SORT</a> [GLOBAL] [ALPHABETICAL]</DT>
<DT><A HREF="#STARTLINK_Directive">STARTLINK</a></DT>
<DT><A HREF="#SYMTRACE_Directive">SYMTRACE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> BEGIN system_name {directive} END</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> system_name</DT>
<DT><A HREF="#hash_Directive">#</a> comment</DT>
<DT><A HREF="#atsign_Directive">@</a> directive_file</DT>
</DL>
<P>You can view all the directives specific to ELF executable files by simply typing the following:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink ? elf</TT>

<H1 ID="NetWare__The_NetWare_ODS_Executable_File_Format"> NetWare:&nbsp; The NetWare O/S Executable File Format </H1>
<P>This chapter deals specifically with aspects of NetWare executable files.&nbsp; The Novell NetWare executable file format
will only run under NetWare operating systems.
<P>Input to JWlink is specified on the command line and can be redirected to one or more files or environment
strings.&nbsp; JWlink command line format is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; JWLINK {directive}</TT>
<P>where<B><I> directive</I></B> is any of the following:
<DL>
<DT><A HREF="#ALIAS_Directive">ALIAS</A> alias_name=symbol_name{,alias_name=symbol_name}</DT>
<DT><A HREF="#DEBUG_Directive">DEBUG</A> dbtype [dblist] | DEBUG [dblist]</DT>
<DT><A HREF="#DISABLE_Directive">DISABLE</A> msg_num{,msg_num}</DT>
<DT><A HREF="#ENDLINK_Directive">ENDLINK</A></DT>
<DT><A HREF="#EXPORT_M_Netware_only">EXPORT</A> entry_name {,entry_name}</DT>
<DT><A HREF="#FILE_Directive">FILE</A> obj_spec{,obj_spec}</DT>
<DT><A HREF="#FORMAT_Directive">FORMAT</A> NOVELL [NLM | LAN | DSK | NAM | 'number'] 'description'</DT>
<DT><A HREF="#IMPORT_M_Netware_only">IMPORT</A> external_name {,external_name}</DT>
<DT><A HREF="#LANGUAGE_Directive">LANGUAGE</A> lang</DT>
<DT><A HREF="#LIBFILE_Directive">LIBFILE</A> obj_file{,obj_file}</DT>
<DT><A HREF="#LIBPATH_Directive">LIBPATH</A> path_name{;path_name}</DT>
<DT><A HREF="#LIBRARY_Directive">LIBRARY</A> library_file{,library_file}</DT>
<DT><A HREF="#MODTRACE_Directive">MODTRACE</A> obj_module{,obj_module}</DT>
<DT><A HREF="#MODULE_Directive">MODULE</A> module_name {,module_name}</DT>
<DT><A HREF="#NAME_Directive">NAME</A> exe_file</DT>
<DT><A HREF="#OPTION_Directive">OPTION</A> option{,option}
<DL>
<DT><A HREF="#ARTIFICIAL_Option">ARTIFICIAL</A></DT>
<DT><A HREF="#AUTOUNLOAD_Option">AUTOUNLOAD</A></DT>
<DT>[NO]<A HREF="#CACHE_Option">CACHE</A></DT>
<DT>[NO]<A HREF="#CASEEXACT_Option">CASEEXACT</A></DT>
<DT><A HREF="#CHECK_Option">CHECK</A>=symbol_name</DT>
<DT><A HREF="#COPYRIGHT_Option">COPYRIGHT</A> 'string'</DT>
<DT><A HREF="#CUSTOM_Option">CUSTOM</A>=file_name</DT>
<DT><A HREF="#CVPACK_Option">CVPACK</A></DT>
<DT><A HREF="#DOSSEG_Option">DOSSEG</A></DT>
<DT><A HREF="#ELIMINATE_Option">ELIMINATE</A></DT>
<DT><A HREF="#EXIT_Option">EXIT</A>=symbol_name</DT>
<DT>[NO]<A HREF="#FARCALLS_Option">FARCALLS</A></DT>
<DT><A HREF="#HELP_Option">HELP</A>=help_file</DT>
<DT><A HREF="#IMPFILE_Option">IMPFILE</A>[=imp_file]</DT>
<DT><A HREF="#IMPLIB_Option">IMPLIB</A>[=imp_lib]</DT>
<DT><A HREF="#MANGLEDNAMES_Option">MANGLEDNAMES</A></DT>
<DT><A HREF="#MAP_Option">MAP</A>[=map_file]</DT>
<DT><A HREF="#MAXERRORS_Option">MAXERRORS</A>=n</DT>
<DT><A HREF="#MESSAGES_Option">MESSAGES</A>=msg_file</DT>
<DT><A HREF="#MULTILOAD_Option">MULTILOAD</A></DT>
<DT><A HREF="#NAMELEN_Option">NAMELEN</A>=n</DT>
<DT><A HREF="#NLMFLAGS_Option">NLMFLAGS</A>=some_value</DT>
<DT><A HREF="#NODEFAULTLIBS_Option">NODEFAULTLIBS</A></DT>
<DT><A HREF="#NOEXTENSION_Option">NOEXTENSION</A></DT>
<DT><A HREF="#OSDOMAIN_Option">OSDOMAIN</A></DT>
<DT><A HREF="#OSNAME_Option">OSNAME</A>='string'</DT>
<DT><A HREF="#PSEUDOPREEMPTION_Option">PSEUDOPREEMPTION</A></DT>
<DT><A HREF="#QUIET_Option">QUIET</A></DT>
<DT>[NO]<A HREF="#REDEFSOK_Option">REDEFSOK</A></DT>
<DT><A HREF="#SHOWDEAD_Option">SHOWDEAD</A></DT>
<DT><A HREF="#REENTRANT_Option">REENTRANT</A></DT>
<DT><A HREF="#SCREENNAME_Option">SCREENNAME</A> 'name'</DT>
<DT><A HREF="#SHARELIB_Option">SHARELIB</A>=shared_nlm</DT>
<DT><A HREF="#STACK_Option">STACK</A>=n</DT>
<DT><A HREF="#START_Option">START</A>=symbol_name</DT>
<DT><A HREF="#STATICS_Option">STATICS</A></DT>
<DT><A HREF="#SYMFILE_Option">SYMFILE</A>[=symbol_file]</DT>
<DT><A HREF="#SYNCHRONIZE_Option">SYNCHRONIZE</A></DT>
<DT><A HREF="#THREADNAME_Option">THREADNAME</A> 'thread_name'</DT>
<DT>[NO]<A HREF="#UNDEFSOK_Option">UNDEFSOK</A></DT>
<DT><A HREF="#VERBOSE_Option">VERBOSE</A></DT>
<DT><A HREF="#VERSION_Option">VERSION</A>=major[.minor[.revision]]</DT>
<DT><A HREF="#VFREMOVAL_Option">VFREMOVAL</A></DT>
<DT><A HREF="#XDCDATA_Option">XDCDATA</A>=rpc_file</DT>
</DL>
</DT>
<DT><A HREF="#OPTLIB_Directive">OPTLIB</A> library_file{,library_file}</DT>
<DT><A HREF="#ORDER_Directive">ORDER</a> CLNAME class_name [class_options]</DT>
<DT><A HREF="#OUTPUT_Directive">OUTPUT</a> RAW | HEX [options]</DT>
<DT><A HREF="#PATH_Directive">PATH</A> path_name{;path_name}</DT>
<DT><A HREF="#REFERENCE_Directive">REFERENCE</A> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SORT_Directive">SORT</A> [GLOBAL] [ALPHABETICAL]</DT>
<DT><A HREF="#STARTLINK_Directive">STARTLINK</A></DT>
<DT><A HREF="#SYMTRACE_Directive">SYMTRACE</A> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</A> BEGIN system_name {directive} END</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</A> system_name</DT>
<DT><A HREF="#hash_Directive">#</A> comment</DT>
<DT><A HREF="#atsign_Directive">@</A> directive_file</DT>
</DL>
<P>You can view all the directives specific to NetWare executable files by simply typing the following:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink ? nov</TT>

<H2 ID="NetWare__NetWare_Loadable_Modules"> NetWare:&nbsp; NetWare Loadable Modules </H2>
NetWare Loadable Modules (NLMs) are executable files that run in file server memory under the NetWare operating system.&nbsp;
NLMs can be loaded and unloaded from file server memory while the server is running.&nbsp; When running they actually become
part of the operating system thus acting as building blocks for a server environment tailored to your needs.
<P>There are multiple types of NLMs, each identified by the file extension of the executable file and the internal module
type number.
<UL>
<P><LI>Utility and server applications (executable files with extension &quot;nlm&quot;).
<P><LI>LAN drivers (executable files with extension &quot;lan&quot;).
<P><LI>Disk drivers (executable files with extension &quot;dsk&quot;).
<P><LI>Modules that define file system name spaces (executable files with extension &quot;nam&quot;).
<P><LI>Custom Device modules (executable files with extension &quot;cdm&quot;).
<P><LI>Host Adapter modules (executable files with extension &quot;ham&quot;).
<P><LI>Mirrored server link modules (executable files with extension &quot;msl&quot;).
<P><LI>Module types specified by number.&nbsp; These are the current defined values:
<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#E0E0E0"><TD>0</TD><TD>Specifies a standard NLM (default extension .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>1</TD><TD>Specifies a disk driver module (default extension .DSK)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>2</TD><TD>Specifies a namespace driver module (default extension .NAM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>3</TD><TD>Specifies a LAN driver module (default extension .LAN)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>4</TD><TD>Specifies a utility NLM (default extension .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>5</TD><TD>Specifies a Mirrored Server Link module (default .MSL)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>6</TD><TD>Specifies an Operating System module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>7</TD><TD>Specifies a Page High OS module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>8</TD><TD>Specifies a Host Adapter module (default .HAM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>9</TD><TD>Specifies a Custom Device module (default .CDM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>10</TD><TD>Reserved for Novell usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>11</TD><TD>Reserved for Novell usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>12</TD><TD>Specifies a Ghost module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>13</TD><TD>Specifies an SMP driver module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>14</TD><TD>Specifies a NIOS module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>15</TD><TD>Specifies a CIOS CAD type module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>16</TD><TD>Specifies a CIOS CLS type module (default .NLM)</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>21</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>22</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>23</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>24</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>25</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>26</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>27</TD><TD>Reserved for Novell NICI usage</TD><TR>
<TR BGCOLOR="#E0E0E0"><TD>28</TD><TD>Reserved for Novell NICI usage</TD><TR>
</TABLE>
</TD></TR>
</TABLE>
</TD></TR>

</UL>


<P>JWlink can generate all types of NLMs by utilising the numerical value of the module type.

<H1 ID="OSD2_Executable_and_DLL_File_Formats"> OS/2 Executable and DLL File Formats </H1>
<P>This chapter deals specifically with aspects of OS/2 executable files.&nbsp; The OS/2 16-bit executable file format will
run under the following operating systems.
<OL>
<LI>16-bit OS/2 1.x
<LI>32-bit OS/2 2.x, 3.x (Warp) and 4.x
<LI>Phar Lap's 286|DOS-Extender
</OL>
<P>The OS/2 32-bit linear executable file format will run under the following operating systems.
<OL>
<LI>OS/2 2.x and later (LX format only)
<LI>CauseWay DOS extender, Tenberry Software's DOS/4G and DOS/4GW DOS extenders, and compatible products (LE format only)
<LI>FlashTek's DOS Extender (LX format only)
</OL>
<P>Input to JWlink is specified on the command line and can be redirected to one or more files or environment
strings.&nbsp; JWlink command line format is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; JWLINK {directive}</TT>
<P>where<B><I> directive</I></B> is any of the following:
<DL>
<DT><A HREF="#ALIAS_Directive">ALIAS</a> alias_name=symbol_name{,alias_name=symbol_name}</DT>
<DT><A HREF="#DEBUG_Directive">DEBUG</a> dbtype [dblist] | DEBUG [dblist]</DT>
<DT><A HREF="#DISABLE_Directive">DISABLE</a> msg_num{,msg_num}</DT>
<DT><A HREF="#ENDLINK_Directive">ENDLINK</a></DT>
<DT><A HREF="#EXPORT_M_OSD2__Win16__Win32_only">EXPORT</a> export{,export}</DT>
<DT><A HREF="#EXPORT_Directive">EXPORT</a> =lbc_file</DT>
<DT><A HREF="#FILE_Directive">FILE</a> obj_spec{,obj_spec}</DT>
<DT><A HREF="#FORMAT_Directive">FORMAT</a> OS2 [exe_type] [dll_form | exe_attrs]</DT>
<DT><A HREF="#IMPORT_M_OSD2__Win16__Win32_only">IMPORT</a> import{,import}</DT>
<DT><A HREF="#LANGUAGE_Directive">LANGUAGE</a> lang</DT>
<DT><A HREF="#LIBFILE_Directive">LIBFILE</a> obj_file{,obj_file}</DT>
<DT><A HREF="#LIBPATH_Directive">LIBPATH</a> path_name{;path_name}</DT>
<DT><A HREF="#LIBRARY_Directive">LIBRARY</a> library_file{,library_file}</DT>
<DT><A HREF="#MODFILE_Directive">MODFILE</a> obj_file{,obj_file}</DT>
<DT><A HREF="#MODTRACE_Directive">MODTRACE</a> obj_module{,obj_module}</DT>
<DT><A HREF="#NAME_Directive">NAME</a> exe_file</DT>
<DT><A HREF="#NEWSEGMENT_Directive">NEWSEGMENT</a></DT>
<DT><A HREF="#PATH_Directive">PATH</a> path_name{;path_name}</DT>
<DT><A HREF="#OPTION_Directive">OPTION</a> option{,option}
<DL>
<DT><A HREF="#ALIGNMENT_Option">ALIGNMENT</a>=n</DT>
<DT><A HREF="#ARTIFICIAL_Option">ARTIFICIAL</a></DT>
<DT>[NO]<A HREF="#CACHE_Option">CACHE</a></DT>
<DT>[NO]<A HREF="#CASEEXACT_Option">CASEEXACT</a></DT>
<DT><A HREF="#CVPACK_Option">CVPACK</a></DT>
<DT><A HREF="#DESCRIPTION_Option">DESCRIPTION</a> 'string'</DT>
<DT><A HREF="#DOSSEG_Option">DOSSEG</a></DT>
<DT><A HREF="#ELIMINATE_Option">ELIMINATE</a></DT>
<DT>[NO]<A HREF="#FARCALLS_Option">FARCALLS</a></DT>
<DT><A HREF="#HEAPSIZE_Option">HEAPSIZE</a>=n</DT>
<DT><A HREF="#IMPFILE_Option">IMPFILE</a>[=imp_file]</DT>
<DT><A HREF="#IMPLIB_Option">IMPLIB</a>[=imp_lib]</DT>
<DT><A HREF="#INCREMENTAL_Option">INCREMENTAL</a></DT>
<DT><A HREF="#INTERNALRELOCS_Option">INTERNALRELOCS</a></DT>
<DT><A HREF="#MANGLEDNAMES_Option">MANGLEDNAMES</a></DT>
<DT><A HREF="#MANYAUTODATA_Option">MANYAUTODATA</a></DT>
<DT><A HREF="#MAP_Option">MAP</a>[=map_file]</DT>
<DT><A HREF="#MAXERRORS_Option">MAXERRORS</a>=n</DT>
<DT><A HREF="#MIXED1632_Option">MIXED1632</a></DT>
<DT><A HREF="#MODNAME_Option">MODNAME</a>=module_name</DT>
<DT><A HREF="#NAMELEN_Option">NAMELEN</a>=n</DT>
<DT><A HREF="#NEWFILES_Option">NEWFILES</a></DT>
<DT><A HREF="#NOAUTODATA_Option">NOAUTODATA</a></DT>
<DT><A HREF="#NODEFAULTLIBS_Option">NODEFAULTLIBS</a></DT>
<DT><A HREF="#NOEXTENSION_Option">NOEXTENSION</a></DT>
<DT><A HREF="#NOSTUB_Option">NOSTUB</a></DT>
<DT><A HREF="#OFFSET_M_OSD2__Win32__ELF_only">OFFSET</a>=n</DT>
<DT><A HREF="#OLDLIBRARY_Option">OLDLIBRARY</a>=dll_name</DT>
<DT><A HREF="#ONEAUTODATA_Option">ONEAUTODATA</a></DT>
<DT><A HREF="#OSNAME_Option">OSNAME</a>='string'</DT>
<DT><A HREF="#PACKCODE_Option">PACKCODE</a>=n</DT>
<DT><A HREF="#PACKDATA_Option">PACKDATA</a>=n</DT>
<DT><A HREF="#PROTMODE_Option">PROTMODE</a></DT>
<DT><A HREF="#QUIET_Option">QUIET</a></DT>
<DT>[NO]<A HREF="#REDEFSOK_Option">REDEFSOK</a></DT>
<DT><A HREF="#RESOURCE_Option">RESOURCE</a>=resource_file</DT>
<DT><A HREF="#SHOWDEAD_Option">SHOWDEAD</a></DT>
<DT><A HREF="#STACK_Option">STACK</a>=n</DT>
<DT><A HREF="#START_Option">START</a>=symbol_name</DT>
<DT><A HREF="#STATICS_Option">STATICS</a></DT>
<DT><A HREF="#STUB_Option">STUB</a>=stub_name</DT>
<DT><A HREF="#SYMFILE_Option">SYMFILE</a>[=symbol_file]</DT>
<DT><A HREF="#TOGGLERELOCS_Option">TOGGLERELOCS</a></DT>
<DT>[NO]<A HREF="#UNDEFSOK_Option">UNDEFSOK</a></DT>
<DT><A HREF="#VERBOSE_Option">VERBOSE</a></DT>
<DT><A HREF="#VERSION_Option">VERSION</a>=major[.minor]</DT>
<DT><A HREF="#VFREMOVAL_Option">VFREMOVAL</a></DT>
</DL></DT>
<DT><A HREF="#OPTLIB_Directive">OPTLIB</a> library_file{,library_file}</DT>
<DT><A HREF="#ORDER_Directive">ORDER</a> CLNAME class_name [class_options]</DT>
<DT><A HREF="#OUTPUT_Directive">OUTPUT</a> RAW | HEX [options]</DT>
<DT><A HREF="#REFERENCE_Directive">REFERENCE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SEGMENT_Directive">SEGMENT</a> seg_desc{,seg_desc}</DT>
<DT><A HREF="#SORT_Directive">SORT</a> [GLOBAL] [ALPHABETICAL]</DT>
<DT><A HREF="#STARTLINK_Directive">STARTLINK</a></DT>
<DT><A HREF="#SYMTRACE_Directive">SYMTRACE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> BEGIN system_name {directive} END</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> system_name</DT>
<DT><A HREF="#hash_Directive">#</a> comment</DT>
<DT><A HREF="#atsign_Directive">@</a> directive_file</DT>
</DL>
<P>You can view all the directives specific to OS/2 executable files by simply typing the following:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink ? os2</TT>

<H2 ID="OSD2__Dynamic_Link_Libraries"> OS/2:&nbsp; Dynamic Link Libraries </H2>
JWlink can generate two forms of executable files; program modules and Dynamic Link Libraries.&nbsp; A program
module is the executable file that gets loaded by the operating system when you run your application.&nbsp; A Dynamic Link
Library is really a library of routines that are called by a program module but not linked into the program module.&nbsp;
The executable code in a Dynamic Link Library is loaded by the operating system during the execution of a program module when
a routine in the Dynamic Link Library is called.
<P>Program modules are contained in files whose name has a file extension of &quot;exe&quot;.&nbsp; Dynamic Link Libraries
are contained in files whose name has a file extension of &quot;dll&quot;.&nbsp; JWlink &quot;FORMAT&quot;
directive can be used to select the type of executable file to be generated.
<P>Let us consider some of the advantages of using Dynamic Link Libraries over standard libraries.
<OL>
<P><LI>Functions in Dynamic Link Libraries are not linked into your program.&nbsp; Only references to the functions in Dynamic
Link Libraries are placed in the program module.&nbsp; These references are called import definitions.&nbsp; As a result,
the linking time is reduced and disk space is saved.&nbsp; If many applications reference the same Dynamic Link Library, the
saving in disk space can be significant.
<P><LI>Since program modules only reference Dynamic Link Libraries and do not contain the actual executable code, a Dynamic
Link Library can be updated without re-linking your application.&nbsp; When your application is executed, it will use the
updated version of the Dynamic Link Library.
<P><LI>Dynamic Link Libraries also allow sharing of code and data between the applications that use them.&nbsp; If many applications
that use the same Dynamic Link Library are executing concurrently, the sharing of code and data segments improves memory utilization.
</OL>
<H3 ID="OSD2__Creating_a_Dynamic_Link_Library"> OS/2:&nbsp; Creating a Dynamic Link Library </H3>
To create a Dynamic Link Library, you must place the DLL keyword following the name in a <A HREF="#FORMAT_Directive">FORMAT</A> directive.
Or, if the <A HREF="#SYSTEM_Directive">SYSTEM</A> directive is used, a &quot;_dll&quot;-suffix will do it:
directive.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; system os2v2_dll</TT>
<P>In addition, you must specify which functions in the Dynamic Link Library are to be made available to applications which
use it.&nbsp; This is achieved by using the <A HREF="#EXPORT_Directive">EXPORT</A> directive for each function that can be called by an application.
<P>Dynamic Link Libraries can reference other Dynamic Link Libraries.&nbsp; References to other Dynamic Link Libraries are
resolved by specifying <A HREF="#IMPORT_Directive">IMPORT</A> directives or using import libraries.

<H3 ID="OSD2__Using_a_Dynamic_Link_Library"> Using a Dynamic Link Library in OS/2 </H3>
<P>To use a Dynamic Link Library, you must tell JWlink which functions are contained in a Dynamic Link Library
and the name of the Dynamic Link Library.&nbsp; This is achieved in two ways.
<P>The first method is to use the <A HREF="#IMPORT_Directive">IMPORT</A> directive.&nbsp;
This directive names the function and the Dynamic Link Library it belongs to so that JWlink can generate an import definition in the program
module.
<P>The second method is to use import libraries.&nbsp; An import library is a standard library which contains object modules
with special object records that define the functions belonging to a Dynamic Link Library.&nbsp; An import library is created
from a Dynamic Link Library using a Library Manager ([J]WLIB, LIB, ...).&nbsp; The resulting import library can then be specified
in a <A HREF="#LIBRARY_Directive">LIBRARY</A> directive in the same way one would specify a standard library.

<P>Using an import library is the preferred method of providing references to functions in Dynamic Link Libraries.&nbsp; When
a Dynamic Link Library is modified, typically the import library corresponding to the modified Dynamic Link Library is updated
to reflect the changes.&nbsp; Hence, any directive file that specifies the import library in a <A HREF="#LIBRARY_Directive">LIBRARY</A> directive
need not be modified.&nbsp; However, if you are using <A HREF="#IMPORT_Directive">IMPORT</A> directives, you may have to modify the
directives to reflect the changes in the Dynamic Link Library.

<H1 ID="Phar_Lap__The_Phar_Lap_Executable_File_Format"> Phar Lap:&nbsp; The Phar Lap Executable File Format </H1>
<P>This chapter deals specifically with aspects of Phar Lap 386|DOS-Extender executable files.&nbsp; The Phar Lap executable
file format will run under the following operating systems.
<OL>
<LI>Phar Lap's 386|DOS-Extender
<LI>Open Watcom's 32-bit Windows supervisor (relocatable format only)
</OL>
<P>Input to JWlink is specified on the command line and can be redirected to one or more files or environment
strings.&nbsp; JWlink command line format is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; JWLINK {directive}</TT>
<P>where<B><I> directive</I></B> is any of the following:
<DL>
<DT><A HREF="#ALIAS_Directive">ALIAS</A> alias_name=symbol_name{,alias_name=symbol_name}</DT>
<DT><A HREF="#DEBUG_Directive">DEBUG</A> dbtype [dblist] | DEBUG [dblist]</DT>
<DT><A HREF="#DISABLE_Directive">DISABLE</A> msg_num{,msg_num}</DT>
<DT><A HREF="#ENDLINK_Directive">ENDLINK</A></DT>
<DT><A HREF="#FILE_Directive">FILE</A> obj_spec{,obj_spec}</DT>
<DT><A HREF="#FORMAT_Directive">FORMAT</A> PHARLAP [EXTENDED | REX | SEGMENTED]</DT>
<DT><A HREF="#LANGUAGE_Directive">LANGUAGE</A> lang</DT>
<DT><A HREF="#LIBFILE_Directive">LIBFILE</A> obj_file{,obj_file}</DT>
<DT><A HREF="#LIBPATH_Directive">LIBPATH</A> path_name{;path_name}</DT>
<DT><A HREF="#LIBRARY_Directive">LIBRARY</A> library_file{,library_file}</DT>
<DT><A HREF="#MODFILE_Directive">MODFILE</A> obj_file{,obj_file}</DT>
<DT><A HREF="#MODTRACE_Directive">MODTRACE</A> obj_module{,obj_module}</DT>
<DT><A HREF="#NAME_Directive">NAME</A> exe_file</DT>
<DT><A HREF="#OPTION_Directive">OPTION</A> option{,option}
<DL>
<DT><A HREF="#ARTIFICIAL_Option">ARTIFICIAL</A></DT>
<DT>[NO]<A HREF="#CACHE_Option">CACHE</A></DT>
<DT>[NO]<A HREF="#CASEEXACT_Option">CASEEXACT</A></DT>
<DT><A HREF="#CVPACK_Option">CVPACK</A></DT>
<DT><A HREF="#DOSSEG_Option">DOSSEG</A></DT>
<DT><A HREF="#ELIMINATE_Option">ELIMINATE</A></DT>
<DT>[NO]<A HREF="#FARCALLS_Option">FARCALLS</A></DT>
<DT><A HREF="#INCREMENTAL_Option">INCREMENTAL</A></DT>
<DT><A HREF="#MANGLEDNAMES_Option">MANGLEDNAMES</A></DT>
<DT><A HREF="#MAP_Option">MAP</A>[=map_file]</DT>
<DT><A HREF="#MAXDATA_Option">MAXDATA</A>=n</DT>
<DT><A HREF="#MAXERRORS_Option">MAXERRORS</A>=n</DT>
<DT><A HREF="#MINDATA_Option">MINDATA</A>=n</DT>
<DT><A HREF="#NAMELEN_Option">NAMELEN</A>=n</DT>
<DT><A HREF="#NODEFAULTLIBS_Option">NODEFAULTLIBS</A></DT>
<DT><A HREF="#NOEXTENSION_Option">NOEXTENSION</A></DT>
<DT><A HREF="#OFFSET_M_Pharlap_only">OFFSET</A>=n</DT>
<DT><A HREF="#OSNAME_Option">OSNAME</A>='string'</DT>
<DT><A HREF="#QUIET_Option">QUIET</A></DT>
<DT>[NO]<A HREF="#REDEFSOK_Option">REDEFSOK</A></DT>
<DT><A HREF="#SHOWDEAD_Option">SHOWDEAD</A></DT>
<DT><A HREF="#STACK_Option">STACK</A>=n</DT>
<DT><A HREF="#START_Option">START</A>=symbol_name</DT>
<DT><A HREF="#STATICS_Option">STATICS</A></DT>
<DT><A HREF="#SYMFILE_Option">SYMFILE</A>[=symbol_file]</DT>
<DT>[NO]<A HREF="#UNDEFSOK_Option">UNDEFSOK</A></DT>
<DT><A HREF="#VERBOSE_Option">VERBOSE</A></DT>
<DT><A HREF="#VFREMOVAL_Option">VFREMOVAL</A></DT>
</DL></DT>
<DT><A HREF="#OPTLIB_Directive">OPTLIB</A> library_file{,library_file}</DT>
<DT><A HREF="#ORDER_Directive">ORDER</a> CLNAME class_name [class_options]</DT>
<DT><A HREF="#OUTPUT_Directive">OUTPUT</a> RAW | HEX [options]</DT>
<DT><A HREF="#PATH_Directive">PATH</A> path_name{;path_name}</DT>
<DT><A HREF="#REFERENCE_Directive">REFERENCE</A> symbol_name{,symbol_name}</DT>
<DT><A HREF="#RUNTIME_M_Pharlap_only">RUNTIME</A> run_option{,run_option}</DT>
<DT><A HREF="#SORT_Directive">SORT</A> [GLOBAL] [ALPHABETICAL]</DT>
<DT><A HREF="#STARTLINK_Directive">STARTLINK</A></DT>
<DT><A HREF="#SYMTRACE_Directive">SYMTRACE</A> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</A> BEGIN system_name {directive} END</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</A> system_name</DT>
<DT><A HREF="#hash_Directive">#</A> comment</DT>
<DT><A HREF="#atsign_Directive">@</A> directive_file</DT>
</DL>
<P>You can view all the directives specific to Phar Lap 386|DOS-Extender executable files by simply typing the following:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink ? phar</TT>

<H2 ID="Phar_Lap__32Mbit_ProtectedMMode_Applications"> Phar Lap:&nbsp; 32-bit Protected-Mode Applications </H2>
JWlink generates executable files that run under Phar Lap's 386|DOS-Extender.&nbsp; 386|DOS-Extender provides
a 32-bit protected-mode environment for programs running under PC DOS.&nbsp; Running in 32-bit protected mode allows your
program to access all of the memory in your machine.
<P>Essentially, what 386|DOS-Extender does is provide an interface between your application and DOS running in real mode.
&nbsp;Whenever your program issues a software interrupt (DOS and BIOS system calls), 386|DOS-Extender intercepts the requests,
transfers data between the protected-mode and real-mode address space, and calls the corresponding DOS system function running
in real mode.
<H2 ID="Phar_Lap__Memory_Usage"> Phar Lap:&nbsp; Memory Usage </H2>
<P>When running a program under 386|DOS-Extender, memory for the program is allocated from conventional memory (memory below
one megabyte) and extended memory.&nbsp; Conventional memory is allocated from a block of memory that is obtained from DOS
by 386|DOS-Extender at initialization time.&nbsp; By default, all available memory is allocated at initialization time; no
conventional memory remains free.&nbsp; The &quot;MINREAL&quot; and &quot;MAXREAL&quot; options of the &quot;RUNTIME&quot;
directive control the amount of conventional memory initially left free by 386|DOS-Extender.
<P>Part of the conventional memory allocated at initialization is required by 386|DOS-Extender.&nbsp; The following is allocated
from conventional memory for use by 386|DOS-Extender.
<OL>
<P><LI>A data buffer is allocated and is used to pass data to DOS and BIOS system functions.&nbsp; The size allocated is controlled
by the &quot;MINIBUF&quot; and &quot;MAXIBUF&quot; options of the &quot;RUNTIME&quot; directive.
<P><LI>Stack space is allocated and is used for switching between 32-bit protected mode and real mode.&nbsp; The size allocated
is controlled by the &quot;NISTACK&quot; and &quot;ISTKSIZE&quot; options of the &quot;RUNTIME&quot; directive.
<P><LI>A call buffer is allocated and is used for passing data on function calls between 32-bit protected mode and real mode.
&nbsp;The size allocated is controlled by the &quot;CALLBUFS&quot; option of the &quot;RUNTIME&quot; directive.
</OL>
<P>When a program is loaded by 386|DOS-Extender, memory to hold the entire program is allocated.&nbsp; In addition, memory
beyond the end of the program is allocated for use by the program.&nbsp; By default, all extra memory is allocated when the
program is loaded.&nbsp; It is assumed that any memory not required by the program is freed by the program.&nbsp; The amount
of memory allocated at the end of the program is controlled by the &quot;MINDATA&quot; and &quot;MAXDATA&quot; options.

<H2 ID="Phar_Lap__JWlink_Memory_Requirements"> Phar Lap:&nbsp; JWlink Memory Requirements </H2>
<P>JWlink uses all available memory when linking an application.&nbsp; It is possible for the size of the image being
linked to exceed the amount of memory available in your machine, particularly if the image file is to contain debugging information.
&nbsp;For this reason, a temporary disk file is used when all available memory is used by JWlink.
<P>Normally, the temporary file is created in the current working directory.&nbsp; However, by defining the &quot;tmp&quot;
environment variable to be a directory, you can tell JWlink where to create the temporary file.&nbsp; This
can be particularly useful if you have a RAM disk.&nbsp; Consider the following definition of the &quot;tmp&quot; environment
variable.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; set tmp=\tmp</TT>
<P>JWlink will create the temporary file in the directory &quot;\tmp&quot;.

<H1 ID="QNX__The_QNX_Executable_File_Format"> QNX:&nbsp; The QNX Executable File Format </H1>
<P>This chapter deals specifically with aspects of QNX executable files.&nbsp; The QNX executable file format will only run
under the QNX operating system.
<P>Input to JWlink is specified on the command line and can be redirected to one or more files or environment
strings.&nbsp; JWlink command line format is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink {directive}</TT>
<P>where<B><I> directive</I></B> is any of the following:
<DL>
<DT><A HREF="#ALIAS_Directive">ALIAS</A> symbol_name=symbol_name{,symbol_name=symbol_name}</DT>
<DT><A HREF="#DEBUG_Directive">DEBUG</A> dbtype [dblist] | DEBUG [dblist]</DT>
<DT><A HREF="#DISABLE_Directive">DISABLE</A> msg_num{,msg_num}</DT>
<DT><A HREF="#ENDLINK_Directive">ENDLINK</A></DT>
<DT><A HREF="#FILE_Directive">FILE</A> obj_spec{,obj_spec}</DT>
<DT><A HREF="#FORMAT_Directive">FORMAT</A> QNX [FLAT]</DT>
<DT><A HREF="#LANGUAGE_Directive">LANGUAGE</A></DT>
<DT><A HREF="#LIBFILE_Directive">LIBFILE</A> obj_file{,obj_file}</DT>
<DT><A HREF="#LIBPATH_Directive">LIBPATH</A> path_name{:path_name}</DT>
<DT><A HREF="#LIBRARY_Directive">LIBRARY</A> library_file{,library_file}</DT>
<DT><A HREF="#MODFILE_Directive">MODFILE</A> obj_file{,obj_file}</DT>
<DT><A HREF="#MODTRACE_Directive">MODTRACE</A> obj_spec{,obj_spec}</DT>
<DT><A HREF="#NAME_Directive">NAME</A> exe_file</DT>
<DT><A HREF="#NEWSEGMENT_Directive">NEWSEGMENT</A></DT>
<DT><A HREF="#OPTION_Directive">OPTION</A> option{,option}
<DL>
<DT><A HREF="#ARTIFICIAL_Option">ARTIFICIAL</A></DT>
<DT>[NO]<A HREF="#CACHE_Option">CACHE</A></DT>
<DT>[NO]<A HREF="#CASEEXACT_Option">CASEEXACT</A></DT>
<DT><A HREF="#CVPACK_Option">CVPACK</A></DT>
<DT><A HREF="#DOSSEG_Option">DOSSEG</A></DT>
<DT><A HREF="#ELIMINATE_Option">ELIMINATE</A></DT>
<DT>[NO]<A HREF="#FARCALLS_Option">FARCALLS</A></DT>
<DT><A HREF="#HEAPSIZE_Option">HEAPSIZE</A>=n</DT>
<DT><A HREF="#INCREMENTAL_Option">INCREMENTAL</A></DT>
<DT><A HREF="#LINEARRELOCS_Option">LINEARRELOCS</A></DT>
<DT><A HREF="#LONGLIVED_Option">LONGLIVED</A></DT>
<DT><A HREF="#MANGLEDNAMES_Option">MANGLEDNAMES</A></DT>
<DT><A HREF="#MAP_Option">MAP</A>[=map_file]</DT>
<DT><A HREF="#MAXERRORS_Option">MAXERRORS</A>=n</DT>
<DT><A HREF="#NAMELEN_Option">NAMELEN</A>=n</DT>
<DT><A HREF="#NODEFAULTLIBS_Option">NODEFAULTLIBS</A></DT>
<DT><A HREF="#NOEXTENSION_Option">NOEXTENSION</A></DT>
<DT><A HREF="#NORELOCS_Option">NORELOCS</A></DT>
<DT><A HREF="#OFFSET_M_QNX_only">OFFSET</A>=n</DT>
<DT><A HREF="#OSNAME_Option">OSNAME</A>='string'</DT>
<DT><A HREF="#PACKCODE_Option">PACKCODE</A>=n</DT>
<DT><A HREF="#PACKDATA_Option">PACKDATA</A>=n</DT>
<DT><A HREF="#PRIVILEGE_Option">PRIVILEGE</A>=n</DT>
<DT><A HREF="#QUIET_Option">QUIET</A></DT>
<DT>[NO]<A HREF="#REDEFSOK_Option">REDEFSOK</A></DT>
<DT><A HREF="#RESOURCE_Option">RESOURCE</A>[=resource_file | 'string']</DT>
<DT><A HREF="#SHOWDEAD_Option">SHOWDEAD</A></DT>
<DT><A HREF="#STACK_Option">STACK</A>=n</DT>
<DT><A HREF="#START_Option">START</A>=symbol_name</DT>
<DT><A HREF="#STATICS_Option">STATICS</A></DT>
<DT><A HREF="#SYMFILE_Option">SYMFILE</A>[=symbol_file]</DT>
<DT>[NO]<A HREF="#UNDEFSOK_Option">UNDEFSOK</A></DT>
<DT><A HREF="#VERBOSE_Option">VERBOSE</A></DT>
<DT><A HREF="#VFREMOVAL_Option">VFREMOVAL</A></DT>
</DL></DT>
<DT><A HREF="#OPTLIB_Directive">OPTLIB</A> library_file{,library_file}</DT>
<DT><A HREF="#ORDER_Directive">ORDER</a> CLNAME class_name [class_options]</DT>
<DT><A HREF="#OUTPUT_Directive">OUTPUT</a> RAW | HEX [options]</DT>
<DT><A HREF="#PATH_Directive">PATH</A> path_name{:path_name}</DT>
<DT><A HREF="#REFERENCE_Directive">REFERENCE</A> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SEGMENT_Directive">SEGMENT</A> seg_desc{,seg_desc}</DT>
<DT><A HREF="#SORT_Directive">SORT</A> [GLOBAL] [ALPHABETICAL]</DT>
<DT><A HREF="#STARTLINK_Directive">STARTLINK</A></DT>
<DT><A HREF="#SYMTRACE_Directive">SYMTRACE</A> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</A> BEGIN system_name {directive} END</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</A> system_name</DT>
<DT><A HREF="#hash_Directive">#</A> comment</DT>
<DT><A HREF="#atsign_Directive">@</A> directive_file</DT>
</DL>
<P>You can view all the directives specific to QNX executable files by simply typing the following:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink ? qnx</TT>

<H1 ID="Win16_Executable_and_DLL_File_Formats"> Win16 Executable and DLL File Formats </H1>
<P>This chapter deals specifically with aspects of Win16 executable files.&nbsp; The Win16 executable file format will run
under Windows 3.x, Windows 9x/ME and Windows NT/2k/XP/Vista/7.
<P>Input to JWlink is specified on the command line and can be redirected to one or more files or environment
strings.&nbsp; JWlink command line format is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; JWLINK {directive}</TT>
<P>where<B><I> directive</I></B> is any of the following:
<DL>
<DT><A HREF="#ALIAS_Directive">ALIAS</a> alias_name=symbol_name{,alias_name=symbol_name}</DT>
<DT><A HREF="#ANONYMOUSEXPORT_Directive">ANONYMOUSEXPORT</a> export{,export} | =lbc_file</DT>
<DT><A HREF="#DEBUG_Directive">DEBUG</a> dbtype [dblist] | DEBUG [dblist]</DT>
<DT><A HREF="#DISABLE_Directive">DISABLE</a> msg_num{,msg_num}</DT>
<DT><A HREF="#ENDLINK_Directive">ENDLINK</a></DT>
<DT><A HREF="#EXPORT_M_OSD2__Win16__Win32_only">EXPORT</a> export{,export}</DT>
<DT><A HREF="#EXPORT_Directive">EXPORT</a> =lbc_file</DT>
<DT><A HREF="#FILE_Directive">FILE</a> obj_spec{,obj_spec}</DT>
<DT><A HREF="#FORMAT_Directive">FORMAT</a> WINDOWS [dll_form] [MEMORY] [FONT] [DPMI]</DT>
<DT><A HREF="#IMPORT_M_OSD2__Win16__Win32_only">IMPORT</a> import{,import}</DT>
<DT><A HREF="#LANGUAGE_Directive">LANGUAGE</a> lang</DT>
<DT><A HREF="#LIBFILE_Directive">LIBFILE</a> obj_file{,obj_file}</DT>
<DT><A HREF="#LIBPATH_Directive">LIBPATH</a> path_name{;path_name}</DT>
<DT><A HREF="#LIBRARY_Directive">LIBRARY</a> library_file{,library_file}</DT>
<DT><A HREF="#MODFILE_Directive">MODFILE</a> obj_file{,obj_file}</DT>
<DT><A HREF="#MODTRACE_Directive">MODTRACE</a> obj_module{,obj_module}</DT>
<DT><A HREF="#NAME_Directive">NAME</a> exe_file</DT>
<DT><A HREF="#NEWSEGMENT_Directive">NEWSEGMENT</a></DT>
<DT><A HREF="#PATH_Directive">PATH</a> path_name{;path_name}</DT>
<DT><A HREF="#OPTION_Directive">OPTION</a> option{,option}
<DL>
<DT><A HREF="#ALIGNMENT_Option">ALIGNMENT</a>=n</DT>
<DT><A HREF="#ARTIFICIAL_Option">ARTIFICIAL</a></DT>
<DT>[NO]<A HREF="#CACHE_Option">CACHE</a></DT>
<DT>[NO]<A HREF="#CASEEXACT_Option">CASEEXACT</a></DT>
<DT><A HREF="#CVPACK_Option">CVPACK</a></DT>
<DT><A HREF="#DESCRIPTION_Option">DESCRIPTION</a> 'string'</DT>
<DT><A HREF="#DOSSEG_Option">DOSSEG</a></DT>
<DT><A HREF="#ELIMINATE_Option">ELIMINATE</a></DT>
<DT>[NO]<A HREF="#FARCALLS_Option">FARCALLS</a></DT>
<DT><A HREF="#HEAPSIZE_Option">HEAPSIZE</a>=n</DT>
<DT><A HREF="#IMPFILE_Option">IMPFILE</a>[=imp_file]</DT>
<DT><A HREF="#IMPLIB_Option">IMPLIB</a>[=imp_lib]</DT>
<DT><A HREF="#INCREMENTAL_Option">INCREMENTAL</a></DT>
<DT><A HREF="#MANGLEDNAMES_Option">MANGLEDNAMES</a></DT>
<DT><A HREF="#MANYAUTODATA_Option">MANYAUTODATA</a></DT>
<DT><A HREF="#MAP_Option">MAP</a>[=map_file]</DT>
<DT><A HREF="#MAXERRORS_Option">MAXERRORS</a>=n</DT>
<DT><A HREF="#MODNAME_Option">MODNAME</a>=module_name</DT>
<DT><A HREF="#NAMELEN_Option">NAMELEN</a>=n</DT>
<DT><A HREF="#NOAUTODATA_Option">NOAUTODATA</a></DT>
<DT><A HREF="#NODEFAULTLIB_Option">NODEFAULTLIBS</a></DT>
<DT><A HREF="#NOEXTENSION_Option">NOEXTENSION</a></DT>
<DT><A HREF="#NOSTUB_Option">NOSTUB</a></DT>
<DT><A HREF="#OLDLIBRARY_Option">OLDLIBRARY</a>=dll_name</DT>
<DT><A HREF="#ONEAUTODATA_Option">ONEAUTODATA</a></DT>
<DT><A HREF="#OSNAME_Option">OSNAME</a>='string'</DT>
<DT><A HREF="#PACKCODE_Option">PACKCODE</a>=n</DT>
<DT><A HREF="#PACKDATA_Option">PACKDATA</a>=n</DT>
<DT><A HREF="#PROTMODE_Option">PROTMODE</a></DT>
<DT><A HREF="#QUIET_Option">QUIET</a></DT>
<DT>[NO]<A HREF="#REDEFSOK_Option">REDEFSOK</a></DT>
<DT><A HREF="#RESOURCE_Option">RESOURCE</a>=resource_file</DT>
<DT><A HREF="#RWRELOCCHECK_Option">RWRELOCCHECK</a></DT>
<DT><A HREF="#SHOWDEAD_Option">SHOWDEAD</a></DT>
<DT><A HREF="#STACK_Option">STACK</a>=n</DT>
<DT><A HREF="#START_Option">START</a>=symbol_name</DT>
<DT><A HREF="#STATICS_Option">STATICS</a></DT>
<DT><A HREF="#STUB_Option">STUB</a>=stub_name</DT>
<DT><A HREF="#SYMFILE_Option">SYMFILE</a>[=symbol_file]</DT>
<DT>[NO]<A HREF="#UNDEFSOK_Option">UNDEFSOK</a></DT>
<DT><A HREF="#VERBOSE_Option">VERBOSE</a></DT>
<DT><A HREF="#VERSION_Option">VERSION</a>=major[.minor]</DT>
<DT><A HREF="#VFREMOVAL_Option">VFREMOVAL</a></DT>
</DL></DT>
<DT><A HREF="#OPTLIB_Directive">OPTLIB</a> library_file{,library_file}</DT>
<DT><A HREF="#ORDER_Directive">ORDER</a> CLNAME class_name [class_options]</DT>
<DT><A HREF="#OUTPUT_Directive">OUTPUT</a> RAW | HEX [options]</DT>
<DT><A HREF="#REFERENCE_Directive">REFERENCE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SEGMENT_Directive">SEGMENT</a> seg_desc{,seg_desc}</DT>
<DT><A HREF="#SORT_Directive">SORT</a> [GLOBAL] [ALPHABETICAL]</DT>
<DT><A HREF="#STARTLINK_Directive">STARTLINK</a></DT>
<DT><A HREF="#SYMTRACE_Directive">SYMTRACE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> BEGIN system_name {directive} END</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> system_name</DT>
<DT><A HREF="#hash_Directive">#</a> comment</DT>
<DT><A HREF="#atsign_Directive">@</a> directive_file</DT>
</DL>
<P>You can view all the directives specific to Win16 executable files by simply typing the following:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink ? win</TT>

<H2 ID="Win16__Fixed_and_Moveable_Segments"> Fixed and Moveable Segments in Win16 Binaries </H2>
All segments have attributes that tell Windows how to manage the segment.&nbsp; One of these attributes specifies whether
the segment is fixed or moveable.&nbsp; Moveable segments can be moved in memory to satisfy other memory requests.&nbsp; When
a segment is moved, all near pointers to that segment are still valid since a near pointer references memory relative to the
start of the segment.&nbsp; However, far pointers are no longer valid once a segment has been moved.&nbsp; Fixed segments,
on the other hand, cannot be moved in memory.&nbsp; A segment must be fixed if there exists far pointers to that segment that
Windows cannot adjust if that segment were moved.
<P>This is a memory-management issue for real-mode Windows only.&nbsp; However, if a DLL is marked as &quot;fixed&quot;, Windows
3.x will place it in the lower 640K real-mode memory (regardless of the mode in which Windows 3.x is running).&nbsp; Since
the lower 640K is a limited resource, you normally would want a DLL to be marked as &quot;moveable&quot;.
<P>Most segments, including code and data segments, are moveable.&nbsp; Some exceptions exist.&nbsp; If your program contains
a far pointer, the segment which it references must be fixed.&nbsp; If it were moveable, the segment address portion of the
far pointer would be invalid when Windows moved the segment.
<P>All non-Windows programs are assigned fixed segments when they run under Windows.&nbsp; These segments must be fixed since
there is no information in the executable file that describes how segments are referenced.&nbsp; Whenever possible, your application
should consist of moveable segments since fixed segments can cause memory management problems.
<P>For details about available segment attributes, see the <A HREF="#SEGMENT_Directive">SEGMENT</A> directive.


<H2 ID="Win16__Discardable_Segments"> Discardable Segments in Win16 Binaries </H2>
<P>Moveable segments can also be discardable.&nbsp; Memory allocated to a discardable segment can be freed and used for other
memory requests.&nbsp; A &quot;least recently used&quot; (LRU) algorithm is used to determine which segment to discard when
more memory is required.
<P>Discardable segments are usually segments that do not change once they are loaded into memory.&nbsp; For example, code
segments are discardable since programs do not usually modify their code segments.&nbsp; When a segment is discarded, it can
be reloaded into memory by accessing the executable file.
<P>Discardable segments must be moveable since they can be reloaded into a different area in memory than the area they previously
occupied.&nbsp; Note that moveable segments need not be discardable.&nbsp; Obviously, data segments that contain read/write
data cannot be discarded.

<H2 ID="Win16__Dynamic_Link_Libraries"> Dynamic Link Libraries for Win16 </H2>
<P>JWlink can generate two forms of executable files; program modules and Dynamic Link Libraries.&nbsp; A
program module is the executable file that gets loaded by the operating system when you run your application.&nbsp; A Dynamic
Link Library is really a library of routines that are called by a program module but not linked into the program module.&nbsp;
The executable code in a Dynamic Link Library is loaded by the operating system during the execution of a program module when
a routine in the Dynamic Link Library is called.
<P>Program modules are contained in files whose name has a file extension of &quot;exe&quot;.&nbsp; Dynamic Link Libraries
are contained in files whose name has a file extension of &quot;dll&quot;.&nbsp; The <A HREF="#FORMAT_Directive">FORMAT</A>
or <A HREF="#SYSTEM_Directive">SYSTEM</A> directives can be used to select the type of executable file to be generated.
<P>Let us consider some of the advantages of using Dynamic Link Libraries over standard libraries.
<OL>
<P><LI>Functions in Dynamic Link Libraries are not linked into your program.&nbsp; Only references to the functions in Dynamic
Link Libraries are placed in the program module.&nbsp; These references are called import definitions.&nbsp; As a result,
the linking time is reduced and disk space is saved.&nbsp; If many applications reference the same Dynamic Link Library, the
saving in disk space can be significant.
<P><LI>Since program modules only reference Dynamic Link Libraries and do not contain the actual executable code, a Dynamic
Link Library can be updated without re-linking your application.&nbsp; When your application is executed, it will use the
updated version of the Dynamic Link Library.
<P><LI>Dynamic Link Libraries also allow sharing of code and data between the applications that use them.&nbsp; If many applications
that use the same Dynamic Link Library are executing concurrently, the sharing of code and data segments improves memory utilization.
</OL>

<H3 ID="Win16__Creating_a_Dynamic_Link_Library"> Creating a Dynamic Link Library for Win16 </H3>
To create a Dynamic Link Library, you must place the DLL keyword behind a <A HREF="#FORMAT_Directive">FORMAT</A> directive.
Or, if the <A HREF="#SYSTEM_Directive">SYSTEM</A> directive is used, a &quot;_dll&quot;-suffix will do it:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; system win16_dll</TT>
<P>In addition, you must specify which functions in the Dynamic Link Library are to be made available to applications which
use it.&nbsp; This is achieved by using the <A HREF="#EXPORT_Directive">EXPORT</A> directive for each function that can be called by an application.
<P>Dynamic Link Libraries can reference other Dynamic Link Libraries.&nbsp; References to other Dynamic Link Libraries are
resolved by specifying <A HREF="#IMPORT_Directive">IMPORT</A> directives or using import libraries.

<H3 ID="Win16__Using_a_Dynamic_Link_Library"> Using a Dynamic Link Library in Win16 </H3>
<P>To use a Dynamic Link Library, you must tell JWlink which functions are contained in a Dynamic Link Library
and the name of the Dynamic Link Library.&nbsp; This is achieved in two ways.
<P>The first method is to use the <A HREF="#IMPORT_Directive">IMPORT</A> directive.&nbsp; This directive names the function
and the Dynamic Link Library it belongs to so that JWlink can generate an import definition in the program
module.
<P>The second method is to use import libraries.&nbsp; An import library is a standard library which contains object modules
with special object records that define the functions belonging to a Dynamic Link Library.&nbsp; An import library is created
from a Dynamic Link Library using a Library Manager ([J]WLIB, LIB, ...).&nbsp; The resulting import library can then be specified
in a <A HREF="#LIBRARY_Directive">LIBRARY</A> directive in the same way one would specify a standard library.

<P>Using an import library is the preferred method of providing references to functions in Dynamic Link Libraries.&nbsp; When
a Dynamic Link Library is modified, typically the import library corresponding to the modified Dynamic Link Library is updated
to reflect the changes.&nbsp; Hence, any directive file that specifies the import library in a <A HREF="#LIBRARY_Directive">LIBRARY</A> directive
need not be modified.&nbsp; However, if you are using <A HREF="#IMPORT_Directive">IMPORT</A> directives, you may have to modify the
directives to reflect the changes in the Dynamic Link Library.

<H1 ID="Windows_Virtual_Device_Driver_File_Format"> Windows Virtual Device Driver File Format </H1>
<P>This chapter deals specifically with aspects of VxD executable files.
<P>Input to JWlink is specified on the command line and can be redirected to one or more files or environment
strings.&nbsp; JWlink command line format is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; JWLINK {directive}</TT>
<P>where<B><I> directive</I></B> is any of the following:
<DL>
<DT><A HREF="#ALIAS_Directive">ALIAS</a> alias_name=symbol_name{,alias_name=symbol_name}</DT>
<DT><A HREF="#DISABLE_Directive">DISABLE</a> msg_num{,msg_num}</DT>
<DT><A HREF="#ENDLINK_Directive">ENDLINK</a></DT>
<DT><A HREF="#EXPORT_Directive">EXPORT</a> export{,export}</DT>
<DT><A HREF="#EXPORT_Directive">EXPORT</a> =lbc_file</DT>
<DT><A HREF="#FILE_Directive">FILE</a> obj_spec{,obj_spec}</DT>
<DT><A HREF="#FORMAT_Directive">FORMAT</a> WINDOWS VXD [DYNAMIC]</DT>
<DT><A HREF="#LANGUAGE_Directive">LANGUAGE</a> lang</DT>
<DT><A HREF="#LIBFILE_Directive">LIBFILE</a> obj_file{,obj_file}</DT>
<DT><A HREF="#LIBPATH_Directive">LIBPATH</a> path_name{;path_name}</DT>
<DT><A HREF="#LIBRARY_Directive">LIBRARY</a> library_file{,library_file}</DT>
<DT><A HREF="#MODFILE_Directive">MODFILE</a> obj_file{,obj_file}</DT>
<DT><A HREF="#MODTRACE_Directive">MODTRACE</a> obj_module{,obj_module}</DT>
<DT><A HREF="#NAME_Directive">NAME</a> exe_file</DT>
<DT><A HREF="#PATH_Directive">PATH</a> path_name{;path_name}</DT>
<DT><A HREF="#OPTION_Directive">OPTION</a> option{,option}
<DL>
<DT><A HREF="#ALIGNMENT_Option">ALIGNMENT</a>=n</DT>
<DT><A HREF="#ARTIFICIAL_Option">ARTIFICIAL</a></DT>
<DT>[NO]<A HREF="#CACHE_Option">CACHE</a></DT>
<DT>[NO]<A HREF="#CASEEXACT_Option">CASEEXACT</a></DT>
<DT><A HREF="#DESCRIPTION_Option">DESCRIPTION</a> 'string'</DT>
<DT><A HREF="#ELIMINATE_Option">ELIMINATE</a></DT>
<DT>[NO]<A HREF="#FARCALLS_Option">FARCALLS</a></DT>
<DT><A HREF="#HEAPSIZE_Option">HEAPSIZE</a>=n</DT>
<DT><A HREF="#IMPFILE_Option">IMPFILE</a>[=imp_file]</DT>
<DT><A HREF="#IMPLIB_Option">IMPLIB</a>[=imp_lib]</DT>
<DT><A HREF="#INCREMENTAL_Option">INCREMENTAL</a></DT>
<DT><A HREF="#MANGLEDNAMES_Option">MANGLEDNAMES</a></DT>
<DT><A HREF="#MAP_Option">MAP</a>[=map_file]</DT>
<DT><A HREF="#MAXERRORS_Option">MAXERRORS</a>=n</DT>
<DT><A HREF="#MODNAME_Option">MODNAME</a>=module_name</DT>
<DT><A HREF="#NAMELEN_Option">NAMELEN</a>=n</DT>
<DT><A HREF="#NODEFAULTLIBS_Option">NODEFAULTLIBS</a></DT>
<DT><A HREF="#NOEXTENSION_Option">NOEXTENSION</a></DT>
<DT><A HREF="#NOSTUB_Option">NOSTUB</a></DT>
<DT><A HREF="#OSNAME_Option">OSNAME</a>='string'</DT>
<DT><A HREF="#QUIET_Option">QUIET</a></DT>
<DT>[NO]<A HREF="#REDEFSOK_Option">REDEFSOK</a></DT>
<DT><A HREF="#RESOURCE_Option">RESOURCE</a>=resource_file</DT>
<DT><A HREF="#SHOWDEAD_Option">SHOWDEAD</a></DT>
<DT><A HREF="#STACK_Option">STACK</a>=n</DT>
<DT><A HREF="#START_Option">START</a>=symbol_name</DT>
<DT><A HREF="#STATICS_Option">STATICS</a></DT>
<DT><A HREF="#STUB_Option">STUB</a>=stub_name</DT>
<DT><A HREF="#SYMFILE_Option">SYMFILE</a>[=symbol_file]</DT>
<DT>[NO]<A HREF="#UNDEFSOK_Option">UNDEFSOK</a></DT>
<DT><A HREF="#VERBOSE_Option">VERBOSE</a></DT>
<DT><A HREF="#VERSION_Option">VERSION</a>=major[.minor]</DT>
<DT><A HREF="#VFREMOVAL_Option">VFREMOVAL</a></DT>
</DL></DT>
<DT><A HREF="#OPTLIB_Directive">OPTLIB</a> library_file{,library_file}</DT>
<DT><A HREF="#ORDER_Directive">ORDER</a> CLNAME class_name [class_options]</DT>
<DT><A HREF="#OUTPUT_Directive">OUTPUT</a> RAW | HEX [options]</DT>
<DT><A HREF="#REFERENCE_Directive">REFERENCE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SEGMENT_Directive">SEGMENT</a> seg_desc{,seg_desc}</DT>
<DT><A HREF="#SORT_Directive">SORT</a> [GLOBAL] [ALPHABETICAL]</DT>
<DT><A HREF="#STARTLINK_Directive">STARTLINK</a></DT>
<DT><A HREF="#SYMTRACE_Directive">SYMTRACE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> BEGIN system_name {directive} END</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> system_name</DT>
<DT><A HREF="#hash_Directive">#</a> comment</DT>
<DT><A HREF="#atsign_Directive">@</a> directive_file</DT>
</DL>
<P>You can view all the directives specific to WinVxD executable files by simply typing the following:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink ? win vxd</TT>

<H1 ID="Win32_Executable_and_DLL_File_Formats"> Win32/Win64 Executable and DLL File Formats </H1>
<P>The <b>Win32</b> executable file format ( aka PE or PE32 format ) is the native format of Windows 9x/ME and Windows NT/2k/XP/Vista/7.
It may also run under Windows 3.x using the Win32S subsystem ( you are restricted to a subset of the Win32 API ).
Some DOS extenders - HX, WDOSX, Borland's RTM32 and Phar Lap's TNT - are also using the PE32 format.
<P>The <b>Win64</b> executable file format ( aka PE32+ format ) will only run on 64-bit versions of Windows.
<P>Input to JWlink is specified on the command line and can be redirected to one or more files or environment
strings.&nbsp; JWlink command line format is as follows.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; JWLINK {directive}</TT>
<P>where<B><I> directive</I></B> is any of the following:
<DL>
<DT><A HREF="#ALIAS_Directive">ALIAS</a> alias_name=symbol_name{,alias_name=symbol_name}</DT>
<DT><A HREF="#ANONYMOUSEXPORT_Directive">ANONYMOUSEXPORT</a> export{,export} | =lbc_file</DT>
<DT><A HREF="#COMMIT_Directive">COMMIT</a> mem_type</DT>
<DT><A HREF="#DEBUG_Directive">DEBUG</a> dbtype [dblist] | DEBUG [dblist]</DT>
<DT><A HREF="#DISABLE_Directive">DISABLE</a> msg_num{,msg_num}</DT>
<DT><A HREF="#ENDLINK_Directive">ENDLINK</a></DT>
<DT><A HREF="#EXPORT_M_OSD2__Win16__Win32_only">EXPORT</a> export{,export}</DT>
<DT><A HREF="#EXPORT_Directive">EXPORT</a> =lbc_file</DT>
<DT><A HREF="#FILE_Directive">FILE</a> obj_spec{,obj_spec}</DT>
<DT><A HREF="#FORMAT_Directive">FORMAT</a> WINDOWS PE [TNT|HX] [dll_form]</DT>
<DT><A HREF="#IMPORT_M_OSD2__Win16__Win32_only">IMPORT</a> import{,import}</DT>
<DT><A HREF="#LANGUAGE_Directive">LANGUAGE</a> lang</DT>
<DT><A HREF="#LIBFILE_Directive">LIBFILE</a> obj_file{,obj_file}</DT>
<DT><A HREF="#LIBPATH_Directive">LIBPATH</a> path_name{;path_name}</DT>
<DT><A HREF="#LIBRARY_Directive">LIBRARY</a> library_file{,library_file}</DT>
<DT><A HREF="#MODFILE_Directive">MODFILE</a> obj_file{,obj_file}</DT>
<DT><A HREF="#MODTRACE_Directive">MODTRACE</a> obj_module{,obj_module}</DT>
<DT><A HREF="#NAME_Directive">NAME</a> exe_file</DT>
<DT><A HREF="#PATH_Directive">PATH</a> path_name{;path_name}</DT>
<DT><A HREF="#OPTION_Directive">OPTION</a> option{,option}
<DL>
<DT><A HREF="#ALIGNMENT_Option">ALIGNMENT</a>=n</DT>
<DT><A HREF="#ARTIFICIAL_Option">ARTIFICIAL</a></DT>
<DT>[NO]<A HREF="#CACHE_Option">CACHE</a></DT>
<DT>[NO]<A HREF="#CASEEXACT_Option">CASEEXACT</a></DT>
<DT><A HREF="#CHECKSUM_Option">CHECKSUM</a></DT>
<DT><A HREF="#CVPACK_Option">CVPACK</a></DT>
<DT><A HREF="#DESCRIPTION_Option">DESCRIPTION</a> 'string'</DT>
<DT><A HREF="#DOSSEG_Option">DOSSEG</a></DT>
<DT><A HREF="#ELIMINATE_Option">ELIMINATE</a></DT>
<DT>[NO]<A HREF="#FARCALLS_Option">FARCALLS</a></DT>
<DT><A HREF="#FUZZYEXPORT_Option">FUZZYEXPORT</a></DT>
<DT><A HREF="#HEAPSIZE_Option">HEAPSIZE</a>=n</DT>
<DT><A HREF="#IMPFILE_Option">IMPFILE</a>[=imp_file]</DT>
<DT><A HREF="#IMPLIB_Option">IMPLIB</a>[=imp_lib]</DT>
<DT><A HREF="#INCREMENTAL_Option">INCREMENTAL</a></DT>
<DT>[<A HREF="#NOLARGEADDRESSAWARE_Option">NO</a>]<A HREF="#LARGEADDRESSAWARE_Option">LARGEADDRESSAWARE</a></DT>
<DT><A HREF="#LINKVERSION_Option">LINKVERSION</a>=major[.minor]</DT>
<DT><A HREF="#MANGLEDNAMES_Option">MANGLEDNAMES</a></DT>
<DT><A HREF="#MAP_Option">MAP</a>[=map_file]</DT>
<DT><A HREF="#MAXERRORS_Option">MAXERRORS</a>=n</DT>
<DT><A HREF="#MODNAME_Option">MODNAME</a>=module_name</DT>
<DT><A HREF="#NAMELEN_Option">NAMELEN</a>=n</DT>
<DT><A HREF="#NODEFAULTLIBS_Option">NODEFAULTLIBS</a></DT>
<DT><A HREF="#NOEXTENSION_Option">NOEXTENSION</a></DT>
<DT><A HREF="#NORELOCS_Option">NORELOCS</a></DT>
<DT><A HREF="#NOSTDCALL_Option">NOSTDCALL</a></DT>
<DT><A HREF="#NOSTUB_Option">NOSTUB</a></DT>
<DT><A HREF="#NXCOMPAT_Option">NXCOMPAT</a></DT>
<DT><A HREF="#OBJALIGN_Option">OBJALIGN</a>=n</DT>
<DT><A HREF="#OFFSET_M_OSD2__Win32__ELF_only">OFFSET</a>=n</DT>
<DT><A HREF="#OLDLIBRARY_Option">OLDLIBRARY</a>=dll_name</DT>
<DT><A HREF="#OSNAME_Option">OSNAME</a>='string'</DT>
<DT><A HREF="#OSVERSION_Option">OSVERSION</a>=major[.minor]</DT>
<DT><A HREF="#QUIET_Option">QUIET</a></DT>
<DT>[NO]<A HREF="#REDEFSOK_Option">REDEFSOK</a></DT>
<DT><A HREF="#RESOURCE_Option">RESOURCE</a>=resource_file</DT>
<DT><A HREF="#SHOWDEAD_Option">SHOWDEAD</a></DT>
<DT><A HREF="#STACK_Option">STACK</a>=n</DT>
<DT><A HREF="#START_Option">START</a>=symbol_name</DT>
<DT><A HREF="#STATICS_Option">STATICS</a></DT>
<DT><A HREF="#STUB_Option">STUB</a>=stub_name</DT>
<DT><A HREF="#SYMFILE_Option">SYMFILE</a>[=symbol_file]</DT>
<DT>[NO]<A HREF="#UNDEFSOK_Option">UNDEFSOK</a></DT>
<DT><A HREF="#VERBOSE_Option">VERBOSE</a></DT>
<DT><A HREF="#VERSION_Option">VERSION</a>=major[.minor]</DT>
<DT><A HREF="#VFREMOVAL_Option">VFREMOVAL</a></DT>
</DL></DT>
<DT><A HREF="#OPTLIB_Directive">OPTLIB</a> library_file{,library_file}</DT>
<DT><A HREF="#ORDER_Directive">ORDER</a> CLNAME class_name [class_options]</DT>
<DT><A HREF="#OUTPUT_Directive">OUTPUT</a> RAW | HEX [options]</DT>
<DT><A HREF="#PATH_Directive">PATH</a> path_name{;path_name}</DT>
<DT><A HREF="#REFERENCE_Directive">REFERENCE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#RUNTIME_M_Win32_only">RUNTIME</a> run_option</DT>
<DT><A HREF="#SEGMENT_Directive">SEGMENT</a> seg_desc{,seg_desc}</DT>
<DT><A HREF="#SORT_Directive">SORT</a> [GLOBAL] [ALPHABETICAL]</DT>
<DT><A HREF="#STARTLINK_Directive">STARTLINK</a></DT>
<DT><A HREF="#SYMTRACE_Directive">SYMTRACE</a> symbol_name{,symbol_name}</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> BEGIN system_name {directive} END</DT>
<DT><A HREF="#SYSTEM_Directive">SYSTEM</a> system_name</DT>
<DT><A HREF="#hash_Directive">#</a> comment</DT>
<DT><A HREF="#atsign_Directive">@</a> directive_file</DT>
</DL>
<P>You can view all the directives specific to Win32 executable files by simply typing the following:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; jwlink ? pe</TT>

<H2 ID="Win32__Dynamic_Link_Libraries"> Dynamic Link Libraries for Win32/Win64 </H2>
JWlink can generate two forms of Windows binaries; program modules and Dynamic Link Libraries.&nbsp; A program
module is the executable file that gets loaded by the operating system when you run your application.&nbsp; A Dynamic Link
Library is really a library of routines that are called by a program module but not linked into the program module.&nbsp;
The executable code in a Dynamic Link Library is loaded by the operating system during the execution of a program module when
a routine in the Dynamic Link Library is called.
<P>Program modules are contained in files whose name has a file extension of &quot;exe&quot;.&nbsp; Dynamic Link Libraries
are contained in files whose name has a file extension of &quot;dll&quot;.&nbsp; The <A HREF="#FORMAT_Directive">FORMAT</A>
or <A HREF="#SYSTEM_Directive">SYSTEM</A> directives can be used to select the type of executable file to be generated.
<P>Let us consider some of the advantages of using Dynamic Link Libraries over standard libraries.
<OL>
<P><LI>Functions in Dynamic Link Libraries are not linked into your program.&nbsp; Only references to the functions in Dynamic
Link Libraries are placed in the program module.&nbsp; These references are called import definitions.&nbsp; As a result,
the linking time is reduced and disk space is saved.&nbsp; If many applications reference the same Dynamic Link Library, the
saving in disk space can be significant.
<P><LI>Since program modules only reference Dynamic Link Libraries and do not contain the actual executable code, a Dynamic
Link Library can be updated without re-linking your application.&nbsp; When your application is executed, it will use the
updated version of the Dynamic Link Library.
<P><LI>Dynamic Link Libraries also allow sharing of code and data between the applications that use them.&nbsp; If many applications
that use the same Dynamic Link Library are executing concurrently, the sharing of code and data segments improves memory utilization.
</OL>
<H3 ID="Win32__Creating_a_Dynamic_Link_Library"> Creating a Dynamic Link Library for Win32/Win64 </H3>
To create a Dynamic Link Library, the keyword DLL must follow the format name in a <A HREF="#FORMAT_Directive">FORMAT</A>
directive. Alternatively, if a <A HREF="#SYSTEM_Directive">SYSTEM</A> directive is used, 
there's usually a "_dll" suffix to be appended to the system name:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; system pe_dll</TT>
<P>In addition, the functions in the dll that are to be called by other modules must be made publicly available.&nbsp;
This is achieved by using the <A HREF="#EXPORT_Directive">EXPORT</A> directive for each such function.
To create an import library to be used by applications that want to call the dll's functions,
see the <A HREF="#IMPLIB_Option">IMPLIB</A> Option.

<P>Dynamic Link Libraries can reference other Dynamic Link Libraries.&nbsp; References to other Dynamic Link Libraries are
resolved by specifying <A HREF="#IMPORT_Directive">IMPORT</A> directives or using import libraries.

<H3 ID="Win32__Using_a_Dynamic_Link_Library"> Using a Dynamic Link Library in Win32/Win64 </H3>
<P>To use a Dynamic Link Library, you must tell JWlink which functions are contained in a Dynamic Link Library
and the name of the Dynamic Link Library.&nbsp; This is achieved in two ways.
<P>The first method is to use the <A HREF="#IMPORT_Directive">IMPORT</A> directive.&nbsp; This directive names the function
and the Dynamic Link Library it belongs to so that JWlink can generate an import definition in the program
module.
<P>The second method is to use import libraries.&nbsp; An import library is a standard library which contains object modules
with special object records that define the functions belonging to a Dynamic Link Library.&nbsp; An import library is created
from a Dynamic Link Library using a Library Manager. Optionally, JWlink 
may create an import library with the <A HREF="#IMPLIB_Option">IMPLIB</A> option when linking a DLL .&nbsp;
The resulting import library can then be specified
in a <A HREF="#LIBRARY_Directive">LIBRARY</A> directive in the same way one would specify a standard library.

<P>Using an import library is the preferred method of providing references to functions in Dynamic Link Libraries.&nbsp; When
a Dynamic Link Library is modified, typically the import library corresponding to the modified Dynamic Link Library is updated
to reflect the changes.&nbsp; Hence, any directive file that specifies the import library in a <A HREF="#LIBRARY_Directive">LIBRARY</A> directive
need not be modified.&nbsp; OTOH, if you are using <A HREF="#IMPORT_Directive">IMPORT</A> directives, you may have to modify the 
directives to reflect the changes in the Dynamic Link Library.

<H2 ID="Win32__Hints_for_MS_Link_Users"> Hints for MS Link and PoLink Users </H2>

If you're used to MS link or PoLink, the following table should give an idea
about how the arguments are to be translated for JWlink.
<P>
<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#C0C0C0"><TH ALIGN="LEFT">MS Link Argument</TH><TH ALIGN="LEFT">JWlink Equivalent</TH></TR>
<TR><TD BGCOLOR="#E0E0C0">/ALIGN:n</TD>          <TD BGCOLOR="#C0C0E0"><A HREF="#OBJALIGN_Option">OP OBJALIGN</A>=n</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/BASE:n</TD>           <TD BGCOLOR="#C0C0E0"><A HREF="#OFFSET_M_OSD2__Win32__ELF_only">OP OFFSET</A>=n</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/DEBUG</TD>            <TD BGCOLOR="#C0C0E0"><A HREF="#DEBUG_Directive">DEBUG C</A> <A HREF="#CVPACK_Option">OP CVP</A></TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/DLL</TD>              <TD BGCOLOR="#C0C0E0"><A HREF="#FORMAT_Directive">FORMAT</A> WIN PE DLL</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/ENTRY:symbol</TD>     <TD BGCOLOR="#C0C0E0"><A HREF="#START_Option">OP START</A>=symbol</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/EXPORT:name</TD>      <TD BGCOLOR="#C0C0E0"><A HREF="#EXPORT_M_OSD2__Win16__Win32_only">EXPORT</A> name</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/FILEALIGN:n</TD>      <TD BGCOLOR="#C0C0E0"><A HREF="#ALIGNMENT_Option">OP ALIGNMENT</A>=n</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/FIXED</TD>            <TD BGCOLOR="#C0C0E0"><A HREF="#NORELOCS_Option">OP NORELOCS</A></TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/FORCE:multiple</TD>   <TD BGCOLOR="#C0C0E0"><A HREF="#REDEFSOK_Option">OP REDEFSOK</A></TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/HEAP:res,comm</TD>    <TD BGCOLOR="#C0C0E0"><A HREF="#HEAPSIZE_Option">OP HEAPSIZE</A>=res <A HREF="#COMMIT_Directive">COMMIT</A> HEAP=comm</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/IMPLIB:name</TD>      <TD BGCOLOR="#C0C0E0"><A HREF="#IMPLIB_Option">OP IMPLIB</A>=name</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/INCLUDE:symbol</TD>   <TD BGCOLOR="#C0C0E0"><A HREF="#REFERENCE_Directive">REFERENCE</A> symbol</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/LARGEADDRESSAWARE</TD><TD BGCOLOR="#C0C0E0"><A HREF="#LARGEADDRESSAWARE_Option">OP LARGEADDRESSAWARE</A></TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/LIBPATH:path</TD>     <TD BGCOLOR="#C0C0E0"><A HREF="#LIBPATH_Directive">LIBPATH</A> path</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/MAP</TD>              <TD BGCOLOR="#C0C0E0"><A HREF="#MAP_Option">OP MAP</A></TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/NODEFAULTLIB</TD>     <TD BGCOLOR="#C0C0E0"><A HREF="#NODEFAULTLIBS_Option">OP NODEFAULTLIBS</A></TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/NXCOMPAT</TD>         <TD BGCOLOR="#C0C0E0"><A HREF="#NXCOMPAT_Option">OP NXCOMPAT</A></TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/OSVERSION:maj,min</TD><TD BGCOLOR="#C0C0E0"><A HREF="#OSVERSION_Option">OP OSVERSION</A>=maj.min</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/OUT:name</TD>         <TD BGCOLOR="#C0C0E0"><A HREF="#NAME_Directive">NAME</A> name</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/SECTION:segm,...</TD> <TD BGCOLOR="#C0C0E0"><A HREF="#SEGMENT_Directive">SEGMENT</A> segm ...</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/STACK:res,comm</TD>   <TD BGCOLOR="#C0C0E0"><A HREF="#STACK_Option">OP STACK</A>=res <A HREF="#COMMIT_Directive">COMMIT</A> STACK=comm</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/STUB:filename</TD>    <TD BGCOLOR="#C0C0E0"><A HREF="#STUB_Option">OP STUB</A>=filename</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">/SUBSYSTEM:system</TD> <TD BGCOLOR="#C0C0E0"><A HREF="#RUNTIME_M_Win32_only">RUNTIME</A> system</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">library.LIB</TD>       <TD BGCOLOR="#C0C0E0"><A HREF="#LIBRARY_Directive">LIBRARY</A> library</TD></TR>
<TR><TD BGCOLOR="#E0E0C0">module.OBJ</TD>        <TD BGCOLOR="#C0C0E0"><A HREF="#FILE_Directive">FILE</A> module</TD></TR>
</TABLE>
</TD></TR>
</TABLE>

<P>There's no direct replacement for MS link's <b>/DEF</b> option, which tells the linker to scan a so-called Module Definition File.
However, since the main usage of such files is to define exports, it's simple to replace them
with standard linker directive files.
<P>Here's an example. Module Definition File MYDLL.DEF:
<P><PRE>
    LIBRARY MYDLL
    EXPORTS
     MyFunction1
     MyFunction2
     MyFunction3
</PRE>
<P>can be replaced by linker directive file MYDLL.RSP:
<P><PRE>
    OP MODNAME=MYDLL
    OP FUZZYEXPORT
    EXPORT {
     MyFunction1
     MyFunction2
     MyFunction3
    }
</PRE>
<P> and that file is added to JWlink's commandline with the <A HREF="#atsign_Directive">@</A> directive:
<P><TT>jwlink format win pe dll file mydll.obj <b>@MYDLL.RSP</b>

<H1 ID="JWlink_Diagnostic_Messages"> JWlink Diagnostic Messages </H1>
JWlink issues three classes of messages; fatal errors, errors and warnings.&nbsp; Each message has a 4-digit
number associated with it.&nbsp; Fatal messages start with the digit 3, error messages start with the digit 2, and warning
messages start with the digit 1.&nbsp; It is possible for a message to be issued as a warning or an error.
<P>If a fatal error occurs, the linker will terminate immediately and no executable file will be generated.
<P>If an error occurs, the linker will continue to execute so that all possible errors are issued.&nbsp; However, no executable
file will be generated since these errors do not permit a proper executable file to be generated.
<P>If a warning occurs, the linker will continue to execute.&nbsp; A warning message is usually informational and does not
prevent the creation of a proper executable file.&nbsp; However, all warnings should eventually be corrected.
<P>The messages listed contain references to<TT> %s, %S, %a, %x, %d, %l,</TT> and<TT> %f.</TT>&nbsp; They represent strings
that are substituted by JWlink to make the error message more precise.
<OL>
<P><LI><TT> %s</TT> represents a string.&nbsp; This may be a segment or group name, or the name of a linker directive or option.
<P><LI><TT> %S</TT> represents the name of a symbol.
<P><LI><TT> %a</TT> represents an address.&nbsp; The format of the address depends on the format of the executable file being
generated.
<P><LI><TT> %x</TT> represents a hexadecimal number.
<P><LI><TT> %d</TT> represents integers in the range -32768 and 32767.
<P><LI><TT> %l</TT> represents integers in the range -2147483648 and 2147483647.
<P><LI><TT> %f</TT> represents an executable file format such as DOS, WINDOWS, PHARLAP, NOVELL, OS2, QNX or ELF.
</OL>
<P>The following is a list of all warning and error messages produced by JWlink followed by a description
of the message.&nbsp; A message may contain more than one reference to &quot;%s&quot;.&nbsp; In such a case, the description
will reference them as &quot;%sn&quot; where n is the occurrence of &quot;%s&quot; in the message.

<H2 ID="2002_TT_internal_TT_M__s"> 2002 ** internal ** - %s </H2>
If this message occurs, you have found a bug in the linker and should report it.

<H2 ID="2008_cannot_open__s1____s2"> 2008 cannot open %s1 :&nbsp; %s2 </H2>
An error occurred while trying to open the file &quot;%s1&quot;.&nbsp; The reason for the error is given by &quot;%s2&quot;.
&nbsp;Generally this error message is issued when the linker cannot open a file (e.g., an object file or an executable file).

<H2 ID="3009_dynamic_memory_exhausted"> 3009 dynamic memory exhausted </H2>
The linker uses all available memory when linking an application.&nbsp; When all available memory is used, a spill file will be used.&nbsp; Therefore,
unless you are low on disk space, the linker will always be able to generate the executable file.&nbsp; Dynamic memory is
the memory the linker uses to build its internal data structures and symbol table.&nbsp; Dynamic memory is the amount of unallocated
memory available on your machine (including virtual memory for those operating systems that support it).&nbsp; A spill file
is not used for dynamic memory.&nbsp; If the linker issues this message, it cannot link your application.&nbsp; The following
are suggestions that may help you in this situation.
<OL>
<P><LI>Concatenate all your object files into one and specify only the resulting object file as input to the linker.&nbsp;
For example, if you are linking in a DOS environment, you can issue the following DOS command.
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;copy/b *.obj all.obj</TT>
<P>This technique only works for OMF-type object files.&nbsp; This significantly reduces the size of the file list the linker
must maintain.
<P><LI>Object files may contain a record which specifies the module name.&nbsp; This information is used by Open Watcom Debugger
to locate modules during a debugging session and usually contains the full path of the source file.&nbsp; This can consume
a significant amount of memory when many such object files are being linked.&nbsp; If your source is being compiled by the
Open Watcom C or C++ compiler, you can use the &quot;nm&quot; option to set the module name to just the file name.&nbsp; This
reduces the amount of memory required by the linker.&nbsp; If your are using Open Watcom Debugger to debug your application,
you may have to use the &quot;set source&quot; command so that the source corresponding to a module can be located.
<P><LI>Typically, when you are compiling a program for a large code model, each module defines a different &quot;text&quot;
segment.&nbsp; If you are compiling your application using the Open Watcom C or C++ compiler, you can reduce the number of
&quot;text&quot; segments that the linker has to process by specifying the &quot;nt&quot; option.&nbsp; The &quot;nt&quot;
option allows you to specify the name of the &quot;text&quot; segment so that a group of object files define the same &quot;text&quot;
segment.
</OL>

<H2 ID="2010_3010_IDO_error_processing__s1____s2"> 2010,3010 I/O error processing %s1 :&nbsp; %s2 </H2>
An error has occurred while processing the file &quot;%s1&quot;.&nbsp; The cause of the error is given by &quot;%s2&quot;.
&nbsp;This error is usually detected while reading from object and library files or writing to the spill file or executable
file.&nbsp; For example, this error would be issued if a &quot;disk full&quot; condition existed.

<H2 ID="2011_invalid_object_file_attribute"> 2011 invalid object file attribute </H2>
The linker encountered an object file that was not of the format required of an object file.

<H2 ID="2012_invalid_library_file_attribute"> 2012 invalid library file attribute </H2>
The linker encountered a library file that was not of the format required of a library file.

<H2 ID="3013_break_key_detected"> 3013 break key detected </H2>
The linking process was interrupted by the user from the keyboard.

<H2 ID="1014_stack_segment_not_found"> 1014 stack segment not found </H2>
The linker identifies the stack segment by a segment defined as having the &quot;STACK&quot; attribute.&nbsp; This message
is issued if no such segment is encountered.&nbsp; This usually happens if the linker cannot find the run-time libraries required
to link your application.

<H2 ID="2015_bad_relocation_type_specified"> 2015 bad relocation type specified </H2>
This message is issued if a a relocation is found in an object file which the linker does not support.

<H2 ID="2016__a__absolute_target_invalid_for_selfMrelative_relocation"> 2016 %a:&nbsp; absolute target invalid for self-relative relocation </H2>
This message is issued, for example, if a near call or jump is made to an external symbol which is defined using the &quot;EQU&quot;
assembler directive.&nbsp; &quot;%a&quot; identifies the location of the near call or jump instruction.

<H2 ID="2017_bad_location_specified_for_selfMrelative_relocation_at__a"> 2017 bad location specified for self-relative relocation at %a </H2>
This message is issued if a bad fixup is encountered.&nbsp; &quot;%a&quot; defines the location of the fixup.

<H2 ID="2018_relocation_offset_at__a_is_out_of_range"> 2018 relocation offset at %a is out of range </H2>
This message is issued when the offset part of a relocation exceeds 64K in a 16-bit executable or an Alpha executable.
&nbsp;&quot;%a&quot; defines the location of the fixup.&nbsp; The error is most commonly caused by errors in coding assembly
language routines.&nbsp; Consider a module that references an external symbol that is defined in a segment different from
the one in which the reference occurred.&nbsp; The module, however, specifies that the segment in which the symbol is defined
is the same segment as the segment that references the symbol.&nbsp; This error is most commonly caused when the &quot;EXTRN&quot;
assembler directive is placed after the &quot;SEGMENT&quot; assembler directive for the segment referencing the symbol.&nbsp;
If the segment that references the symbol is allocated far enough away from the segment that defines the symbol, the linker
will issue this message.

<H2 ID="1019_segment_relocation_at__a"> 1019 segment relocation at %a </H2>
This message is issued when a 16-bit segment relocation is encountered and &quot;FORMAT DOS COM&quot;, &quot;FORMAT PHARLAP&quot;
or &quot;FORMAT NOVELL&quot; has been specified.&nbsp; None of the above executable file formats allow segment relocation.
&nbsp;&quot;%a&quot; identifies the location of the segment relocation.

<H2 ID="2020_size_of_group__s_exceeds_64k_by__l_bytes"> 2020 size of group %s exceeds 64k by %l bytes </H2>
The group &quot;%s&quot; has exceeded the maximum size (64K) allowed for a group in a 16-bit executable by &quot;%l&quot;
bytes.&nbsp; Usually, the group is &quot;DGROUP&quot; (the default data segment) and your application has placed too much
data in this group.&nbsp; One of the following may solve this problem.
<OL>
<P><LI>If you are using the Open Watcom C or C++ compiler, you can place some of your data in a far segment by using the &quot;far&quot;
keyword when defining data.&nbsp; You can also decrease the value of the data threshold by using the &quot;zt&quot; compiler
option.&nbsp; Any datum whose size exceeds the value of the data threshold will be placed in a far segment.
<P><LI>If you are using the Open Watcom FORTRAN 77 compiler, you can decrease the value of the data threshold by using the
&quot;dt&quot; compiler option.&nbsp; Any datum whose size exceeds the value of the data threshold will be placed in a far
segment.
</OL>

<H2 ID="2021_size_of_segment__s_exceeds_64k_by__l_bytes"> 2021 size of segment %s exceeds 64k by %l bytes </H2>
The segment &quot;%s&quot; has exceeded the maximum size (64K) for a segment in a 16-bit executable.&nbsp; This usually occurs
if you are linking a 16-bit application that has been compiled for a small code model and the size of the application has
grown in such a way that the size of the code segment (&quot;_TEXT&quot;) has exceeded 64K.&nbsp; You can overlay your application
or compile it for a large code model if you cannot reduce the amount of code in your application.

<H2 ID="2022_cannot_have_a_starting_address_with_an_imported_symbol"> 2022 cannot have a starting address with an imported symbol </H2>
When generating an OS/2 executable file, a symbol imported from a DLL cannot be a start address.&nbsp; When generating
a NetWare executable file, a symbol imported from an NLM cannot be a start address.

<H2 ID="1023_no_starting_address_found__using__a"> 1023 no starting address found, using %a </H2>
The starting address defines the location where execution is to begin and must be defined by a special &quot;module end&quot;
record in one of the object files linked into your application.&nbsp; This message is issued if no such record is encountered
in which case a default starting address, namely &quot;%a&quot;, will be used.&nbsp; This usually happens if the linker cannot
find the run-time libraries required to link your application.

<H2 ID="2024_missing_overlay_loader"> 2024 missing overlay loader </H2>
This message is issued when an overlayed 16-bit DOS executable is being linked and the overlay manager has not been encountered.
&nbsp;This usually happens if the linker cannot find the run-time libraries required to link your application.

<H2 ID="2025_short_vector__d_is_out_of_range"> 2025 short vector %d is out of range </H2>
This message is issued when the linker is creating an overlayed 16-bit DOS executable and <A HREF="#SMALL_Option">OPTION SMALL</A> is specified.
&nbsp;Since an overlay vector contains a near call to the overlay loader followed by a near jump to the routine corresponding
to the overlay vector, all code including the overlay manager and all overlay vectors must be less than 64K.&nbsp; This message
is issued if the offset of an overlay vector from the overlay loader or the corresponding routine exceeds 64K.

<H2 ID="2026_redefinition_of_reserved_symbol__s"> 2026 redefinition of reserved symbol %s </H2>
The linker defines certain reserved symbols.&nbsp; These symbols are:
<DL>
<DT></DT>
<DD>_edata <sup>[1]</sup></DD>
<DD>_end <sup>[1]</sup></DD>
<DD>__OVLTAB__ <sup>[2]</sup></DD>
<DD>__OVLSTARTVEC__ <sup>[2]</sup></DD>
<DD>__OVLENDVEC__ <sup>[2]</sup></DD>
<DD>__LOVLLDR__ <sup>[2]</sup></DD>
<DD>__NOVLLDR__ <sup>[2]</sup></DD>
<DD>__SOVLLDR__ <sup>[2]</sup></DD>,
<DD>__LOVLINIT__ <sup>[2]</sup></DD>
<DD>__NOVLINIT__ <sup>[2]</sup></DD>
<DD>__SOVLINIT__ <sup>[2]</sup></DD>
</DL>
[1]: symbols are defined only if the <A HREF="#DOSSEG_Option">DOSSEG</A> option is specified.<br>
[2]: symbols are defined only if you are using overlays in 16-bit DOS executables.<br>

<P>Your application must not attempt to define these symbols.&nbsp; &quot;%s&quot; identifies the
reserved symbol.

<H2 ID="1027_2027_redefinition_of__S_ignored"> 1027,2027 redefinition of %S ignored </H2>
The symbol &quot;%S&quot; has been defined by more that one module; the first definition is used.&nbsp;
This may be a warning or an error message, depending on state of option [NO]<A HREF="#REDEFSOK_Option">REDEFSOK</A>.&nbsp;
Note that if a symbol is defined more than once and its address is the same in both cases, no warning
will be issued.&nbsp; This prevents the warning message from being issued when linking FORTRAN 77 modules that contain common
blocks.

<H2 ID="1028_2028__S_is_an_undefined_reference"> 1028,2028 %S is an undefined reference </H2>
The symbol &quot;%S&quot; has been referenced but not defined.&nbsp; Check that the spelling of the symbol is consistent.
&nbsp;If you want the linker to ignore undefined references, use the [NO]<A HREF="#UNDEFSOK_Option">UNDEFSOK</A> option.

<H2 ID="2029_premature_end_of_file_encountered"> 2029 premature end of file encountered </H2>
This error is issued while processing object files and object modules from libraries and is caused if the end of the file
or module is reached before the &quot;module end&quot; record is encountered.&nbsp; The probable cause is a truncated object
file.

<H2 ID="1030_multiple_starting_addresses_found"> 1030 multiple starting addresses found </H2>
The starting address defines the location where execution is to begin and is defined by a &quot;module end&quot; record
in a particular object file.&nbsp; This message is issued if more than one object file contains a &quot;module end&quot; record
that defines a starting address.

<H2 ID="2031_segment__s_is_in_group__s_and_group__s"> 2031 segment %s is in group %s and group %s </H2>
The segment &quot;%s1&quot; has been defined to be in group &quot;%s2&quot; in one module and in group &quot;%s3&quot;
in another module.&nbsp; A segment can only belong to one group.

<H2 ID="1032_record_Ltype_0x_xR_not_processed"> 1032 record (type 0x%x) not processed </H2>
An object record type not supported by the linker has been encountered.&nbsp; This message is issued when linking object
modules created by other compilers or assemblers that create object files with records that the linker does not support.

<H2 ID="2033_3033_directive_error_near___s_"> 2033,3033 directive error near '%s' </H2>
A syntax error occurred while the linker was processing directives.&nbsp; &quot;%s&quot; specifies where the error occurred.

<H2 ID="2034__a_cannot_have_an_offset_with_an_imported_symbol"> 2034 %a cannot have an offset with an imported symbol </H2>
An imported symbol is one that was specified in an <A HREF="#IMPORT_Directive">IMPORT</A> directive.&nbsp; Imported symbols are defined in
Windows or OS/2 16-bit DLLs and in Netware NLMs.&nbsp; References to imported symbols must always have an offset value of
0.&nbsp; If &quot;DosWrite&quot; is an imported symbol, then referencing &quot;DosWrite+2&quot; is illegal.&nbsp; &quot;%a&quot;
defines the location of the illegal reference.

<H2 ID="1038_DEBUG_directive_appears_after_object_files"> 1038 DEBUG directive appears after object files </H2>
This message is issued if the first <A HREF="#DEBUG_Directive">DEBUG</A> directive appears after a <A HREF="#FILE_Directive">FILE</A> directive.&nbsp; A common
error is to specify a <A HREF="#DEBUG_Directive">DEBUG</A> directive after the <A HREF="#FILE_Directive">FILE</A> directives in which case no debugging information
for those object files is generated in the executable file.

<H2 ID="2039_ALIGNMENT_value_too_small"> 2039 ALIGNMENT value too small </H2>
The value specified in the <A HREF="#ALIGNMENT_Option">ALIGNMENT</A> option refers to the alignment of segments in the executable file.&nbsp;
For 16-bit Windows or 16-bit OS/2, segments in the executable file are pointed to by a segment table.&nbsp; An entry in the
segment table contains a 16-bit value which is a multiple of the alignment value.&nbsp; Together they form the offset of the
segment from the start of the segment table.&nbsp; The smaller the alignment, the bigger the value required in the segment
table to point to the segment.&nbsp; If this value exceeds 64K, then a larger alignment value is required to decrease the
size that goes in the segment table.

<H2 ID="2040_ordinal_in_IMPORT_directive_not_valid"> 2040 ordinal in IMPORT directive not valid </H2>
The specified ordinal in the <A HREF="#IMPORT_Directive">IMPORT</A> directive is incorrect (e.g., -1).&nbsp; An ordinal number must be in the
range 0 to 65535.

<H2 ID="2041_ordinal_in_EXPORT_directive_not_valid"> 2041 ordinal in EXPORT directive not valid </H2>
The specified ordinal in the <A HREF="#EXPORT_Directive">EXPORT</A> directive is incorrect (e.g., -1).&nbsp; An ordinal number must be in the
range 0 to 65535.

<H2 ID="2042_too_many_IOPL_words_in_EXPORT_directive"> 2042 too many IOPL words in EXPORT directive </H2>
The maximum number of IOPL words for a 16-bit executable is 63.

<H2 ID="1043_duplicate_exported_ordinal"> 1043 duplicate exported ordinal </H2>
This message is issued for ordinal numbers specified in an <A HREF="#EXPORT_Directive">EXPORT</A> directive for symbols belonging to DLLs.
&nbsp;This message is issued if an ordinal number is assigned to two different symbols.&nbsp; A warning is issued and the
linker assigns a non-used ordinal number to the symbol that caused the warning.

<H2 ID="1044_2044_exported_symbol__s_not_found"> 1044,2044 exported symbol %s not found </H2>
This message is issued when generating a DLL or NetWare NLM.&nbsp; An attempt has been made to define an entry point into
a DLL or NLM that does not exist.

<H2 ID="1045_segment_attribute_defined_more_than_once"> 1045 segment attribute defined more than once </H2>
A segment appearing in a <A HREF="#SEGMENT_Directive">SEGMENT</A> directive has been given conflicting or duplicate attributes.

<H2 ID="1046_segment_name__s_not_found"> 1046 segment name %s not found </H2>
The segment name specified in a <A HREF="#SEGMENT_Directive">SEGMENT</A> directive has not been defined.

<H2 ID="1047_class_name__s_not_found"> 1047 class name %s not found </H2>
The class name specified in a <A HREF="#SEGMENT_Directive">SEGMENT</A> directive has not been defined.

<H2 ID="1048_inconsistent_attributes_for_automatic_data_segment"> 1048 inconsistent attributes for automatic data segment </H2>
This message is issued for Windows or OS/2 16-bit executable files.&nbsp; Two conflicting attributes were specified for
the automatic data segment.&nbsp; For example, &quot;LOADONCALL&quot; and &quot;PRELOAD&quot; are conflicting attributes.
&nbsp;Only the first attribute is used.

<H2 ID="2049_invalid_STUB_file"> 2049 invalid STUB file </H2>
The stub file defined with the <A HREF="#STUB_Option">STUB</A> option is not a valid executable file.&nbsp; The stub file is only used for OS/2 executable files and Windows (both
Win16 and Win32/Win64) executable files.

<H2 ID="1050_invalid_DLL_specified_in_OLDLIBRARY_option"> 1050 invalid DLL specified in OLDLIBRARY option </H2>
The DLL specified in an <A HREF="#OLDLIBRARY_Option">OLDLIBRARY</A> option is not a valid dynamic link library.

<H2 ID="2051_STUB_file_name_same_as_executable_file_name"> 2051 STUB file name same as executable file name </H2>
When generating an OS/2 or Windows (Win16, Win32/Win64) executable file, the stub file name must not be same as the executable
file name.

<H2 ID="2052_relocation_at__a_not_in_the_same_segment"> 2052 relocation at %a not in the same segment </H2>
This message is only issued for Windows (Win16), OS/2, Phar Lap, and QNX executables.&nbsp; A relative fixup must relocate
to the same segment.&nbsp; &quot;%a&quot; defines the location of the fixup.

<H2 ID="2053__a__cannot_reach_a_DLL_with_a_relative_relocation"> 2053 %a:&nbsp; cannot reach a DLL with a relative relocation </H2>
A reference to a symbol in an OS/2 or Windows 16-bit DLL must not be relative.&nbsp; &quot;%a&quot; defines the location
of the reference.

<H2 ID="1054_debugging_information_incompatible__using_line_numbers_only"> 1054 debugging information incompatible:&nbsp; using line numbers only </H2>
An attempt has been made to link an object file with out-of-date debugging information.

<H2 ID="2055__a__frame_must_be_the_same_as_the_target_in_protected_mode"> 2055 %a:&nbsp; frame must be the same as the target in protected mode </H2>
Each relocation consists of three components; the location being relocated, the target (or address being referenced), and
the frame (the segment to which the target is adjusted).&nbsp; In protected mode, the segment of the target must be the same
as the frame.&nbsp; &quot;%a&quot; defines the location of the fixup.&nbsp; This message does not apply to 32-bit OS/2 and
Windows (Win32/Win64).

<H2 ID="2056_cannot_find_library_member__sL_sR"> 2056 cannot find library member %s(%s) </H2>
Library member &quot;%s2&quot; in library file &quot;%s1&quot; could not be found.&nbsp; This message is issued if the
library file could not be found or the library file did not contain the specified member.

<H2 ID="3057_executable_format_has_been_established"> 3057 executable format has been established </H2>
This message is issued if there is more than one <A HREF="#FORMAT_Directive">FORMAT</A> directive.

<H2 ID="1058__s_option_not_valid_for__s_executable"> 1058 option %s not valid for %s </H2>
The option &quot;%s1&quot; can only be specified if an executable file whose format is &quot;%s2&quot; is being generated.

<H2 ID="1059_2059_value_for__s_too_large"> 1059,2059 value for %s too large </H2>
The value specified for option &quot;%s&quot; exceeds its limit.

<H2 ID="1060_value_for__s_incorrect"> 1060 value for %s incorrect </H2>
The value specified for option &quot;%s&quot; is not in the allowable range.

<H2 ID="1061_multiple_values_specified_for_REALBREAK"> 1061 multiple values specified for REALBREAK </H2>
The <A HREF="#RUNTIME_M_PharLap_only">RUNTIME REALBREAK</A> directive for Phar Lap executables can only be specified once.

<H2 ID="1062_export_and_import_records_not_valid_for__f"> 1062 export and import records not valid for %f </H2>
This message is issued if a reference to a DLL is encountered and the executable file format is not one that supports DLLs.
&nbsp;The file format is represented by &quot;%f&quot;.

<H2 ID="2063_invalid_relocation_for_flat_memory_model_at__a"> 2063 invalid relocation for flat memory model at %a </H2>
A segment relocation in the flat memory model was encountered.&nbsp; &quot;%a&quot; defines the location of the fixup.

<H2 ID="2064_cannot_combine_32Mbit_segments_L_s1R_with_16Mbit_segments_L_s2R"> 2064 cannot combine 32-bit segments (%s1) with 16-bit segments (%s2) </H2>
A 32-bit segment &quot;%s1&quot; and a 16-bit segment &quot;%s2&quot; have been encountered.&nbsp; Mixing object files
created by a 286 compiler and object files created by a 386 compiler is the most probable cause of this error.

<H2 ID="2065_REALBREAK_symbol__s_not_found"> 2065 REALBREAK symbol %s not found </H2>
The symbol specified in the <A HREF="#RUNTIME_M_PharLap_only">RUNTIME REALBREAK</A> directive for Phar Lap executables has not been defined.

<H2 ID="2066_invalid_relative_relocation_type_for_an_import_at__a"> 2066 invalid relative relocation type for an import at %a </H2>
This message is issued only if a NetWare executable file is being generated.&nbsp; An imported symbol is one that was specified
in an <A HREF="#IMPORT_Directive">IMPORT</A> directive or an import library.&nbsp; Any reference to an imported symbol must not refer to the segment
of the imported symbol.&nbsp; &quot;%a&quot; defines the location of the reference.

<H2 ID="2067__a__cannot_relocate_between_code_and_data_in_Novell_formats"> 2067 %a:&nbsp; cannot relocate between code and data in Novell formats </H2>
This message is issued only if a NetWare executable file is being generated.&nbsp; Segment relocation is not permitted.
&nbsp;&quot;%a&quot; defines the location of the fixup.

<H2 ID="2068_absolute_segment_fixup_not_valid_in_protected_mode"> 2068 absolute segment fixup not valid in protected mode </H2>
A reference to an absolute location is not allowed for binaries supposed to run in a protected-mode environment.&nbsp;
An absolute location is most commonly defined by the &quot;EQU&quot; assembler directive.

<H2 ID="1069_unload_CHECK_procedure_not_found"> 1069 unload CHECK procedure not found </H2>
This message is issued only if a NetWare executable file is being generated.&nbsp; The symbol specified in the <A HREF="#CHECK_Option">CHECK</A>
option has not been defined.

<H2 ID="2070_START_procedure_not_found"> 2070 START procedure not found </H2>
This message is issued only if a NetWare executable file is being generated.&nbsp; The symbol specified in the <A HREF="#START_Option">START</A>
option has not been defined.&nbsp; The default START symbol is &quot;_Prelude&quot;.

<H2 ID="2071_EXIT_procedure_not_found"> 2071 EXIT procedure not found </H2>
This message is issued only if a NetWare executable file is being generated.&nbsp; The symbol specified in the <A HREF="#EXIT_Option">EXIT</A>
option has not been defined.&nbsp; The default EXIT symbol is &quot;_Stop&quot;.

<H2 ID="1072_SECTION_directive_not_allowed_in_root"> 1072 SECTION directive not allowed in root </H2>
When describing 16-bit overlays, <A HREF="#SECTION_Directive">SECTION</A> directives must appear between a <A HREF="#BEGIN_Directive">BEGIN</A> directive and its
corresponding <A HREF="#END_Directive">END</A> directive.

<H2 ID="2073_bad_Novell_file_format_specified"> 2073 bad Novell file format specified </H2>
An invalid NetWare executable file format was specified.&nbsp; Valid formats are NLM, DSK, NAM, LAN, MSL, HAM, CDM or a
numerical module type.

<H2 ID="2074_circular_alias_found_for__s"> 2074 circular alias found for %s </H2>
An attempt was made to circularly define the symbol name specified in an <A HREF="#ALIAS_Directive">ALIAS</A> directive.&nbsp; For example:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; ALIAS foo1=foo2, foo2=foo1</TT>

<H2 ID="2075_expecting_an_END_directive"> 2075 expecting an END directive </H2>
A <A HREF="#BEGIN_Directive">BEGIN</A> directive is missing its corresponding <A HREF="#END_Directive">END</A> directive.

<H2 ID="1076__s_option_multiply_specified"> 1076 %s option multiply specified </H2>
The option &quot;%s&quot; can only be specified once.

<H2 ID="1080_file__s_is_a__dMbit_object_file"> 1080 file %s is a %d-bit object file </H2>
A 32-bit attribute was encountered while generating a 16-bit executable file format, or a 16-bit attribute was encountered
while generating a 32-bit executable file format.

<H2 ID="2082_invalid_record_type_0x_x"> 2082 invalid record type 0x%x </H2>
An object record type not recognized by the linker has been encountered.&nbsp; This message is issued when linking object
modules created by other compilers or assemblers that create object files with records that the linker does not recognize.

<H2 ID="2083_cannot_reference_address__a_from_frame__x"> 2083 cannot reference address %a from frame %x </H2>
When generating a 16-bit executable, the offset of a referenced symbol was greater than 64K from the location referencing
it.

<H2 ID="2084_target_offset_exceeds_64K_at__a"> 2084 target offset exceeds 64K at %a </H2>
When generating a 16-bit executable, the computed offset for a symbol exceeds 64K.&nbsp; &quot;%a&quot; defines the location
of the fixup.

<H2 ID="2086_invalid_starting_address_for__COM_file"> 2086 invalid starting address for .COM file </H2>
The value of the segment of the starting address for a 16-bit DOS &quot;COM&quot; file, as specified in the map file, must
be 0.
<H2 ID="1087_stack_segment_ignored_in__COM_file"> 1087 stack segment ignored in .COM file </H2>
A stack segment must not be defined when generating a 16-bit DOS &quot;COM&quot; file.&nbsp; Only a single physical segment
is allowed in a DOS &quot;COM&quot; file.&nbsp; The stack is allocated from the high end of the physical segment.&nbsp; That
is, the initial value of SP is hexadecimal FFFE.

<H2 ID="3088_virtual_memory_exhausted"> 3088 virtual memory exhausted </H2>
This message is similar to the &quot;dynamic memory exhausted&quot; message.&nbsp; The DOS-hosted version of the linker
has run out of memory trying to keep track of virtual memory blocks.&nbsp; Virtual memory blocks are allocated from expanded
memory, extended memory and the spill file.

<H2 ID="1089_program_too_large_for_a__COM_file"> 1089 program too large for a .COM file </H2>
The total size of a 16-bit DOS &quot;COM&quot; program must not exceed 64K.&nbsp; That is, the total amount of code and
data must be less than 64K since only a single physical segment is allowed in a DOS &quot;COM&quot; file.&nbsp; You must decrease
the size of your program or generate a DOS &quot;EXE&quot; file.

<H2 ID="1090_redefinition_of__s_by__s_ignored"> 1090 redefinition of %s by %s ignored </H2>
The symbol &quot;%s1&quot; has been redefined by module &quot;%s2&quot;.&nbsp; This message is issued when the size specified
in the <A HREF="#NAMELEN_Option">NAMELEN</A> option has caused two symbols to map to the same symbol.&nbsp; For example, if the symbols<B> routine1</B>
and<B> routine2</B> are encountered and OPTION NAMELEN=7 is specified, then this message will be issued since
the first seven characters of the two symbols are identical.

<H2 ID="2091_group__s_is_in_more_than_one_overlay"> 2091 group %s is in more than one overlay </H2>
A group that spans more than one section in a 16-bit DOS executable has been detected.

<H2 ID="2092_NEWSEGMENT_directive_appears_before_object_files"> 2092 NEWSEGMENT directive appears before object files </H2>
The 16-bit <A HREF="#NEWSEGMENT_Directive">NEWSEGMENT</A> directive must appear after a <A HREF="#FILE_Directive">FILE</A> directive.

<H2 ID="2093_cannot_open__s"> 2093 cannot open %s </H2>
This message is issued when the linker is unable to open a file and is unable to determine the cause.

<H2 ID="2094_iDo_error_processing__s"> 2094 i/o error processing %s </H2>
This message is issued when the linker has encountered an i/o error while processing the file and is unable to determine
the cause.&nbsp; This message may be issued when reading from object and library files, or writing to the executable and spill
file.

<H2 ID="3097_too_many_library_modules"> 3097 too many library modules </H2>
This message is similar to the &quot;dynamic memory exhausted&quot; message.&nbsp; This message if issued when the <A HREF="#DISTRIBUTE_Option">DISTRIBUTE</A>
option for 16-bit DOS executables is specified.&nbsp; The linker has run out of memory trying to keep track of the relationship
between object modules extracted from libraries and the overlays they should be placed in.

<H2 ID="1098_Offset_option_must_be_a_multiple_of__dK"> 1098 Offset option must be a multiple of %dK </H2>
The value specified with the <A HREF="#OFFSET_Option">OFFSET</A> option must be a multiple of 4K (4096) for Phar Lap and QNX executables
and a multiple of 64K (65536) for OS/2 and Windows 32-bit executables.

<H2 ID="2099_symbol_name_too_long___s"> 2099 symbol name too long:&nbsp; %s </H2>
The maximum size (approximately 2048) of a symbol has been exceeded.&nbsp; Reduce the size of the symbol to avoid this
error.

<H2 ID="1101_invalid_incremental_information_file"> 1101 invalid incremental information file </H2>
The incremental information file is corrupt or from an older version of the compiler.&nbsp; The old information file and
the executable will be deleted and new ones will be generated.

<H2 ID="1102_object_file__s_not_found_for_tracing"> 1102 object file %s not found for tracing </H2>
A <A HREF="#SYMTRACE_Directive">SYMTRACE</A> or <A HREF="#MODTRACE_Directive">MODTRACE</A> directive contained an object file (namely %s) that could not be found.

<H2 ID="1103_library_module__sL_sR_not_found_for_tracing"> 1103 library module %s(%s) not found for tracing </H2>
A <A HREF="#SYMTRACE_Directive">SYMTRACE</A> or <A HREF="#MODTRACE_Directive">MODTRACE</A> directive contained an object module (namely module %s1 in library %s2 )
that could not be found.

<H2 ID="1105_cannot_reserve__l_bytes_of_extra_overlay_space"> 1105 cannot reserve %l bytes of extra overlay space </H2>
The value specified with the <A HREF="#AREA_Option">AREA</A> option for 16-bit DOS executables results in an executable file that requires
more than 1 megabyte of memory to execute.

<H2 ID="3106_borland_virdef_unsupported"> 3106 Borland VIRDEF record not supported </H2>
The linker detected a Borland so-called VIRDEF record in an OMF object module which it cannot handle.

<H2 ID="1107_undefined_system_name___s"> 1107 undefined system name:&nbsp; %s </H2>
The name %s was referenced in a <A HREF="#SYSTEM_Directive">SYSTEM</A> directive but never defined by a system block definition.

<H2 ID="1108_system__s_defined_more_than_once"> 1108 system %s defined more than once </H2>
The name %s has appeared in a system definition block more than once.

<H2 ID="1109_OFFSET_option_is_less_than_the_stack_size"> 1109 OFFSET option is less than the stack size </H2>
For the QNX operating system, the stack is placed at the front of the executable image and thus the initial load address
must leave enough room for the stack.

<H2 ID="1110_library_members_not_allowed_in_libfile"> 1110 library members not allowed in libfile </H2>
Only object files are allowed in a <A HREF="#LIBFILE_Directive">LIBFILE</A> directive.&nbsp; This message will be issued if a module from a
library file is specified in a <A HREF="#LIBFILE_Directive">LIBFILE</A> directive.

<H2 ID="1111_error_in_default_system_block"> 1111 error in default system block </H2>
The default system block definition (system name &quot;286&quot; for 16-bit applications) and (system name &quot;386&quot;
for 32-bit applications) contains a directive error.&nbsp; The system name &quot;286&quot; or &quot;386&quot; is automatically
referenced by the linker when the format of the executable cannot be determined (i.e.&nbsp; no <A HREF="#FORMAT_Directive">FORMAT</A> directive
has been specified).

<H2 ID="3114_environment_name_specified_incorrectly"> 3114 environment name specified incorrectly </H2>
This message is specified if the environment variable is not properly enclosed between two percent (%) characters.

<H2 ID="1115_environment_name__s_not_found"> 1115 environment name %s not found </H2>
The environment variable %s has not been defined in the environment space.

<H2 ID="1116_overlay_area_must_be_at_least__l_bytes"> 1116 overlay area must be at least %l bytes </H2>
This message is issued if the size of the largest overlay exceeds the size of the overlay area specified by the <A HREF="#AREA_Option">AREA</A>
option for 16-bit DOS executables.

<H2 ID="1117_segment_number_too_high_for_a_movable_entry_point"> 1117 segment number too high for a movable entry point </H2>
The segment number of a moveable segment must not exceed 255 for 16-bit executables.&nbsp; Reduce the number of segments
or use the <A HREF="#PACKCODE_Option">PACKCODE</A> option.

<H2 ID="1118_heap_size_too_large"> 1118 heap size too large </H2>
This message is issued if the size of the heap, stack and the default data segment (group DGROUP) exceeds 64K for 16-bit
executables.

<H2 ID="2119_jwlib_import_statement_incorrect"> 2119 jwlib import statement incorrect </H2>
The <A HREF="#EXPORT_Directive">EXPORT</A> directive allows you to specify a library command file.&nbsp; This command file is scanned for any
librarian commands that create import library entries.&nbsp; An invalid command was detected in this file.

<H2 ID="2120_application_too_large_to_run_under_DOS"> 2120 application too large to run under DOS </H2>
This message is issued if the size of the 16-bit DOS application exceeds 1M.

<H2 ID="1121___s__has_already_been_exported"> 1121 '%s' has already been exported </H2>
The linker has detected an attempt to export a symbol more than once.&nbsp; For example, a name appearing in more than
one <A HREF="#EXPORT_Directive">EXPORT</A> directive will cause this message to be issued.&nbsp; Also, if you have declared a symbol as an export
in your source and have also specified the same symbol in an <A HREF="#EXPORT_Directive">EXPORT</A> directive, this message will be issued.&nbsp;
This message is only a warning.

<H2 ID="3122_no_FILE_directives_found"> 3122 no FILE directives found </H2>
This message is issued if no <A HREF="#FILE_Directive">FILE</A> directive has been specified.&nbsp; In other words, you have specified no
object files to link.

<H2 ID="3123_overlays_are_not_supported_in_this_version_of_the_linker"> 3123 overlays are not supported in this version of the linker </H2>
This version of the linker does not support the creation of overlaid 16-bit executables.

<H2 ID="1124_lazy_reference_for__S_has_different_default_resolutions"> 1124 lazy reference for %S has different default resolutions </H2>
A lazy external reference is one which has two resolutions:&nbsp; a preferred one and a default one which is used if the
preferred one is not found.&nbsp; In this case, the linker has found two lazy references that have the same preferred resolution
but different default resolutions.

<H2 ID="1125_multiple_aliases_found_for__S"> 1125 multiple aliases found for %S </H2>
The linker has found a name which has been aliased to two different symbols.

<H2 ID="1126__s_has_been_modified__doing_full_relink"> 1126 %s has been modified:&nbsp; doing full relink </H2>
The linker has determined that the time stamps on the executable file and symbolic information file (.sym) are different.
&nbsp;An incremental link will not be done.

<H2 ID="2127_cannot_export_symbol__S"> 2127 cannot export symbol %S </H2>
An attempt was made to export a symbol defined with an absolute address or to export an imported symbol.&nbsp; It is not
possible to export these symbols with the <A HREF="#EXPORT_Directive">EXPORT</A> directive.

<H2 ID="3128_directive_error_near_beginning_of_input"> 3128 directive error near beginning of input </H2>
The linker detected an error at the start of the command line.

<H2 ID="3129_address_information_too_large"> 3129 address information too large </H2>
The linker has encountered a segment that appears in more than 11000 object files.&nbsp; An empty segment does not affect
this limit.&nbsp; This can only occur with Watcom debugging information.&nbsp; If this message appears, switch to DWARF debugging
information.

<H2 ID="1130__s_is_an_invalid_shared_nlm_file"> 1130 %s is an invalid shared nlm file </H2>
The NLM specified in a <A HREF="#SHARELIB_Option">SHARELIB</A> option is not valid.

<H2 ID="3131_cannot_open_spill_file__file_already_exists"> 3131 cannot open spill file:&nbsp; file already exists </H2>
All 26 of the DOS-hosted linker's possible spill file names are in use.&nbsp; Spill files can accumulate when linking on
a multi-tasking system and the directory in which the spill file is created is identical for each invocation of the linker.

<H2 ID="2132_curly_brace_delimited_list_incorrect"> 2132 curly brace delimited list incorrect </H2>
A list delimited by curly braces is not correct.&nbsp; The most likely cause is a missing right brace.

<H2 ID="1133_no_realbreak_specified_for_16Mbit_code"> 1133 no realbreak specified for 16-bit code </H2>
While generating a Phar Lap executable file, both 16-bit and 32-bit code was linked together and no <A HREF="#RUNTIME_M_PharLap_only">RUNTIME REALBREAK</A>
directive has been specified.&nbsp; A warning message is issued since this may be a potential problem.

<H2 ID="1134__s_is_an_invalid_message_file"> 1134 %s is an invalid message file </H2>
The file specified in a <A HREF="#MESSAGE_Option">MESSAGE</A> option for NetWare executable files is invalid.

<H2 ID="3135_need_exactly_1_overlay_area_with_dynamic_overlay_manager"> 3135 need exactly 1 overlay area with dynamic overlay manager </H2>
Only a single overlay area is supported by the 16-bit dynamic overlay manager.

<H2 ID="1136_segment_relocation_to_a_readDwrite_data_segment_found_at__aL_SR"> 1136 segment relocation to a read/write data segment found at %a(%S) </H2>
The <A HREF="#RWRELOCCHECK_Option">RWRELOCCHECK</A> option for 16-bit Windows (Win16) executables has been specified and the linker has detected
a segment relocation to a read/write data segment.&nbsp; Where the name of the offending symbol is not available, &quot;identifier
unavailable&quot; is used.

<H2 ID="3137_too_many_errors_encountered"> 3137 too many errors encountered </H2>
This message is issued when the number of error messages issued by the linker exceeds the number specified by the <A HREF="#MAXERRORS_Option">MAXERRORS</A>
option.

<H2 ID="3138_invalid_filename___s_"> 3138 invalid filename '%s' </H2>
The linker performs a simple filename validation whenever a filename is specified to the linker.&nbsp; For example, a directory
specification is not a valid filename.

<H2 ID="3139_cannot_have_both_16Mbit_and_32Mbit_object_files"> 3139 cannot have both 16-bit and 32-bit object files </H2>
It is impossible to mix 16-bit code and 32-bit code in the same executable when generating a QNX executable file.

<H2 ID="1140_invalid_message_number"> 1140 invalid message number </H2>
An invalid message number has been specified in a <A HREF="#DISABLE_Directive">DISABLE</A> directive.

<H2 ID="1141_virtual_function_table_record_for__s_mismatched"> 1141 virtual function table record for %s mismatched </H2>
The linker performs a consistency check to ensure that the C++ compiler has not generated incorrect virtual function information.
&nbsp;If the message is issued, please report this problem.

<H2 ID="2142_section_alignment_greater_than_OBJALIGN"> 2142 section %s alignment (%d) greater than OBJALIGN value </H2>
The linker performs a consistency check to ensure that no section alignment is violated. To avoid the error message, 
decrease the section alignment or increase the value of the <A HREF="#OBJALIGN_Option">OBJALIGN</A> option!

<H2 ID="1143_not_enough_memory_to_sort_map_file_symbols"> 1143 not enough memory to sort map file symbols </H2>
There was not enough memory for the linker to sort the symbols in the &quot;Memory Map&quot; portion of the map file.&nbsp;
This will only occur when the <A HREF="#SORT_Directive">SORT GLOBAL</A> directive has been specified.

<H2 ID="1145__S_is_both_pure_virtual_and_nonMpure_virtual"> 1145 %S is both pure virtual and non-pure virtual </H2>
A function has been declared both as &quot;pure&quot; and &quot;non-pure&quot; virtual.

<H2 ID="2146__s_is_an_invalid_object_file"> 2146 %s is an invalid object file </H2>
Something was encountered in the object file that cannot be processed by the linker.

<H2 ID="3147_Ambiguous_format_specified"> 3147 Ambiguous format specified </H2>
Not enough of the <A HREF="#FORMAT_Directive">FORMAT</A> directive attributes were specified to enable the linker to determine the executable file format.
&nbsp;For example,
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; FORMAT OS2</TT>
<P>will generate this message.

<H2 ID="1148_Invalid_segment_type_specified"> 1148 Invalid segment type specified </H2>
The segment type must be one of CODE or DATA.

<H2 ID="1149_Only_one_debugging_format_can_be_specified"> 1149 Only one debugging format can be specified </H2>
The debugging format must be one of Watcom, CodeView, DWARF (default), or Novell.&nbsp; You cannot specify multiple debugging
formats.

<H2 ID="1150_file__s_has_code_for_a_different_processor"> 1150 file %s has code for a different processor </H2>
An object file has been encountered which contains code compiled for a different processor (e.g., an Intel application
and an Alpha object file).

<H2 ID="2151_big_endian_code_not_supported"> 2151 big endian code not supported </H2>
Big endian code is not supported by the linker.

<H2 ID="2152_no_dictionary_found"> 2152 no dictionary found </H2>
No symbol search dictionary was found in a library that the linker attempted to process.

<H2 ID="2154_cannot_execute__s1____s2"> 2154 cannot execute %s1 :&nbsp; %s2 </H2>
An attempt by the linker to spawn another application failed.&nbsp; The application is specified by &quot;%s1&quot; and
the reason for the failure is specified by &quot;%s2&quot;.

<H2 ID="2155_relocation_at__a_to_an_improperly_aligned_target"> 2155 relocation at %a to an improperly aligned target </H2>
Some relocations in Alpha executables require that the object be aligned on a 4 byte boundary.

<H2 ID="2156_OPTION_INCREMENTAL_must_be_one_of_the_first_directives_specified"> 2156 OPTION INCREMENTAL must be one of the first directives specified </H2>
The <A HREF="#INCREMENTAL_Option">INCREMENTAL</A> option must be specified before any option or directive which modifies the linker's symbol table (e.g., IMPORT, EXPORT,
REFERENCE, ALIAS).

<H2 ID="3157_no_code_or_data_present"> 3157 no code or data present </H2>
The linker requires that there be at least 1 byte of either code or data in the executable.

<H2 ID="1158_problem_adding_resource_information"> 1158 problem adding resource information </H2>
The resource file is invalid or corrupt.

<H2 ID="3159_incremental_linking_only_supports_DWARF_debugging_information"> 3159 incremental linking only supports DWARF debugging information </H2>
When <A HREF="#INCREMENTAL_Option">OPTION INCREMENTAL</A> is used, you cannot specify non-DWARF debugging information for the executable.&nbsp; You must
specify DEBUG DWARF when requesting debugging information.

<H2 ID="3160_incremental_linking_does_not_support_dead_code_elimination"> 3160 incremental linking does not support dead code elimination </H2>
When <A HREF="#INCREMENTAL_Option">OPTION INCREMENTAL</A> is used, you cannot specify <A HREF="#ELIMINATE_Option">OPTION ELIMINATE</A>.

<H2 ID="1163_module_has_not_been_compiled_with_the__zv__option"> 1163 module has not been compiled with the &quot;zv&quot; option </H2>
When <A HREF="#VFREMOVAL_Option">OPTION VFREMOVAL</A> is used, all object files must be compiled with the &quot;zv&quot; option.&nbsp; The linker has detected
an object file that has not been compiled with this option.

<H2 ID="3164_incremental_linking_does_not_support_virtual_function_removal"> 3164 incremental linking does not support virtual function removal </H2>
When <A HREF="#INCREMENTAL_Option">OPTION INCREMENTAL</A> is used, you cannot also specify <A HREF="#VFREMOVAL_Option">OPTION VFREMOVAL</A>.

<H2 ID="1165_resource_file__s_too_big"> 1165 resource file %s too big </H2>
The resource file specified in <A HREF="#RESOURCE_Option">OPTION RESOURCE</A> was too big to fit inside the QNX executable.&nbsp; The maximum size is
approximately 32000 bytes.

<H2 ID="2166_both__s1_and__s2_marked_as_starting_symbols"> 2166 both %s1 and %s2 marked as starting symbols </H2>
If the linker sees that there is more than one starting address specified in the program and they have symbol names associated
with them, it will emit this error message.&nbsp; If there is more than one starting address specified and at least one of
them is unnamed, it will issue message 1030.

<H2 ID="1167_NLM_internal_name_L_sR_truncated"> 1167 NLM internal name (%s) truncated </H2>
This message is issued when generating a NetWare NLM.&nbsp; The output file name as specified by the <A HREF="#NAME_Directive">NAME</A> directive has
specified a long file name (exceeds 8.3).&nbsp; The linker will truncate the generated file name by using the first eight
characters of the specified file name and the first three characters of the file extension (if supplied), separated by a period.

<H2 ID="3168_exactly_one_export_must_exist_for_VxD_format"> 3168 exactly one export must exist for VxD format </H2>
The Windows VxD format requires exactly one export to be present, but an attempt was made to build a VxD module with no
exports or more than one export.

<H2 ID="2169_location_counter_already_beyond_fixed_segment_address__a"> 2169 location counter already beyond fixed segment address %a </H2>
When creating an image using the <A HREF="#OUTPUT_Directive">OUTPUT</A> directive, a segment was specified with an address lower than the current location
counter.&nbsp; This would overlay the segment data with already existing data at the same address, and is not allowed.

<H2 ID="1170_directive__s_can_only_occur_once"> 1170 directive %s can only occur once </H2>
A directive was specified more than once on JWlink command line and was ignored.&nbsp; Remove the redundant
instances of the directive.

<H2 ID="1171_locally_defined_symbol__s_imported"> 1171 locally defined symbol %s imported </H2>
An imported symbol (intended to be imported from a DLL) was resolved locally.&nbsp; The linker will ignore the symbol defined
in a DLL, if provided, and the local reference will be used.&nbsp; Ensure that this is the intended behaviour.

<H2 ID="2172_relocation_requires_option_NOLARGEADDRESSAWARE"> 2172 32-bit relocation to '%s' requires option NOLARGEaddressaware </H2>
A 32-bit direct offset was found in a 64-bit module.
With 32-bit addresses, option <A HREF="#LARGEADDRESSAWARE_Option">NOLARGEADDRESSAWARE</A> must be specified to ensure
the binary will be loaded in the first 2 GB of the address space.

<H2 ID="1173_unknown_directive_ignored"> 1173 unknown directive '-%s' ignored </H2>
An unknown linker directive was found in the .drectve section of a COFF or ELF object module.
<P>
JWlink will assume that the directives found in .drectve will follow the syntax understood
by MS link. Hence JWlink must translate them to its own format. Currently the following
directives are translated:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; -entry:start_label</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; -defaultlib:library_name</TT>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; -export:exported_name[=internal_name]</TT>
<P>Additionally, JWlink will understand and translate:
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; -import:internal_name=module_name[.external_name | ordinal]</TT>
<P>The MS linker has no <TT>-import</TT> directive and also won't understand anymore an IMPORT section
in a module definition file (.DEF) as the 16-bit linker did. Hence this is
currently kind of exclusive JWlink feature.

<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- # -</DT>
<DD><A HREF="#hash_Directive">The # Directive</A></DD>
<DT>- 1 -</DT>
<DD><A HREF="#1014_stack_segment_not_found">1014 stack segment not found</A></DD>
<DD><A HREF="#1019_segment_relocation_at__a">1019 segment relocation at %a</A></DD>
<DD><A HREF="#1023_no_starting_address_found__using__a">1023 no starting address found, using %a</A></DD>
<DD><A HREF="#1027_2027_redefinition_of__S_ignored">1027,2027 redefinition of %S ignored</A></DD>
<DD><A HREF="#1028_2028__S_is_an_undefined_reference">1028,2028 %S is an undefined reference</A></DD>
<DD><A HREF="#1032_record_Ltype_0x_xR_not_processed">1032 record (type 0x%x) not processed</A></DD>
<DD><A HREF="#1038_DEBUG_directive_appears_after_object_files">1038 DEBUG directive appears after object files</A></DD>
<DD><A HREF="#1043_duplicate_exported_ordinal">1043 duplicate exported ordinal</A></DD>
<DD><A HREF="#1044_2044_exported_symbol__s_not_found">1044,2044 exported symbol %s not found</A></DD>
<DD><A HREF="#1045_segment_attribute_defined_more_than_once">1045 segment attribute defined more than once</A></DD>
<DD><A HREF="#1046_segment_name__s_not_found">1046 segment name %s not found</A></DD>
<DD><A HREF="#1047_class_name__s_not_found">1047 class name %s not found</A></DD>
<DD><A HREF="#1048_inconsistent_attributes_for_automatic_data_segment">1048 inconsistent attributes for automatic data segment</A></DD>
<DD><A HREF="#1050_invalid_DLL_specified_in_OLDLIBRARY_option">1050 invalid DLL specified in OLDLIBRARY option</A></DD>
<DD><A HREF="#1054_debugging_information_incompatible__using_line_numbers_only">1054 debugging information incompatible:&nbsp; using line numbers only</A></DD>
<DD><A HREF="#1058__s_option_not_valid_for__s_executable">1058 %s option not valid for %s executable</A></DD>
<DD><A HREF="#1059_2059_value_for__s_too_large">1059,2059 value for %s too large</A></DD>
<DD><A HREF="#1060_value_for__s_incorrect">1060 value for %s incorrect</A></DD>
<DD><A HREF="#1061_multiple_values_specified_for_REALBREAK">1061 multiple values specified for REALBREAK</A></DD>
<DD><A HREF="#1062_export_and_import_records_not_valid_for__f">1062 export and import records not valid for %f</A></DD>
<DD><A HREF="#1069_unload_CHECK_procedure_not_found">1069 unload CHECK procedure not found</A></DD>
<DD><A HREF="#1072_SECTION_directive_not_allowed_in_root">1072 SECTION directive not allowed in root</A></DD>
<DD><A HREF="#1076__s_option_multiply_specified">1076 %s option multiply specified</A></DD>
<DD><A HREF="#1080_file__s_is_a__dMbit_object_file">1080 file %s is a %d-bit object file</A></DD>
<DD><A HREF="#1087_stack_segment_ignored_in__COM_file">1087 stack segment ignored in .COM file</A></DD>
<DD><A HREF="#1090_redefinition_of__s_by__s_ignored">1090 redefinition of %s by %s ignored</A></DD>
<DD><A HREF="#1098_Offset_option_must_be_a_multiple_of__dK">1098 Offset option must be a multiple of %dK</A></DD>
<DD><A HREF="#1101_invalid_incremental_information_file">1101 invalid incremental information file</A></DD>
<DD><A HREF="#1102_object_file__s_not_found_for_tracing">1102 object file %s not found for tracing</A></DD>
<DD><A HREF="#1103_library_module__sL_sR_not_found_for_tracing">1103 library module %s(%s) not found for tracing</A></DD>
<DD><A HREF="#1105_cannot_reserve__l_bytes_of_extra_overlay_space">1105 cannot reserve %l bytes of extra overlay space</A></DD>
<DD><A HREF="#1107_undefined_system_name___s">1107 undefined system name:&nbsp; %s</A></DD>
<DD><A HREF="#1108_system__s_defined_more_than_once">1108 system %s defined more than once</A></DD>
<DD><A HREF="#1109_OFFSET_option_is_less_than_the_stack_size">1109 OFFSET option is less than the stack size</A></DD>
<DD><A HREF="#1110_library_members_not_allowed_in_libfile">1110 library members not allowed in libfile</A></DD>
<DD><A HREF="#1111_error_in_default_system_block">1111 error in default system block</A></DD>
<DD><A HREF="#1115_environment_name__s_not_found">1115 environment name %s not found</A></DD>
<DD><A HREF="#1116_overlay_area_must_be_at_least__l_bytes">1116 overlay area must be at least %l bytes</A></DD>
<DD><A HREF="#1117_segment_number_too_high_for_a_movable_entry_point">1117 segment number too high for a movable entry point</A></DD>
<DD><A HREF="#1118_heap_size_too_large">1118 heap size too large</A></DD>
<DD><A HREF="#1121___s__has_already_been_exported">1121 '%s' has already been exported</A></DD>
<DD><A HREF="#1124_lazy_reference_for__S_has_different_default_resolutions">1124 lazy reference for %S has different default resolutions</A></DD>
<DD><A HREF="#1125_multiple_aliases_found_for__S">1125 multiple aliases found for %S</A></DD>
<DD><A HREF="#1126__s_has_been_modified__doing_full_relink">1126 %s has been modified:&nbsp; doing full relink</A></DD>
<DD><A HREF="#1130__s_is_an_invalid_shared_nlm_file">1130 %s is an invalid shared nlm file</A></DD>
<DD><A HREF="#1133_no_realbreak_specified_for_16Mbit_code">1133 no realbreak specified for 16-bit code</A></DD>
<DD><A HREF="#1134__s_is_an_invalid_message_file">1134 %s is an invalid message file</A></DD>
<DD><A HREF="#1136_segment_relocation_to_a_readDwrite_data_segment_found_at__aL_SR">1136 segment relocation to a read/write data segment found at %a(%S)</A></DD>
<DD><A HREF="#1140_invalid_message_number">1140 invalid message number</A></DD>
<DD><A HREF="#1141_virtual_function_table_record_for__s_mismatched">1141 virtual function table record for %s mismatched</A></DD>
<DD><A HREF="#1143_not_enough_memory_to_sort_map_file_symbols">1143 not enough memory to sort map file symbols</A></DD>
<DD><A HREF="#1145__S_is_both_pure_virtual_and_nonMpure_virtual">1145 %S is both pure virtual and non-pure virtual</A></DD>
<DD><A HREF="#1148_Invalid_segment_type_specified">1148 Invalid segment type specified</A></DD>
<DD><A HREF="#1149_Only_one_debugging_format_can_be_specified">1149 Only one debugging format can be specified</A></DD>
<DD><A HREF="#1150_file__s_has_code_for_a_different_processor">1150 file %s has code for a different processor</A></DD>
<DD><A HREF="#1158_problem_adding_resource_information">1158 problem adding resource information</A></DD>
<DD><A HREF="#1163_module_has_not_been_compiled_with_the__zv__option">1163 module has not been compiled with the &quot;zv&quot; option</A></DD>
<DD><A HREF="#1165_resource_file__s_too_big">1165 resource file %s too big</A></DD>
<DD><A HREF="#1167_NLM_internal_name_L_sR_truncated">1167 NLM internal name (%s) truncated</A></DD>
<DD><A HREF="#1170_directive__s_can_only_occur_once">1170 directive %s can only occur once</A></DD>
<DD><A HREF="#1171_locally_defined_symbol__s_imported">1171 locally defined symbol %s imported</A></DD>
<DD><A HREF="#1173_unknown_directive_ignored">1173 unknown directive '-%s' ignored</A></DD>
<DT>- 2 -</DT>
<DD><A HREF="#2002_TT_internal_TT_M__s">2002 ** internal ** - %s</A></DD>
<DD><A HREF="#2008_cannot_open__s1____s2">2008 cannot open %s1 :&nbsp; %s2</A></DD>
<DD><A HREF="#2010_3010_IDO_error_processing__s1____s2">2010,3010 I/O error processing %s1 :&nbsp; %s2</A></DD>
<DD><A HREF="#2011_invalid_object_file_attribute">2011 invalid object file attribute</A></DD>
<DD><A HREF="#2012_invalid_library_file_attribute">2012 invalid library file attribute</A></DD>
<DD><A HREF="#2015_bad_relocation_type_specified">2015 bad relocation type specified</A></DD>
<DD><A HREF="#2016__a__absolute_target_invalid_for_selfMrelative_relocation">2016 %a:&nbsp; absolute target invalid for self-relative relocation</A></DD>
<DD><A HREF="#2017_bad_location_specified_for_selfMrelative_relocation_at__a">2017 bad location specified for self-relative relocation at %a</A></DD>
<DD><A HREF="#2018_relocation_offset_at__a_is_out_of_range">2018 relocation offset at %a is out of range</A></DD>
<DD><A HREF="#2020_size_of_group__s_exceeds_64k_by__l_bytes">2020 size of group %s exceeds 64k by %l bytes</A></DD>
<DD><A HREF="#2021_size_of_segment__s_exceeds_64k_by__l_bytes">2021 size of segment %s exceeds 64k by %l bytes</A></DD>
<DD><A HREF="#2022_cannot_have_a_starting_address_with_an_imported_symbol">2022 cannot have a starting address with an imported symbol</A></DD>
<DD><A HREF="#2024_missing_overlay_loader">2024 missing overlay loader</A></DD>
<DD><A HREF="#2025_short_vector__d_is_out_of_range">2025 short vector %d is out of range</A></DD>
<DD><A HREF="#2026_redefinition_of_reserved_symbol__s">2026 redefinition of reserved symbol %s</A></DD>
<DD><A HREF="#2029_premature_end_of_file_encountered">2029 premature end of file encountered</A></DD>
<DD><A HREF="#1030_multiple_starting_addresses_found">1030 multiple starting addresses found</A></DD>
<DD><A HREF="#2031_segment__s_is_in_group__s_and_group__s">2031 segment %s is in group %s and group %s</A></DD>
<DD><A HREF="#2033_3033_directive_error_near___s_">2033,3033 directive error near '%s'</A></DD>
<DD><A HREF="#2034__a_cannot_have_an_offset_with_an_imported_symbol">2034 %a cannot have an offset with an imported symbol</A></DD>
<DD><A HREF="#2039_ALIGNMENT_value_too_small">2039 ALIGNMENT value too small</A></DD>
<DD><A HREF="#2040_ordinal_in_IMPORT_directive_not_valid">2040 ordinal in IMPORT directive not valid</A></DD>
<DD><A HREF="#2041_ordinal_in_EXPORT_directive_not_valid">2041 ordinal in EXPORT directive not valid</A></DD>
<DD><A HREF="#2042_too_many_IOPL_words_in_EXPORT_directive">2042 too many IOPL words in EXPORT directive</A></DD>
<DD><A HREF="#2049_invalid_STUB_file">2049 invalid STUB file</A></DD>
<DD><A HREF="#2051_STUB_file_name_same_as_executable_file_name">2051 STUB file name same as executable file name</A></DD>
<DD><A HREF="#2052_relocation_at__a_not_in_the_same_segment">2052 relocation at %a not in the same segment</A></DD>
<DD><A HREF="#2053__a__cannot_reach_a_DLL_with_a_relative_relocation">2053 %a:&nbsp; cannot reach a DLL with a relative relocation</A></DD>
<DD><A HREF="#2055__a__frame_must_be_the_same_as_the_target_in_protected_mode">2055 %a:&nbsp; frame must be the same as the target in protected mode</A></DD>
<DD><A HREF="#2056_cannot_find_library_member__sL_sR">2056 cannot find library member %s(%s)</A></DD>
<DD><A HREF="#2063_invalid_relocation_for_flat_memory_model_at__a">2063 invalid relocation for flat memory model at %a</A></DD>
<DD><A HREF="#2064_cannot_combine_32Mbit_segments_L_s1R_with_16Mbit_segments_L_s2R">2064 cannot combine 32-bit segments (%s1) with 16-bit segments (%s2)</A></DD>
<DD><A HREF="#2065_REALBREAK_symbol__s_not_found">2065 REALBREAK symbol %s not found</A></DD>
<DD><A HREF="#2066_invalid_relative_relocation_type_for_an_import_at__a">2066 invalid relative relocation type for an import at %a</A></DD>
<DD><A HREF="#2067__a__cannot_relocate_between_code_and_data_in_Novell_formats">2067 %a:&nbsp; cannot relocate between code and data in Novell formats</A></DD>
<DD><A HREF="#2068_absolute_segment_fixup_not_valid_in_protected_mode">2068 absolute segment fixup not valid in protected mode</A></DD>
<DD><A HREF="#2070_START_procedure_not_found">2070 START procedure not found</A></DD>
<DD><A HREF="#2071_EXIT_procedure_not_found">2071 EXIT procedure not found</A></DD>
<DD><A HREF="#2073_bad_Novell_file_format_specified">2073 bad Novell file format specified</A></DD>
<DD><A HREF="#2074_circular_alias_found_for__s">2074 circular alias found for %s</A></DD>
<DD><A HREF="#2075_expecting_an_END_directive">2075 expecting an END directive</A></DD>
<DD><A HREF="#2082_invalid_record_type_0x_x">2082 invalid record type 0x%x</A></DD>
<DD><A HREF="#2083_cannot_reference_address__a_from_frame__x">2083 cannot reference address %a from frame %x</A></DD>
<DD><A HREF="#2084_target_offset_exceeds_64K_at__a">2084 target offset exceeds 64K at %a</A></DD>
<DD><A HREF="#2086_invalid_starting_address_for__COM_file">2086 invalid starting address for .COM file</A></DD>
<DD><A HREF="#1089_program_too_large_for_a__COM_file">1089 program too large for a .COM file</A></DD>
<DD><A HREF="#2091_group__s_is_in_more_than_one_overlay">2091 group %s is in more than one overlay</A></DD>
<DD><A HREF="#2092_NEWSEGMENT_directive_appears_before_object_files">2092 NEWSEGMENT directive appears before object files</A></DD>
<DD><A HREF="#2093_cannot_open__s">2093 cannot open %s</A></DD>
<DD><A HREF="#2094_iDo_error_processing__s">2094 i/o error processing %s</A></DD>
<DD><A HREF="#2099_symbol_name_too_long___s">2099 symbol name too long:&nbsp; %s</A></DD>
<DD><A HREF="#2119_jwlib_import_statement_incorrect">2119 jwlib import statement incorrect</A></DD>
<DD><A HREF="#2120_application_too_large_to_run_under_DOS">2120 application too large to run under DOS</A></DD>
<DD><A HREF="#2127_cannot_export_symbol__S">2127 cannot export symbol %S</A></DD>
<DD><A HREF="#2132_curly_brace_delimited_list_incorrect">2132 curly brace delimited list incorrect</A></DD>
<DD><A HREF="#2146__s_is_an_invalid_object_file">2146 %s is an invalid object file</A></DD>
<DD><A HREF="#2151_big_endian_code_not_supported">2151 big endian code not supported</A></DD>
<DD><A HREF="#2152_no_dictionary_found">2152 no dictionary found</A></DD>
<DD><A HREF="#2154_cannot_execute__s1____s2">2154 cannot execute %s1 :&nbsp; %s2</A></DD>
<DD><A HREF="#2155_relocation_at__a_to_an_improperly_aligned_target">2155 relocation at %a to an improperly aligned target</A></DD>
<DD><A HREF="#2156_OPTION_INCREMENTAL_must_be_one_of_the_first_directives_specified">2156 OPTION INCREMENTAL must be one of the first directives specified</A></DD>
<DD><A HREF="#2166_both__s1_and__s2_marked_as_starting_symbols">2166 both %s1 and %s2 marked as starting symbols</A></DD>
<DD><A HREF="#2169_location_counter_already_beyond_fixed_segment_address__a">2169 location counter already beyond fixed segment address %a</A></DD>
<DD><A HREF="#2172_relocation_requires_option_NOLARGEADDRESSAWARE">2172 32-bit relocation to '%s' requires option NOLARGEaddressaware"</A></DD>
<DT>- 3 -</DT>
<DD><A HREF="#3009_dynamic_memory_exhausted">3009 dynamic memory exhausted</A></DD>
<DD><A HREF="#3013_break_key_detected">3013 break key detected</A></DD>
<DD><A HREF="#3057_executable_format_has_been_established">3057 executable format has been established</A></DD>
<DD><A HREF="#3088_virtual_memory_exhausted">3088 virtual memory exhausted</A></DD>
<DD><A HREF="#3097_too_many_library_modules">3097 too many library modules</A></DD>
<DD><A HREF="#3106_borland_virdef_unsupported">3106 Borland VIRDEF record not supported</A></DD>
<DD><A HREF="#3114_environment_name_specified_incorrectly">3114 environment name specified incorrectly</A></DD>
<DD><A HREF="#3122_no_FILE_directives_found">3122 no FILE directives found</A></DD>
<DD><A HREF="#3123_overlays_are_not_supported_in_this_version_of_the_linker">3123 overlays are not supported in this version of the linker</A></DD>
<DD><A HREF="#3128_directive_error_near_beginning_of_input">3128 directive error near beginning of input</A></DD>
<DD><A HREF="#3129_address_information_too_large">3129 address information too large</A></DD>
<DD><A HREF="#3131_cannot_open_spill_file__file_already_exists">3131 cannot open spill file:&nbsp; file already exists</A></DD>
<DD><A HREF="#3135_need_exactly_1_overlay_area_with_dynamic_overlay_manager">3135 need exactly 1 overlay area with dynamic overlay manager</A></DD>
<DD><A HREF="#3137_too_many_errors_encountered">3137 too many errors encountered</A></DD>
<DD><A HREF="#3138_invalid_filename___s_">3138 invalid filename '%s'</A></DD>
<DD><A HREF="#3139_cannot_have_both_16Mbit_and_32Mbit_object_files">3139 cannot have both 16-bit and 32-bit object files</A></DD>
<DD><A HREF="#3147_Ambiguous_format_specified">3147 Ambiguous format specified</A></DD>
<DD><A HREF="#3157_no_code_or_data_present">3157 no code or data present</A></DD>
<DD><A HREF="#3159_incremental_linking_only_supports_DWARF_debugging_information">3159 incremental linking only supports DWARF debugging information</A></DD>
<DD><A HREF="#3160_incremental_linking_does_not_support_dead_code_elimination">3160 incremental linking does not support dead code elimination</A></DD>
<DD><A HREF="#3164_incremental_linking_does_not_support_virtual_function_removal">3164 incremental linking does not support virtual function removal</A></DD>
<DD><A HREF="#3168_exactly_one_export_must_exist_for_VxD_format">3168 exactly one export must exist for VxD format</A></DD>
<DT>- @ -</DT>
<DD><A HREF="#atsign_Directive">The @ Directive</A>
<DT>- A -</DT>
<DD><A HREF="#ALIAS_Directive">The ALIAS Directive</A></DD>
<DD><A HREF="#ALIGNMENT_Option">The ALIGNMENT Option</A></DD>
<DD><A HREF="#All_Debugging_Information_M_DEBUG_WATCOM_ALL">All Debugging Information - DEBUG WATCOM ALL</A></DD>
<DD><A HREF="#ANONYMOUSEXPORT_Directive">The ANONYMOUSEXPORT Directive</A></DD>
<DD><A HREF="#AREA_Option">The AREA Option</A></DD>
<DD><A HREF="#ARTIFICIAL_Option">The ARTIFICIAL Option</A></DD>
<DD><A HREF="#AUTOSECTION_Directive">The AUTOSECTION Directive</A></DD>
<DD><A HREF="#AUTOUNLOAD_Option">The AUTOUNLOAD Option</A></DD>
<DT>- B -</DT>
<DD><A HREF="#BEGIN_Directive">The BEGIN Directive</A></DD>
<DT>- C -</DT>
<DD><A HREF="#CACHE_Option">The CACHE Option</A></DD>
<DD><A HREF="#CASEEXACT_Option">The CASEEXACT Option</A></DD>
<DD><A HREF="#CHECK_Option">The CHECK Option</A></DD>
<DD><A HREF="#CHECKSUM_Option">The CHECKSUM Option</A></DD>
<DD><A HREF="#COMMIT_Directive">The COMMIT Directive</A></DD>
<DD><A HREF="#Converting_Libraries_Created_using_Phar_Lap_386_LIB">Converting Libraries Created using Phar Lap 386|LIB</A></DD>
<DD><A HREF="#COPYRIGHT_Option">The COPYRIGHT Option</A></DD>
<DD><A HREF="#CUSTOM_Option">The CUSTOM Option</A></DD>
<DD><A HREF="#CVPACK_Option">The CVPACK Option</A></DD>
<DT>- D -</DT>
<DD><A HREF="#DEBUG_Directive">The DEBUG Directive</A></DD>
<DD><A HREF="#DESCRIPTION_Option">The DESCRIPTION Option</A></DD>
<DD><A HREF="#DISABLE_Directive">The DISABLE Directive</A></DD>
<DD><A HREF="#DISTRIBUTE_Option">The DISTRIBUTE Option</A></DD>
<DD><A HREF="#Converting_Microsoft_Response_Files_to_Directive_Files">DOS:&nbsp; Converting Microsoft Response Files to Directive Files</A></DD>
<DD><A HREF="#DOS__Defining_Overlay_Structures">DOS:&nbsp; Defining Overlay Structures</A></DD>
<DD><A HREF="#DOS__How_Overlay_Files_are_Opened">DOS:&nbsp; How Overlay Files are Opened</A></DD>
<DD><A HREF="#DOS__Increasing_the_Dynamic_Overlay_Area">DOS:&nbsp; Increasing the Dynamic Overlay Area</A></DD>
<DD><A HREF="#DOS__Memory_Layout">DOS:&nbsp; Memory Layout</A></DD>
<DD><A HREF="#DOS__Nested_Overlay_Structures">DOS:&nbsp; Nested Overlay Structures</A></DD>
<DD><A HREF="#DOS__Rules_About_Overlays">DOS:&nbsp; Rules About Overlays</A></DD>
<DD><A HREF="#DOS_Executable_File_Format">DOS Executable File Format</A></DD>
<DD><A HREF="#DOS__The_Dynamic_Overlay_Manager">DOS:&nbsp; The Dynamic Overlay Manager</A></DD>
<DD><A HREF="#DOS__JWlink_Memory_Requirements">DOS:&nbsp; JWlink Memory Requirements</A></DD>
<DD><A HREF="#DOS__Using_Overlays">DOS:&nbsp; Using Overlays</A></DD>
<DD><A HREF="#DOSSEG_Option">The DOSSEG Option</A></DD>
<DD><A HREF="#DYNAMIC_Option">The DYNAMIC Option</A></DD>
<DT>- E -</DT>
<DD><A HREF="#ELF__Memory_Layout">ELF:&nbsp; Memory Layout</A></DD>
<DD><A HREF="#ELF_Executable_File_Format">ELF Executable File Format</A></DD>
<DD><A HREF="#ELIMINATE_Option">The ELIMINATE Option</A></DD>
<DD><A HREF="#END_Directive">The END Directive</A></DD>
<DD><A HREF="#ENDLINK_Directive">The ENDLINK Directive</A></DD>
<DD><A HREF="#EXIT_Option">The EXIT Option</A></DD>
<DD><A HREF="#EXPORT_M_ELF_only">EXPORT - ELF only</A></DD>
<DD><A HREF="#EXPORT_M_Netware_only">EXPORT - Netware only</A></DD>
<DD><A HREF="#EXPORT_M_OSD2__Win16__Win32_only">EXPORT - OS/2, Win16, Win32/Win64 only</A></DD>
<DD><A HREF="#EXPORT_Directive">The EXPORT Directive</A></DD>
<DD><A HREF="#EXPORTALL_Option">The EXPORTALL Option</A></DD>
<DT>- F -</DT>
<DD><A HREF="#FARCALLS_Option">The FARCALLS Option</A></DD>
<DD><A HREF="#FILE_Directive">The FILE Directive</A></DD>
<DD><A HREF="#FILLCHAR_Option">The FILLCHAR Option</A></DD>
<DD><A HREF="#FIXEDLIB_Directive">The FIXEDLIB Directive</A></DD>
<DD><A HREF="#FORCEVECTOR_Directive">The FORCEVECTOR Directive</A></DD>
<DD><A HREF="#FORMAT_Directive">The FORMAT Directive</A></DD>
<DT>- G -</DT>
<DD><A HREF="#Global_Symbol_Information">Global Symbol Information</A></DD>
<DD><A HREF="#Global_Symbols_for_the_NetWare_Debugger_M_DEBUG_NOVELL">Global Symbols for the NetWare Debugger - DEBUG NOVELL</A></DD>
<DT>- H -</DT>
<DD><A HREF="#HEAPSIZE_Option">The HEAPSIZE Option</A></DD>
<DD><A HREF="#HELP_Option">The HELP Option</A></DD>
<DD><A HREF="#HSHIFT_Option">The HSHIFT Option</A></DD>
<DT>- I -</DT>
<DD><A HREF="#IMPFILE_Option">The IMPFILE Option</A></DD>
<DD><A HREF="#IMPLIB_Option">The IMPLIB Option</A></DD>
<DD><A HREF="#IMPORT_M_ELF_only">IMPORT - ELF only</A></DD>
<DD><A HREF="#IMPORT_M_Netware_only">IMPORT - Netware only</A></DD>
<DD><A HREF="#IMPORT_M_OSD2__Win16__Win32_only">IMPORT - OS/2, Win16, Win32/Win64 only</A></DD>
<DD><A HREF="#IMPORT_Directive">The IMPORT Directive</A></DD>
<DD><A HREF="#INCREMENTAL_Option">The INCREMENTAL Option</A></DD>
<DD><A HREF="#INTERNALRELOCS_Option">The INTERNALRELOCS Option</A></DD>
<DT>- K -</DT>
<DD><A HREF="#KNOWEAS_Option">The KNOWEAS Option</A></DD>
<DT>- L -</DT>
<DD><A HREF="#LANGUAGE_Directive">The LANGUAGE Directive</A></DD>
<DD><A HREF="#LARGEADDRESSAWARE_Option">The LARGEADDRESSAWARE Option</A></DD>
<DD><A HREF="#LIBFILE_Directive">The LIBFILE Directive</A></DD>
<DD><A HREF="#LIBPATH_Directive">The LIBPATH Directive</A></DD>
<DD><A HREF="#LIBRARY_Directive">The LIBRARY Directive</A></DD>
<DD><A HREF="#Line_Numbering_Information_M_DEBUG_WATCOM_LINES">Line Numbering Information - DEBUG WATCOM LINES</A></DD>
<DD><A HREF="#LINEARRELOCS_Option">The LINEARRELOCS Option</A></DD>
<DD><A HREF="#Linker_Directives_and_Options">Linker Directives and Options</A></DD>
<DD><A HREF="#Linking_16Mbit_Executable_Files">Linking 16-bit Executable Files</A></DD>
<DD><A HREF="#Linking_DOS_16Mbit_Executable_Files">Linking DOS 16-bit Executable Files</A></DD>
<DD><A HREF="#Linking_DOSMextended_16Mbit_HX_Executable_Files">Linking DOS-extended 16-bit HX Executable Files</A></DD>
<DD><A HREF="#Linking_OSD2_16Mbit_Dynamic_Link_Libraries">Linking OS/2 16-bit Dynamic Link Libraries</A></DD>
<DD><A HREF="#Linking_OSD2_16Mbit_Executable_Files">Linking OS/2 16-bit Executable Files</A></DD>
<DD><A HREF="#Linking_Windows_3_x_16Mbit_Dynamic_Link_Libraries">Linking Windows 3.x 16-bit Dynamic Link Libraries</A></DD>
<DD><A HREF="#Linking_Windows_3_x_16Mbit_Executable_Files">Linking Windows 3.x 16-bit Executable Files</A></DD>
<DD><A HREF="#Linking_32Mbit_Executable_Files">Linking 32- and 64-bit x86 Executable Files</A></DD>
<DD><A HREF="#Linking_DOSMextended_32Mbit_CauseWay_Executable_Files">Linking DOS-extended 32-bit CauseWay Executable Files</A></DD>
<DD><A HREF="#Linking_DOSMextended_32Mbit_CauseWay_Dynamic_Link_Libraries">Linking DOS-extended 32-bit CauseWay Dynamic Link Libraries</A></DD>
<DD><A HREF="#Linking_DOSMextended_32Mbit_HX_Executable_Files">Linking DOS-extended 32-bit HX Executable Files</A></DD>
<DD><A HREF="#Linking_DOSMextended_32Mbit_HX_Executable_Files_Win32stat">Linking DOS-extended 32-bit HX Binaries (static Win32 Emulation )</A></DD>
<DD><A HREF="#Linking_DOSMextended_32Mbit_HX_Dynamic_Link_Libraries">Linking DOS-extended 32-bit HX Dynamic Link Libraries</A></DD>
<DD><A HREF="#Linking_OSD2_32Mbit_Dynamic_Link_Libraries">Linking OS/2 32-bit Dynamic Link Libraries</A></DD>
<DD><A HREF="#Linking_OSD2_32Mbit_Executable_Files">Linking OS/2 32-bit Executable Files</A></DD>
<DD><A HREF="#Linking_OSD2_32Mbit_Presentation_Manager_Executable_Files">Linking OS/2 32-bit Presentation Manager Executable Files</A></DD>
<DD><A HREF="#Linking_Windows_3_x_or_9x_32Mbit_Virtual_Device_Driver">Linking Windows 3.x or 9x 32-bit Virtual Device Driver (VxD)</A></DD>
<DD><A HREF="#Linking_Win32DWin64_CharacterMMode_Executable_Files">Linking Win32/Win64 Console Executable Files</A></DD>
<DD><A HREF="#Linking_Win32DWin64_Windowed_Executable_Files">Linking Win32/Win64 GUI Executable Files</A></DD>
<DD><A HREF="#Linking_Win32DWin64_Dynamic_Link_Libraries">Linking Win32/Win64 Dynamic Link Libraries</A></DD>
<DD><A HREF="#Linking_Executable_Files_for_Various_Systems">Linking Executable Files for Various Systems</A></DD>
<DD><A HREF="#LINKVERSION_Option">The LINKVERSION Option</A></DD>
<DD><A HREF="#Local_Symbol_Information_M_DEBUG_WATCOM_LOCALS">Local Symbol Information - DEBUG WATCOM LOCALS</A></DD>
<DD><A HREF="#LONGLIVED_Option">The LONGLIVED Option</A></DD>
<DT>- M -</DT>
<DD><A HREF="#MANGLEDNAMES_Option">The MANGLEDNAMES Option</A></DD>
<DD><A HREF="#MANYAUTODATA_Option">The MANYAUTODATA Option</A></DD>
<DD><A HREF="#MAP_Option">The MAP Option</A></DD>
<DD><A HREF="#MAXDATA_Option">The MAXDATA Option</A></DD>
<DD><A HREF="#MAXERRORS_Option">The MAXERRORS Option</A></DD>
<DD><A HREF="#MESSAGES_Option">The MESSAGES Option</A></DD>
<DD><A HREF="#MINDATA_Option">The MINDATA Option</A></DD>
<DD><A HREF="#MIXED1632_Option">The MIXED1632 Option</A></DD>
<DD><A HREF="#MODFILE_Directive">The MODFILE Directive</A></DD>
<DD><A HREF="#MODNAME_Option">The MODNAME Option</A></DD>
<DD><A HREF="#MODTRACE_Directive">The MODTRACE Directive</A></DD>
<DD><A HREF="#MODULE_Directive">The MODULE Directive</A></DD>
<DD><A HREF="#MULTILOAD_Option">The MULTILOAD Option</A></DD>
<DT>- N -</DT>
<DD><A HREF="#NAME_Directive">The NAME Directive</A></DD>
<DD><A HREF="#NAMELEN_Option">The NAMELEN Option</A></DD>
<DD><A HREF="#NetWare__Memory_Layout">NetWare:&nbsp; Memory Layout</A></DD>
<DD><A HREF="#NetWare__NetWare_Loadable_Modules">NetWare:&nbsp; NetWare Loadable Modules</A></DD>
<DD><A HREF="#NetWare__The_NetWare_ODS_Executable_File_Format">NetWare:&nbsp; The NetWare O/S Executable File Format</A></DD>
<DD><A HREF="#NEWFILES_Option">The NEWFILES Option</A></DD>
<DD><A HREF="#NEWSEGMENT_Directive">The NEWSEGMENT Directive</A></DD>
<DD><A HREF="#NLMFLAGS_Option">The NLMFLAGS Option</A></DD>
<DD><A HREF="#NOAUTODATA_Option">The NOAUTODATA Option</A></DD>
<DD><A HREF="#NODEFAULTLIBS_Option">The NODEFAULTLIBS Option</A></DD>
<DD><A HREF="#NOEXTENSION_Option">The NOEXTENSION Option</A></DD>
<DD><A HREF="#NOINDIRECT_Option">The NOINDIRECT Option</A></DD>
<DD><A HREF="#NOLARGEADDRESSAWARE_Option">The NOLARGEADDRESSAWARE Option</A></DD>
<DD><A HREF="#NORELOCS_Option">The NORELOCS Option</A></DD>
<DD><A HREF="#NOSTDCALL_Option">The NOSTDCALL Option</A></DD>
<DD><A HREF="#NOSTUB_Option">The NOSTUB Option</A></DD>
<DD><A HREF="#NOVECTOR_Directive">The NOVECTOR Directive</A></DD>
<DD><A HREF="#NXCOMPAT_Option">The NXCOMPAT Option</A></DD>
<DT>- O -</DT>
<DD><A HREF="#OBJALIGN_Option">The OBJALIGN Option</A></DD>
<DD><A HREF="#OFFSET_M_OSD2__Win32__ELF_only">OFFSET - OS/2, Win32/Win64, ELF only</A></DD>
<DD><A HREF="#OFFSET_M_PharLap_only">OFFSET - PharLap only</A></DD>
<DD><A HREF="#OFFSET_M_QNX_only">OFFSET - QNX only</A></DD>
<DD><A HREF="#OFFSET_M_RAW_only">OFFSET - RAW only</A></DD>
<DD><A HREF="#OFFSET_Option">The OFFSET Option</A></DD>
<DD><A HREF="#OLDLIBRARY_Option">The OLDLIBRARY Option</A></DD>
<DD><A HREF="#ONEAUTODATA_Option">The ONEAUTODATA Option</A></DD>
<DD><A HREF="#ONLYEXPORTS_Debugging_Option">The ONLYEXPORTS Debugging Option</A></DD>
<DD><A HREF="#About_JWlink">About JWlink</A></DD>
<DD><A HREF="#JWlink_Diagnostic_Messages">JWlink Diagnostic Messages</A></DD>
<DD><A HREF="#OPTION_Directive">The OPTION Directive</A></DD>
<DD><A HREF="#OPTLIB_Directive">The OPTLIB Directive</A></DD>
<DD><A HREF="#ORDER_Directive">The ORDER Directive</A></DD>
<DD><A HREF="#OSD2__Creating_a_Dynamic_Link_Library">OS/2:&nbsp; Creating a Dynamic Link Library</A></DD>
<DD><A HREF="#OSD2__Dynamic_Link_Libraries">OS/2:&nbsp; Dynamic Link Libraries</A></DD>
<DD><A HREF="#OSD2__Memory_Layout">OS/2:&nbsp; Memory Layout</A></DD>
<DD><A HREF="#OSD2_Executable_and_DLL_File_Formats">OS/2 Executable and DLL File Formats</A></DD>
<DD><A HREF="#OSD2__Using_a_Dynamic_Link_Library">Using a Dynamic Link Library in OS/2</A></DD>
<DD><A HREF="#OSDOMAIN_Option">The OSDOMAIN Option</A></DD>
<DD><A HREF="#OSNAME_Option">The OSNAME Option</A></DD>
<DD><A HREF="#OSVERSION_Option">The OSVERSION Option</A></DD>
<DD><A HREF="#OUTPUT_Directive">The OUTPUT Directive</A></DD>
<DD><A HREF="#OVERLAY_Directive">The OVERLAY Directive</A></DD>
<DT>- P -</DT>
<DD><A HREF="#PACKCODE_Option">The PACKCODE Option</A></DD>
<DD><A HREF="#PACKDATA_Option">The PACKDATA Option</A></DD>
<DD><A HREF="#PATH_Directive">The PATH Directive</A></DD>
<DD><A HREF="#Phar_Lap__32Mbit_ProtectedMMode_Applications">Phar Lap:&nbsp; 32-bit Protected-Mode Applications</A></DD>
<DD><A HREF="#Phar_Lap__Memory_Layout">Phar Lap:&nbsp; Memory Layout</A></DD>
<DD><A HREF="#Phar_Lap__Memory_Usage">Phar Lap:&nbsp; Memory Usage</A></DD>
<DD><A HREF="#Phar_Lap__JWlink_Memory_Requirements">Phar Lap:&nbsp; JWlink Memory Requirements</A></DD>
<DD><A HREF="#Phar_Lap__The_Phar_Lap_Executable_File_Format">Phar Lap:&nbsp; The Phar Lap Executable File Format</A></DD>
<DD><A HREF="#PRIVILEGE_Option">The PRIVILEGE Option</A></DD>
<DD><A HREF="#PROTMODE_Option">The PROTMODE Option</A></DD>
<DD><A HREF="#PSEUDOPREEMPTION_Option">The PSEUDOPREEMPTION Option</A></DD>
<DT>- Q -</DT>
<DD><A HREF="#QNX__Memory_Layout">QNX:&nbsp; Memory Layout</A></DD>
<DD><A HREF="#QNX__The_QNX_Executable_File_Format">QNX:&nbsp; The QNX Executable File Format</A></DD>
<DD><A HREF="#QUIET_Option">The QUIET Option</A></DD>
<DT>- R -</DT>
<DD><A HREF="#RAW__Memory_Layout">RAW:&nbsp; Memory Layout</A></DD>
<DD><A HREF="#RAW__JWlink_Memory_Requirements">RAW:&nbsp; JWlink Memory Requirements</A></DD>
<DD><A HREF="#RAW__The_RAW_File_Format">RAW:&nbsp; The RAW File Format</A></DD>
<DD><A HREF="#REDEFSOK_Option">The REDEFSOK Option</A></DD>
<DD><A HREF="#REENTRANT_Option">The REENTRANT Option</A></DD>
<DD><A HREF="#REFERENCE_Directive">The REFERENCE Directive</A></DD>
<DD><A HREF="#Removing_Debugging_Information_from_an_Executable_File">Removing Debugging Information from an Executable File</A></DD>
<DD><A HREF="#RESOURCE_M_OSD2__Win16__Win32_only">RESOURCE - OS/2, Win16, Win32/Win64 only</A></DD>
<DD><A HREF="#RESOURCE_M_QNX_only">RESOURCE - QNX only</A></DD>
<DD><A HREF="#RESOURCE_Directive">The RESOURCE Directive</A></DD>
<DD><A HREF="#RESOURCE_Option">The RESOURCE Option</A></DD>
<DD><A HREF="#RUNTIME_M_ELF_only">RUNTIME - ELF only</A></DD>
<DD><A HREF="#RUNTIME_M_PharLap_only">RUNTIME - PharLap only</A></DD>
<DD><A HREF="#RUNTIME_M_Win32_only">RUNTIME - Win32/Win64 only</A></DD>
<DD><A HREF="#RUNTIME_Directive">The RUNTIME Directive</A></DD>
<DD><A HREF="#RWRELOCCHECK_Option">The RWRELOCCHECK Option</A></DD>
<DT>- S -</DT>
<DD><A HREF="#SCREENNAME_Option">The SCREENNAME Option</A></DD>
<DD><A HREF="#Searching_for_Libraries_Specified_in_Environment_Variables">Searching for Libraries Specified in Environment Variables</A></DD>
<DD><A HREF="#Searching_for_Optional_Libraries_Specified_in_Environment_Variables">Searching for Optional Libraries Specified in Environment Variables</A></DD>
<DD><A HREF="#SECTION_Directive">The SECTION Directive</A></DD>
<DD><A HREF="#SEGMENT_Directive">The SEGMENT Directive</A></DD>
<DD><A HREF="#SHARELIB_Option">The SHARELIB Option</A></DD>
<DD><A HREF="#SHOWDEAD_Option">The SHOWDEAD Option</A></DD>
<DD><A HREF="#SMALL_Option">The SMALL Option</A></DD>
<DD><A HREF="#SORT_Directive">The SORT Directive</A></DD>
<DD><A HREF="#Special_System_Names">Special System Names</A></DD>
<DD><A HREF="#STACK_Option">The STACK Option</A></DD>
<DD><A HREF="#STANDARD_Option">The STANDARD Option</A></DD>
<DD><A HREF="#START_Option">The START Option</A></DD>
<DD><A HREF="#STARTLINK_Directive">The STARTLINK Directive</A></DD>
<DD><A HREF="#STATICS_Option">The STATICS Option</A></DD>
<DD><A HREF="#STUB_Option">The STUB Option</A></DD>
<DD><A HREF="#SYMFILE_Option">The SYMFILE Option</A></DD>
<DD><A HREF="#SYMTRACE_Directive">The SYMTRACE Directive</A></DD>
<DD><A HREF="#SYNCHRONIZE_Option">The SYNCHRONIZE Option</A></DD>
<DD><A HREF="#SYSTEM_Directive">The SYSTEM Directive</A></DD>
<DT>- T -</DT>
<DD><A HREF="#THREADNAME_Option">The THREADNAME Option</A></DD>
<DD><A HREF="#TOGGLERELOCS_Option">The TOGGLERELOCS Option</A></DD>
<DD><A HREF="#Typing_Information_M_DEBUG_WATCOM_TYPES">Typing Information - DEBUG WATCOM TYPES</A></DD>
<DT>- U -</DT>
<DD><A HREF="#UNDEFSOK_Option">The UNDEFSOK Option</A></DD>
<DD><A HREF="#Using_DEBUG_Directives">Using DEBUG Directives</A></DD>
<DD><A HREF="#Using_the_SYSTEM_Directive">Using the SYSTEM Directive</A></DD>
<DT>- V -</DT>
<DD><A HREF="#VECTOR_Directive">The VECTOR Directive</A></DD>
<DD><A HREF="#VERBOSE_Option">The VERBOSE Option</A></DD>
<DD><A HREF="#VERSION_Option">The VERSION Option</A></DD>
<DD><A HREF="#VFREMOVAL_Option">The VFREMOVAL Option</A></DD>
<DT>- W -</DT>
<DD><A HREF="#Win16__Creating_a_Dynamic_Link_Library">Win16:&nbsp; Creating a Dynamic Link Library</A></DD>
<DD><A HREF="#Win16__Discardable_Segments">Win16:&nbsp; Discardable Segments</A></DD>
<DD><A HREF="#Win16__Dynamic_Link_Libraries">Win16:&nbsp; Dynamic Link Libraries</A></DD>
<DD><A HREF="#Win16__Fixed_and_Moveable_Segments">Win16:&nbsp; Fixed and Moveable Segments</A></DD>
<DD><A HREF="#Win16__Memory_Layout">Win16:&nbsp; Memory Layout</A></DD>
<DD><A HREF="#Win16_Executable_and_DLL_File_Formats">Win16 Executable and DLL File Formats</A></DD>
<DD><A HREF="#Win16__Using_a_Dynamic_Link_Library">Using a Dynamic Link Library in Win16</A></DD>
<DD><A HREF="#Win32__Creating_a_Dynamic_Link_Library">Creating a Dynamic Link Library for Win32/Win64</A></DD>
<DD><A HREF="#Win32__Dynamic_Link_Libraries">Dynamic Link Libraries in Win32/Win64</A></DD>
<DD><A HREF="#Win32__Memory_Layout">Memory Layout of Win32/Win64 Binaries</A></DD>
<DD><A HREF="#Win32_Executable_and_DLL_File_Formats">Win32/Win64 Executable and DLL File Formats</A></DD>
<DD><A HREF="#Win32__Using_a_Dynamic_Link_Library">Using a Dynamic Link Library in Win32/Win64</A></DD>
<DD><A HREF="#WinVxD__Memory_Layout">WinVxD:&nbsp; Memory Layout</A></DD>
<DD><A HREF="#Windows_Virtual_Device_Driver_File_Format">Windows Virtual Device Driver File Format</A></DD>
<DT>- X -</DT>
<DD><A HREF="#XDCDATA_Option">The XDCDATA Option</A></DD>
<DT>- Z -</DT>
</DL>

</BODY>
